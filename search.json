[{"title":"SRS(2)-state thread框架","path":"/2025/08/05/SRS_2/","content":"SRS的协程是基于State-thread（ST）开发的，这篇文章希望能够理清这个框架的基本思路。本篇文章部分讲解来自文章 类似框架首先应该以一个宏观角度去审视框架。业内还有很多类似的协程框架。 首先是libco，这是一个微信开源的CC++协程库，不同于本文提到的ST，这个框架使用了共享栈技术，多个协程在运行时可以分时复用同一块栈内存。 另外是Libgo，可以提供类似Go语言的并发编程体验。它支持多线程调度（work-stealing）、Channel通信、协程局部存储（CLS）等高级特性。 Boost.Coroutine2: C++ Boost库提供的官方协程组件。它更底层、更灵活，提供了构建协程所需的核心能力（上下文切换），但需要用户自己基于它来构建完整的调度器和IO事件循环。 语言级别的协程支持，是未来的标准方向。通过co_await, co_yield, co_return等关键字，编译器会自动将一个函数转换成状态机，从而实现协程。它与语言结合得最紧密，但需要异步框架（如asio）的配合来驱动IO事件。 ST框架结构核心结构体_st_vp_ttypedef struct _st_vp st_utime_t last_clock; /* The last time we went into vp_check_clock() */ //下面是四种线程状态 _st_thread_t *idle_thread; //idle微线程是框架创建的微线程，只有在没有其他微线程可以调度时，才会被调度执行。主要任务是调用IO多路复用函数等待IO事件和处理定时器。 _st_clist_t run_q; //可运行的微线程，等待框架调度即可运行。 _st_clist_t io_q; //当微线程需要等待IO事件时，会被放到IO等待队列中。当等待的IO事件发生 或者 超时 或者 被中断时，会从IO等待队列中移除并加入到runable队列中。 _st_clist_t zombie_q; //当微线程结束时，如果设置了joinable，即需要其他微线程‘收尸’，就会添加到zombie队列。#ifdef DEBUG _st_clist_t thread_q; /* all threads of this vp */#endif int pagesize; _st_thread_t *sleep_q; //数据结构为完全二叉树组织的最小堆结构，当微线程设置了定时器时，就会根据超时时间添加到树中。 int sleepq_size; /* number of threads on sleep queue */#ifdef ST_SWITCH_CB st_switch_cb_t switch_out_cb;\t/* called when a thread is switched out */ st_switch_cb_t switch_in_cb;\t/* called when a thread is switched in */#endif _st_vp_t; st_thread_ttypedef struct _st_thread int state; /* Threads state */ int flags; /* Threads flags */ void *(*start)(void *arg); /* The start function of the thread */ void *arg; /* Argument of the start function */ void *retval; /* Return value of the start function */ _st_stack_t *stack; /* Info about threads stack */ _st_clist_t links; /* For putting on run/sleep/zombie queue */ _st_clist_t wait_links; /* For putting on mutex/condvar wait queue */ st_utime_t due; /* Wakeup time when thread is sleeping */ _st_thread_t *left; /* For putting in timeout heap */ _st_thread_t *right; /* -- see docs/timeout_heap.txt for details */ int heap_index; void **private_data; /* Per thread private data */ _st_cond_t *term; /* Termination condition variable for join */ jmp_buf context; /* Threads context */ _st_thread_t; st_stack_ttypedef struct _st_stack // 指向实际栈内存块的起始虚拟地址。 // 这块内存通常是通过 mmap 系统调用从操作系统申请的一段连续虚拟内存。 // 协程的所有函数调用、局部变量都存放在这块内存区域中。 void *v_addr; // 栈内存块的实际大小（以字节为单位）。 // 这个大小是在创建时确定的，例如 64KB。 int v_size; // 指向下一个 st_stack_t 结构体的指针。 // 这是实现“空闲栈缓存池”的关键所在。当一个协程结束，它所使用的栈不会被立即释放， // 而是通过这个 next 指针被链接到一个全局的空闲链表（free list）中。 // 当需要创建新协程时，框架会优先从这个链表中获取一个已分配的栈，从而避免了昂贵的 mmap 调用。 struct _st_stack *next; st_stack_t; 微线程状态和分类// 微线程状态定义#define _ST_ST_RUNNING 0 // 执行中 #define _ST_ST_RUNNABLE 1 // 可执行状态，等待调度#define _ST_ST_IO_WAIT 2 // 等待IO事件#define _ST_ST_LOCK_WAIT 3 // 等待互斥锁#define _ST_ST_COND_WAIT 4 // 等待条件变量#define _ST_ST_SLEEPING 5 // sleep#define _ST_ST_ZOMBIE 6 // 微线程已结束，待其他微线程调用st_thread_join收尸#define _ST_ST_SUSPENDED 7 // 暂停，只能调用st_thread_interrupt唤醒// 微线程flag定义#define _ST_FL_PRIMORDIAL 0x01 // 原生微线程，即不是创建的微线程，没有分配私有栈资源#define _ST_FL_IDLE_THREAD 0x02 // 空闲处理微线程，用于调用epoll，处理定时器#define _ST_FL_ON_SLEEPQ 0x04 // 微线程在sleep队列中，需要定时器的情况：调用st_usleep、st_cond_timedwait、st_poll等待IO事件等#define _ST_FL_INTERRUPT 0x08 // 微线程被调用st_thread_interrupt()中断#define _ST_FL_TIMEDOUT 0x10 // 微线程定时器超时 同时微线程被分成了三种角色，分别是Primordial、Idle、User Primoodial，当函数A调用st_init的时候，ST会将函数A的上下文包装成一个协程，负责初始化整个协程。 User，由用户通过st_thread_create函数创建，负责具体的业务逻辑。 Idle，同样是在st_init时被创建并维护，当ST中没有User正在运行时，会调用Idle微线程，用IO事件轮询器（如poll()或epoll_wait()），并把自己挂起，从而让整个进程进入睡眠状态，等待内核的唤醒。// idle微线程执行的start函数void *_st_idle_thread_start(void *arg) _st_thread_t *me = _ST_CURRENT_THREAD(); while (_st_active_count 0) /* Idle vp till I/O is ready or the smallest timeout expired */\t// 调用IO多路复用函数（epoll，select等）等待IO事件发生，并处理所有发生的IO事件，\t// 如果微线程等待的IO事件发生，会将微线程从io等待队列st_vp_t.io_q中移除\t// 并加入到runable队列st_vp_t.run_q _ST_VP_IDLE(); /* Check sleep queue for expired threads */\t// 检查微线程设置的定时器是否超时，针对超时的微线程，将其从sleep队列移除\t// 并加入到runable队列 _st_vp_check_clock();\t// 交出运行权，并从runable队列st_vp_t.run_q中调度下一个微线程运行 me-state = _ST_ST_RUNNABLE; _ST_SWITCH_CONTEXT(me); /* No more threads */ exit(0); /* NOTREACHED */ return NULL; 初始化、创建、销毁流程初始化// 框架初始化函数int st_init(void) _st_thread_t *thread; if (_st_active_count) /* Already initialized */ return 0; // 选择使用哪个IO多路复用函数，如epoll、select等 st_set_eventsys(ST_EVENTSYS_DEFAULT); // 屏蔽SIGPIPE信号 并 初始化IO多路复用函数相关数据结构 if (_st_io_init() 0) return -1; memset(_st_this_vp, 0, sizeof(_st_vp_t)); // 清空runable队列、io等待队列、zombie队列 ST_INIT_CLIST(_ST_RUNQ); ST_INIT_CLIST(_ST_IOQ); ST_INIT_CLIST(_ST_ZOMBIEQ); // 调用IO多路复用函数对应的初始化函数 if ((*_st_eventsys-init)() 0) return -1; _st_this_vp.pagesize = getpagesize(); _st_this_vp.last_clock = st_utime(); // 创建idle微线程，idle微线程主要用于调用epoll等待IO事件和处理定时器 _st_this_vp.idle_thread = st_thread_create(_st_idle_thread_start, NULL, 0, 0); if (!_st_this_vp.idle_thread) return -1; _st_this_vp.idle_thread-flags = _ST_FL_IDLE_THREAD; _st_active_count--; // 将idle微线程从runable队列移除，由于idle微线程只在没有微线程可以运行时，才会主动调度， // 所以不需要加入到run队列 _ST_DEL_RUNQ(_st_this_vp.idle_thread); // 初始化primordial微线程，primordial微线程用来标记系统进程，由于可以直接使用 // 系统进程的栈空间，故只需要为primordial微线程分配st_thread_t和私有key数据区 thread = (_st_thread_t *)calloc(1, sizeof(_st_thread_t) + (ST_KEYS_MAX * sizeof(void *))); if (!thread) return -1; thread-private_data = (void **)(thread + 1); thread-state = _ST_ST_RUNNING; thread-flags = _ST_FL_PRIMORDIAL; _ST_SET_CURRENT_THREAD(thread); _st_active_count++; // 当前运行的微线程是primordial微线程，当primordial微线程退出时，整个进程也会终止 return 0; 微线程创建 // 创建微线程函数_st_thread_t *st_thread_create(void *(*start)(void *arg), void *arg, int joinable, int stk_size)\t_st_thread_t *thread;\t_st_stack_t *stack;\tvoid **ptds;\tchar *sp; //step 1\tif (stk_size == 0) stk_size = ST_DEFAULT_STACK_SIZE; // 默认栈空间为64K\t// 将栈空间调整为PAGE_SIZE的整数倍\tstk_size = ((stk_size + _ST_PAGE_SIZE - 1) / _ST_PAGE_SIZE) * _ST_PAGE_SIZE;\t// 分配微线程使用的私有数据空间：包括栈空间，私有key数据区，st_thread_t结构体等\t// 为了避免频繁调用系统分配函数分配微线程栈空间，框架中保存了stack空闲链表，\t// 会优先从空闲链表获取，当空闲链表为空时，会从系统分配\tstack = _st_stack_new(stk_size);\tif (!stack) return NULL; //step 2\t// 初始化分配好的空间\tsp = stack-stk_top;\tsp = sp - (ST_KEYS_MAX * sizeof(void *));\tptds = (void **)sp;\tsp = sp - sizeof(_st_thread_t);\tthread = (_st_thread_t *)sp;\t// 保证栈可用位置一定是64字节对齐的\tif ((unsigned long)sp 0x3f) sp = sp - ((unsigned long)sp 0x3f);\tstack-sp = sp - _ST_STACK_PAD_SIZE;\t// 分配的空间重置为0，因为stack可能是从空闲链表中获取的\tmemset(thread, 0, sizeof(_st_thread_t));\tmemset(ptds, 0, ST_KEYS_MAX * sizeof(void *));\tthread-private_data = ptds;\tthread-stack = stack;\tthread-start = start;\tthread-arg = arg; //step 3\t// 调用setjmp保存当前的上下文信息到jmp_buf中，主要功能是初始化jmp_buf\t// 因为现在保存到jmp_buf中的信息不会在微线程的后续运行中使用到\tif (setjmp(thread-context)) // 当微线程首次被调度运行时，会进入该分支，并调用_st_thread_main函数执行 _st_thread_main();\t// 非常重要的一点：设置jmp_buf中的rsp指向为微线程分配的私有栈空间的可用位置\t// 这样可以保证框架中不同微线程运行在自己的私有栈空间上\tthread-context[JB_RSP] = (long)(stack-sp);\t// 如果微线程是可joinable的，就创建一个微线程终止时使用的条件变量\t// 当该微线程终止时会等待在该条件变量上，当其他微线程调用st_thread_join函数\t// 替该微线程收尸后，该微线程才会真正终止\tif (joinable) thread-term = st_cond_new(); if (thread-term == NULL) _st_stack_free(thread-stack); return NULL; // 设置为runable状态，并 加入到runable队列中\tthread-state = _ST_ST_RUNNABLE;\t_st_active_count++;\t_ST_ADD_RUNQ(thread);\treturn thread;// 微线程启动后调用的main函数void _st_thread_main(void)\t_st_thread_t *thread = _ST_CURRENT_THREAD();\t/*\t* Cap the stack by zeroing out the saved return address register\t* value. This allows some debugging/profiling tools to know when\t* to stop unwinding the stack. Its a no-op on most platforms.\t*/\tMD_CAP_STACK(thread);\t// 调用微线程设置的start函数\tthread-retval = (*thread-start)(thread-arg);\t// 清理微线程使用的资源\tst_thread_exit(thread-retval); 创建微线程使用的私有栈-初始化私有栈-调用setjmp并修改jmp_buf 在创建微线程的过程中，核心在于，st_thread_create并不会直接让协程跳转到用户指定的函数（start_routine）。而是跳转到一个由ST框架提供的、名为_st_thread_main的内部包裹函数。creat这个函数是目前我见过最复杂的一个函数了，后续再去学习吧。。。 微线程切换与调度 // 切换_thread微线程出去，并调度下一个runable状态的微线程运行#define _ST_SWITCH_CONTEXT(_thread) \\ \\ if (!setjmp(_thread-context)) \\ _st_vp_schedule(); \\ \\ // 微线程调度逻辑，即调度下一个runable状态微线程运行void _st_vp_schedule(void)\t_st_thread_t *thread;\t// 如果runable队列_st_this_vp.run_q非空，就选队列首的微线程\t// 否则调度idle微线程运行\tif (_ST_RUNQ.next != _ST_RUNQ) thread = _ST_THREAD_PTR(_ST_RUNQ.next); _ST_DEL_RUNQ(thread); else thread = _st_this_vp.idle_thread; // 设置选中的微线程的状态为running状态，并调用longjmp函数跳转到选中的微线程， // 选中的微线程从最后一次的setjmp位置继续运行\tthread-state = _ST_ST_RUNNING;\t_ST_SET_CURRENT_THREAD(thread);\tlongjmp(thread-context, 1) 线程终止 // 微线程终止时调用的函数void st_thread_exit(void *retval)\t_st_thread_t *thread = _ST_CURRENT_THREAD();\tthread-retval = retval;\t// 释放微线程运行期间调用st_thread_setspecific设置的私有key数据\t_st_thread_cleanup(thread);\t_st_active_count--;\t// 如果创建了term条件变量，需要通知调用st_thread_join()等待该微线程的微线程为该\t// 微线程“收尸”\tif (thread-term) // 添加到zombie队列 thread-state = _ST_ST_ZOMBIE; _ST_ADD_ZOMBIEQ(thread); // 通知等待在term条件变量上的微线程 st_cond_signal(thread-term); // 交出控制权，等到为本线程收尸的微线程调用st_thread_join()返回 // 后，本微线程才会switch回来，并恢复运行 _ST_SWITCH_CONTEXT(thread); // 清理条件变量 st_cond_destroy(thread-term); thread-term = NULL; // 如果终止的不是Primordial微线程，就释放为微线程分配的私有栈空间，\t// 释放的栈空间会放到空闲链表中\tif (!(thread-flags _ST_FL_PRIMORDIAL)) _st_stack_free(thread-stack);\t// 交出控制权，并调度下一个runable状态的微线程，微线程生命周期终止\t_ST_SWITCH_CONTEXT(thread);\t/* Not going to land here */","tags":["SRS","state thread框架","协程"],"categories":["technology","编程基础","音视频"]},{"title":"SRS(1)-架构分析(WIP)","path":"/2025/08/04/SRS_1/","content":"开始研读SRS项目源码，自然就是先从wiki和架构开始。wiki的第一部分是其支持的一些协议，以及协议的核心配置项。在项目实战的时候应该针对具体的业务场景，针对专门的业务需求进行配置层面，甚至源码层面的优化。 第二部分是核心功能，也就是本篇文章想要聊的部分。这个部分会随着源码的阅读不断进行更新-纠错等。 设计思想源服务器-边缘服务器-客户端在这种架构分解中，源服务器负责接收、编码、存储音视频流；边缘服务器负责分发音视频流；客户端则负责接收、播放等。 基于协程单线程架构与之前聊过的回调地狱以及多线程巨大开销不同，基于state-thread协程库的开发，能够使编码方式更像同步。同时阅读代码的难度也是真的降低了很多（相比于恶心的回调函数方式）. 层级结构 接入层：负责处理底层的IO请求，协议解析等。 核心逻辑层： srscource：将推送到服务器的音视频流抽象成一个对象。负责缓存最近的GOP、管理消费者、并且实现数据的分发， srsconsumer：每个客户端都对应一个实例，从Srssource中拉去音视频数据，并根据客户端协议进行打包发送。 功能模块：诸如录制，转码、HLS切片等操作。 扩展层： HTTP-API： 提供了一套完整的RESTful API，用于外部系统查询服务器状态、管理流、配置热更新等。 HTTP-Callback （Webhook）：这是SRS扩展性的关键。在， ， 等关键业务节点，SRS会主动向您配置的业务服务器发送HTTP请求，从而可以轻松实现推流鉴权、流量统计、与业务系统深度集成等定制化需求。on_publishon_playon_done Prometheus Exporter： 内置了对Prometheus监控的支持，可以方便地将SRS纳入云原生的可观测性（Observability）体系。 核心功能HTTP服务器 SRS主服务框架是一个基于协程的，事件驱动的网络服务器框架。其内嵌了HTTP服务器，完成诸多功能： 流媒体分发（接入层）：例如hlv hls DASH的分发，都是通过HTTP的API实现的。 管理与控制（扩展层）：例如HTTP RESTful API，可以通过简单的HTTP GET\\POST请求来查询所有流、所有客户端的状态，并且能够实现控制客户端，控制DVR，动态热加载等等功能。 HTTP callback: 可以利用这个API实现回调功能，实现流媒体核心与复杂的业务逻辑之间的解耦。例如SRS接收到on_play命令时会回调立刻HTTP的API，同理接收到on_stop的时候也会回调api实现业务上的计时收费等功能。 DVR(digital video recording)我认为在具体聊这个功能之前首先要明白设定这个功能的意义，为什么需要服务器来实现一个录制功能呢？ 应用场景：直播领域。一方面是为了对即时性的直播的保存，通过录制直播将其转化为长久的点播内容。另一方面是为了满足监管机构对于直播内容需要存档的要求。 为什么要在服务器端完成这件事？第一自然是效率问题，作为服务器，流本身就会在其内部进行流转，过程中将其写入本地文件自然不难。第二可以降低客户端对于带宽，设备等的要求，简化了推流端的流程与配置。 DVR的工作流程当一个流推送到SRS时，SRS会在核心SrsSource结构体上挂载一个额特殊的消费者，即DVR，这个消费者将接收到的流数据写入到文件中，实现录制效果。 Stream Converter（Ingest） 应用场景 用于主动去拉取那些不支持向SRS主动推流的外部源，然后将这些拉取到的流注入(Ingest)到SRS内部。例如安防领域，摄像头（IP camera）通常是不支持主动推流的，于是便可以在SRS中配置一个ingest项，启动ffmpeg，并主动像一个IP进行拉流，并以RTMP协议推送到SRS自己的RTMP端口上。 实时转码：通过Ingest使用ffmpeg独立进程完成协议的转换编解码，能够实现解耦，以及实时性的要求。毕竟SRS的核心在于分发，而不是编解码，将这一功能外包给独立的ffmpeg进程，能够保证SRS核心的轻量化。 工作流程这就与FFmpeg紧密相关了，这里不再赘述了 Forward For Small Cluster这是一个服务器端的，主动的，流复制和推送功能。当一台SRS服务器（我们称之为“主服务器”）接收到一路直播推流后，如果配置了Forward功能，这台主服务器会立即、主动地将这路流原封不动地转发到一台或多台其他的服务器上。通过这样的做法一是实现服务器的备份。实现当主服务器产生故障时，能够热切换到备用服务器上。二是实现跨地区的分发，例如亚洲和北美的两台主服务器。三是能够对转发的这一路流做更多处理而不影响到主服务器的流。 但是主服务器每增加一个Forward目标，就需要消耗一份额外的CPU和上行带宽来推送这份流的拷贝。如果有1路流，要转发给10台服务器，主服务器就需要承担1路推流进入和10路推流出去的网络负载。当目标服务器数量很多时（例如几十上百台），主服务器的带宽和CPU会迅速成为瓶颈，整个集群的扩展性会很差。 基本的客户端安全配置例如踢掉连接用户等。 截图有多个API可以调用，例如HTTP(提供回调，最终是使用ffmpeg进程来截图),Transcoder","tags":["SRS"],"categories":["technology","音视频"]},{"title":"回调函数","path":"/2025/07/31/回调函数/","content":"回调本身有多种形式，下面一一介绍 封装式延迟回调class Task public: typedef void (*TaskCallback)(void*);//为 ‘一个指向“返回值为void，参数为void*”的函数’ 的指针类型，创建一个新的类型别名，名为 TaskCallback。” Task():mTaskCallback(NULL),mArg(NULL) ;//当你创建一个 Task 对象时，它内部的函数指针 mTaskCallback 和参数指针 mArg 都被初始化为 NULL。 void setTaskCallback(TaskCallback cb, void* arg) mTaskCallback = cb; mArg = arg; void handle() if(mTaskCallback) mTaskCallback(mArg); bool operator=(const Task task) this-mTaskCallback = task.mTaskCallback; this-mArg = task.mArg; private: TaskCallback mTaskCallback; void* mArg;; 在上面的回调函数定义中，首先定义别名，具体见上，其中void*是一个通用指针，可以指向任何类型数据。为了充分说明，我们定义一个处理函数。 // 假设有一个连接信息的结构体struct ConnectionInfo int socket_fd; std::string client_ip;;// 定义一个符合 TaskCallback 签名的函数void handle_connection(void* arg) // 将 void* 转换回原始类型 ConnectionInfo* info = static_castConnectionInfo*(arg); printf(Handling connection from IP: %s on socket %d , info-client_ip.c_str(), info-socket_fd); // ... 在这里执行具体的读写操作 ... // 清理资源 delete info; 接下来通过set方法装载，myTask.setTaskCallback(handle_connection, connectionData);,执行完这步后，myTask 对象内部的 mTaskCallback 指向了 handle_connection 函数，mArg 指向了 connectionData 对象的内存地址。 需要的时候，系统的其他部分（比如一个线程池或者事件循环）只需要调用 Task 对象的 handle() 方法，就可以执行被封装的任务，而无需关心任务具体是什么。 这种模式非常适用于：1.线程池任务队列：主线程创建一堆 Task 对象（通过 set 配置好），然后把这些对象扔进一个队列。工作线程不断从队列中取出 Task 对象，并调用它们的 handle() 方法。 2.事件驱动编程：当某个事件发生时，事件循环调用对应事件处理程序（一个 Task 对象）的 handle() 方法。 3.实现解耦：调用 handle() 的代码完全不知道它到底在执行哪个具体函数，它只知道如何执行一个 Task。 普通回调这种方式就是网上非常常见的，这里不做赘述，贴上gpt代码 #include stdio.h#include stdlib.h// 这是一个回调函数，告诉qsort如何比较两个整数int compare_integers(const void* a, const void* b) int val1 = *(int*)a; int val2 = *(int*)b; return (val1 - val2);int main() int numbers[] = 5, 2, 8, 1, 9; int n = sizeof(numbers) / sizeof(numbers[0]); // 调用qsort，直接把回调函数 compare_integers 作为参数传进去 qsort(numbers, n, sizeof(int), compare_integers); for(int i = 0; i n; i++) printf(%d , numbers[i]); printf( ); return 0; 现代C++中的lamda与function std::function: 一个通用的、多态的函数封装器。它可以存储、复制和调用任何“可调用对象”（普通函数、Lambda表达式、成员函数、函数对象等）。它完美替代了 void (TaskCallback)(void)。 Lambda表达式: 一种在源代码中定义匿名函数的方式。它可以方便地“捕获”上下文中的变量，从而完全避免使用不安全的 void*。 #include iostream#include functional // 需要包含这个头文件#include stringclass ModernTask public: // 使用 std::function，它可以持有任何无参数、无返回值的可调用对象 // 这比C风格的函数指针更强大、更安全 using TaskCallback = std::functionvoid(); ModernTask() = default; // 使用默认构造函数 // set函数现在接受一个 std::function 对象 void setTask(TaskCallback cb) mTaskCallback = cb; // handle函数保持不变 void handle() if (mTaskCallback) // 检查是否有效 mTaskCallback(); // 直接调用 private: TaskCallback mTaskCallback;;// 使用示例struct ConnectionInfo int socket_fd; std::string client_ip;;int main() ModernTask myTask; ConnectionInfo connectionData = 10, 192.168.1.101; // 使用Lambda表达式来创建回调 // [=] 表示按值捕获所有外部变量 (这里是connectionData) myTask.setTask([=]() // 在Lambda内部，可以直接访问 connectionData，无需 void* 转换 std::cout Handling connection from IP: connectionData.client_ip on socket connectionData.socket_fd std::endl; ); myTask.handle(); return 0;","tags":["回调函数"],"categories":["technology","编程基础"]},{"title":"socket编程","path":"/2025/07/23/socket编程/","content":"以下部分内容参考文章Socket本质上就是对TCPIP协议组的封装。是应用层与传输层通信的中间层。从设计模式角度而言，Socket实际上是一组接口，。用户通过这些接口去组织数据，以符合指定的协议。Socket有三种类型， SOCK_STREAM 面向稳定通信，底层是TCP SOCK_DGRAM 无连接的通信，底层是UDP，需要上层协议来保证可靠性。 SOCK_RAW 更加灵活的数据控制，可以指定IP头部。 常用Socket编程接口 socket()：创建socket bind()：绑定socket到本地地址和端口，通常由服务端调用 listen()：TCP专用，开启监听模式 accept()：TCP专用，服务器等待客户端连接，一般是阻塞态 connect()：TCP专用，客户端主动连接服务器 send()：TCP专用，发送数据 recv()：TCP专用，接收数据 sendto()：UDP专用，发送数据到指定的IP地址和端口 recvfrom()：UDP专用，接收数据，返回数据远端的IP地址和端口 closesocket()：关闭socket Socket通信流程TCP流程 UDP流程需要注意，TCP和UDP的端口互不干扰，所以说系统可以同时开启TCP80端口和UDP80端口 网络编程模型 同步阻塞迭代模型bind(srvfd);listen(srvfd);for(;;) clifd = accept(srvfd,...); //开始接受客户端来的连接 read(clifd,buf,...); //从客户端读取数据 dosomthingonbuf(buf); write(clifd,buf)//发送数据到客户端 上述程序弊端： 如果没有客户端的连接请求，进程会阻塞在accept系统调用处，程序不能执行其他任何操作。(系统调用使得程序从用户态陷入内核态) 在与客户端建立好一条链路后，通过read系统调用从客户端接受数据，而客户端发送数据过来是不可控的。如果客户端迟迟不发生数据过来，则程序同样会阻塞在read调用，此时，如果另外的客户端来尝试连接时，都会失败。 同样的道理，write系统调用也会使得程序出现阻塞(例如：客户端接受数据异常缓慢，导致写缓冲区满，数据迟迟发送不出)。 多进程并发模型多进程并发模型在同步阻塞迭代模型的基础上进行了一些改进，以避免是程序阻塞在read系统调用上。核心代码如下： bind(srvfd);listen(srvfd);for(;;)clifd = accept(srvfd,...); //开始接受客户端来的连接ret = fork();switch( ret ) case -1 : do_err_handler(); break; case 0: // 子进程 client_handler(clifd); break ; default : // 父进程 close(clifd); continue ;void client_handler(clifd) read(clifd,buf,...); //从客户端读取数据 dosomthingonbuf(buf); write(clifd,buf)//发送数据到客户端 多线程并发模型在多进程并发模型中，每一个客户端连接开启fork一个进程，若客户端连接较大，则系统依然将不堪负重。通过多线程(或线程池)并发模型，可以在一定程度上改善这一问题。 在服务端的线程模型实现方式一般有三种： 按需生成(来一个连接生成一个线程) 线程池(预先生成很多线程) Leader follower（LF）以第一种为例，其核心代码如下：void *thread_callback( void *args ) //线程回调函数 int clifd = *(int *)args ; client_handler(clifd);void client_handler(clifd) read(clifd,buf,...); //从客户端读取数据 dosomthingonbuf(buf); write(clifd,buf)//发送数据到客户端bind(srvfd);listen(srvfd);for(;;) clifd = accept(); pthread_create(...,thread_callback,clifd); 在这个模型中，服务端分为了两个线程，一是负责业务逻辑和流的读取。二是accept链接。 IO多路复用多进程模型和多线程(线程池)模型每个进程线程只能处理一路IO，在服务器并发数较高的情况下，过多的进程线程会使得服务器性能下降。而通过多路IO复用，能使得一个进程同时处理多路IO，提升服务器吞吐量。这是一种进程预先告知内核的能力，让内核发现进程指定的一个或多个IO条件就绪了，就通知进程。使得一个进程能在一连串的事件上等待。IO复用的实现方式目前主要有select、poll和epoll。select和poll的原理基本相同： 注册待侦听的fd(这里的fd创建时最好使用非阻塞) 每次调用都去检查这些fd的状态，当有一个或者多个fd就绪的时候返回 返回结果中包括已就绪和未就绪的fd 相比select，poll解决了单个进程能够打开的文件描述符数量有限制这个问题：select受限于FD_SIZE的限制，如果修改则需要修改这个宏重新编译内核；而poll通过一个pollfd数组向内核传递需要关注的事件，避开了文件描述符数量限制。此外，select和poll共同具有的一个很大的缺点就是包含大量fd的数组被整体复制于用户态和内核态地址空间之间，开销会随着fd数量增多而线性增大。epoll的出现，解决了select、poll的缺点： 基于事件驱动的方式，避免了每次都要把所有fd都扫描一遍。 epoll_wait只返回就绪的fd。 epoll使用nmap内存映射技术避免了内存复制的开销。 epoll的fd数量上限是操作系统的最大文件句柄数目,这个数目一般和内存有关，通常远大于1024。 select：支持注册 FD_SETSIZE(1024) 个 socket。 poll： poll 作为 select 的替代者，最大的区别就是，poll 不再限制 socket 数量。 epoll：epoll 能直接返回具体的准备好的通道，时间复杂度 O(1)。 C在win平台创建socket的实例WSADATA wsaData; //启动socket /* Param1：MAKEWORD 请求的winsock版本 Param2：指向WSADATA的指针 */ if (WSAStartup(MAKEWORD(2, 2), wsaData) != 0) printf(PC Server Socket Start Up Error ); return -1; int serverSockfd; /* 创建socket，这里由于我做的是RTSP服务器，所以做了封装， 但基本函数就是 SOCKET sock = socket(AF_INET, SOCK_STREAM, 0); */ serverSockfd = createTcpSocket(); if (serverSockfd 0) WSACleanup(); printf(failed to create tcp socket ); return -1; //bind if (bindSocketAddr(serverSockfd, 0.0.0.0, SERVER_PORT) 0) printf(failed to bind addr ); return -1; //listen if (listen(serverSockfd, 10) 0) printf(failed to listen ); return -1; printf(%s rtsp://127.0.0.1:%d ,__FILE__, SERVER_PORT); //循环接收 while (true) int clientSockfd; char clientIp[40]; int clientPort; clientSockfd = acceptClient(serverSockfd, clientIp, clientPort); if (clientSockfd 0) printf(failed to accept client ); return -1; printf(accept client;client ip:%s,client port:%d , clientIp, clientPort); doClient(clientSockfd, clientIp, clientPort); //注意释放顺序 closesocket(serverSockfd); WSACleanup(); return 0;","tags":["网络编程","Socket"],"categories":["technology","编程基础"]},{"title":"音频重采样","path":"/2025/07/22/音频重采样/","content":"采样格式定义：采样格式指的是音频样本数据的数字表示方式。常见的格式包括脉冲编码调制（PCM）格式，它们可以是浮点数（如32位浮点）或整数（如16位或24位）。类型： PCM S16LES16BE：16位有符号整数，小端大端。这是CD音质的标准格式，提供足够的动态范围，文件大小适中。 PCM S24LES24BE：24位有符号整数，小端大端。提供更宽的动态范围，常用于专业音频录制。 PCM F32LEF32BE：32位浮点数，小端大端。允许极其宽的动态范围，但文件大小也较大。 选择考量：选择合适的采样格式通常要平衡音质需求、存储空间限制和系统兼容性。 多声道系统常见的多声道配置有 5.1 系统：包括前左、前右、中央、低频效果（LFE）、后左和后右六个声道。 7.1 系统：在 5.1 的基础上增加了两个侧面声道（侧左和侧右），以实现更全面的环绕声效果。 其他配置：如 9.1 系统等，根据不同的应用需求，可能会有更多的声道配置。 在这个部分引入音频帧的计算，方便我们下面进行pts、dts、cts分析 音频帧的数据量 采样率 * 采样位宽 * 声道数 * 时间 播放时间 总采样数采样率总采样数 = 音频帧数据量/声道数 各种官方文档都对这一部分有规定，总采样数（samples）指的是一个声道的采样，帧（frame）指的是一个时间点的样本集合，包（packet）指的是多个frame的集合 FFmpeg对于音频重采样的处理首先是配置上下文swr_alloc_set_opts；接下来对于swr_init初始化音频采样格式等基础信息；由swr_convert执行实际的重采样工作；最后由swr_free释放资源。","tags":["SLAM","概率"],"categories":["technology","SLAM"]},{"title":"流媒体基础","path":"/2025/07/18/直播结构/","content":"最近在研究直播系统的架构，在学习的过程中发现直播系统的结构很复杂，一方面是音视频传输过程中的协议不兼容，例如RTSP在现代播放器的不兼容，需要转码才能进行播放。另一方面则是附属功能的复杂，例如礼物，公屏互动等等。还有一方面则是多个拉流会导致拥塞情况，CDN的分发需要考虑高并发。所以准备一边做这个项目，一边从架构角度梳理一下直播系统的搭建过程中应该考虑的问题。 协议解析RTSP协议栈RTSP协议栈通常与live555 共同出现，在这个协议栈中包括RTP传输，RTCP质量评估，以及RTSP交互。已经有很多文章提到了，这里不再赘述 RTMP 连接：类似握手过程（三次）。 C0+C1： 客户端向服务器发送 C0（1字节，表明 RTMP 版本）和 C1（1536字节，包含时间戳等随机数据）两个数据块。 S0+S1+S2： 服务器收到 C0C1 后，立刻回复 S0（版本号）、S1（服务器版的时间戳和随机数据）和 S2（将客户端发来的 C1 数据原样返回）三个数据块。 C2： 客户端收到 S1 后，回复一个 C2 块（将服务器发来的 S1 数据原样返回）。 数据传输：TCP connect： 客户端向服务器发起connect命令，请求连接到服务器上的一个指定应用（Application）。例如rtmp:server.comlive这里的live就是应用名。这个消息里会包含一些参数，如 Flash 版本、编码信息等。 connect response： 服务器验证通过后，会返回一个成功响应，告知客户端可以继续。 createStream： 客户端发送createStream命令，请求服务器创建一个逻辑上的“流通道”，服务器会返回一个唯一的 Stream ID。后续的音视频数据都会在这个 ID 上传输。 publish： 客户端发送publish命令，并携带一个“流名称”（也叫 “stream key” 或 “secret”），告知服务器：“我准备好要往这个流通道上推送数据了，流的名字是 room123。 开始推流: 服务器验证publish命令成功后，客户端就可以正式开始发送音视频数据了。 在传输过程中，RTMP使用了基于chunk的流式结构，为了在一条 TCP 连接上同时传输音频、视频和控制信令而不互相阻塞，RTMP 会把大的数据（如一整个视频帧）拆分成小的“块”（Chunk）。每个 Chunk 都有一个自己的小头部，包含了这个块属于哪个流 （Stream ID）、消息类型、长度等信息。默认的 Chunk 大小是 128 字节。每个完整的音视频帧或元数据，在被拆分成 Chunk 之前，会被打包成一个带有“标签 （Tag）”的数据单元。这个 Tag 的结构（包括 Tag 类型是音频视频脚本数据、时间戳等）和 FLV 文件中的 Tag 结构是一模一样的。 RTMP是过去Flash时代常用的标准，但是由于与现在的浏览器不兼容，所以流的制作方面使用会变少。但是在内容推送方面还是用的最广。延迟相较于HLS低，但是没有WebRTC低。目前点播平台的主流方案就是RTMP推流，HLS负责分发。在这个过程中核心是媒体服务器，诸如SRS\\Nginx-RTMP\\Wpwza。它的职责就是接收来自推流端的唯一一路 RTMP 流，然后将其实时转封装 （transmux） 成包含多个码率的 HLS 切片和清单文件，供海量观众通过 CDN 拉取播放。 另外分发端方案还有Flv。由于flv和RTMP流的数据载体在结构上几乎是一致的，这种设计使得媒体服务器可以极其高效地在 RTMP 和 FLV 之间进行转换。由于没有 HLS 那样的切片和缓冲机制，HTTP-FLV 的延迟可以稳定在 2-5 秒，非常接近 RTMP。 由于它运行在标准的 HTTP 协议之上，可以轻松穿透防火墙，并且不需要像 RTMP 那样使用特殊的 1935 端口。借助flv.js这个强大的库，可以在所有支持 Media Source Extensions （MSE） 的现代浏览器中直接播放 HTTP-FLV 直播，无需 Flash 插件。而HLS兼容CDN，CDN对于HTTP文件下载的支持很完善，因此HLS的兼容性比HTTP-FLV 要好很多；同样HTTP-FLV的延迟比HLS要低很多，基本上可以做到3的5秒左右延迟，而HLS的延迟一般是8到10秒以上。 HLS MPEG-DASH 信令：HTTP 数据传输：基于TCP的HTTP 媒体容器：MPEG-2 TS（用于 HLS）、ISO BMFF （MP4）（用于 DASH 和更新的 HLS）。 有很多优点，但是流的延迟很大，在网上看到的资料大约都是10s左右。这个协议是将流切片，通过HTTP服务器提供发送服务，分片下载。也是比较适合点播，由于依靠标准的web服务器，和CDN能够轻松的扩展几百万的观众，TCP又可以确保可靠交付。还具备自适应比特率，防火墙遍历。 webrtc基于Webrtc的开发一方面延迟极低，另一方面网络拥塞等控制也会很好。它并不是一个单一的协议，而包括了一系列的API和协议，是一个综合性的框架。 SRT 数据传输：UDP，但是在数据包级别实现了自己的ARQ机制（自动重复请求），保证了可靠性 目前准备替代RTMP的协议，基本上只要在网上搜索RTMP实现直播，那么一定会有人说RTMP的不兼容和服务器端转协议问题。而与之相对应的就是SRT的流行。 SRT使用的封装是TS封装，因此对于新的Codec天然就支持。而SRT基于UDP协议，因此对于延迟和弱网传输，也比RTMP要好不少。 一般RTMP延迟在1到3秒以上，而SRT的延迟在300到500毫秒，而且在弱网下表现也很稳定。在广播电视l领域，由于长距离跨国跨地区 传输，或者户外广播时，网络不稳定，因此SRT比RTMP的优势会更明显。 SRT是SRS的核心协议，SRS早在2020年即支持了SRT协议，并且在2022年实现了SRT协程化，从而大幅提高了SRT和其他核心协议的一致性。 比如回调和API的支持，SRT和RTMP保持了非常高的一致性。 架构分析推流端推流端可以使用OBS，推送到对应的端口。采用的协议可以是RTSP、RTMP、SRT。 服务器用来接收OBS的推流，可以使用Nginx来做架构。如果拉流端不兼容协议。服务器还需要对流本身进行转换。 拉流端如果选用浏览器，内嵌了播放器，需要向媒体服务器请求流并进行播放。采用的协议有HLS,DASH,HTTP-FLV,WebRTC 实现路线SRS (Simple Realtime Server): 支持RTMP, HLS, HTTP-FLV, WebRTC, SRT等多种协议。 Nginx + nginx-rtmp-module: 可以将接收到的RTMP流轻松转换为HLS或作为HTTP-FLV分发。但模块已多年未更新，对DASH、WebRTC等新协议支持不足。","tags":["RTSP","Nginx","HLS","RTMP"],"categories":["technology","音视频"]},{"title":"音视频控制流分析","path":"/2025/07/13/音视频控制流分析/","content":"最近在做一个本地播放器，这个播放器是从ffplay.c改编而来的，对源代码进行重构，并添加QT界面。其中的核心文件是videoctl，这篇文章目的在于细致的分析这个文件，进而理解播放器的工作流程。至于播放器的外围部分这里不做详细讨论，仅在第一节中进行阐述 undefined 播放器线程分配。 播放器组成 播放器前端是基于QT的，核心媒体处理分三个部分，一个是数据包的格式规定，一个是音视频的渲染，另一个则是音视频的控制。用户界面做了解耦处理，将信号和槽做多级触发。项目中的核心结构体是CurVideoState，在对这个结构体进行操作时要加线程锁，保证线程安全，例如执行全屏操作时，一方面是QT计算屏幕大小，一方面是SDL实现视频的缩放，刷新等等。这其中就多次涉及CurVideoState状态的改变，每次改变时都要注意为结构体加入线程锁。 注意关于界面的一些操作设置，例如单击鼠标，双击标题栏，拖动界面。通过注册表来实现软件启动时的默认设置，例如初始文件等。 全屏播放应该有两种方式，包括整体填充屏幕，和show组件填充屏幕 下面是ffmpeg解码的流程,结构体分析参考另一篇文章simplest——ffmpeg_player源码阅读 核心媒体处理 datactl.h : 媒体数据控制器，负责处理媒体数据流 ffplay_renderer.hc: 基于FFmpeg的渲染器，处理音视频解码和渲染 videoctl.hcpp: 视频控制器，管理视频播放、暂停等核心功能 用户界面组件 mainwindow.hcpp: 主窗口，应用程序的入口和主界面 ctlbar.hcpp: 控制栏，提供播放、暂停、音量等控制按钮 title.hcpp: 标题栏组件 show.hcpp: 显示区域，负责视频内容的显示 playlist.hcpp: 播放列表管理 medialist.hcpp**: 媒体列表组件 customslider.hcpp: 自定义滑块控件，可能用于进度条或音量控制 核心结构体 VideoState其中包括，指向解复用器的指针，线程句柄，音视频、外部时钟。强制刷新变量。视频状态变量等等多个变量的存储， 时钟类 MyAVpacketList其中存放packet的链表结构，并且每次拖动进度条会更新其中的serial字段。 PacketQueue定义Packet 队列自身属性，包括serial字段，包数量字段，队列所有元素数据大小字段等等 packet_qeue_start其中有packet_queue_put_private(q,flush_pkt);这里传入了一个flush_pkt是为了触发PacketQueue中对应的serial。使其+1.并触发解码器清空自身的缓存，重新开始解码 FrameQueue帧队列，其中包含多个接口；frame_peek_writable获取一个可写的frame，可以以阻塞或者非阻塞方式进行。 线程列表 媒体处理分析以下是videoctl.h分析 #ifndef VIDEOCTL_H#define VIDEOCTL_H#include QObject#include QThread#include QString#include datactl.h#include globalhelper.hclass VideoCtl : public QObject Q_OBJECTpublic: /* 需要注意的是，这里创建了一个单例对象，具体做法就是将构造函数，析构函数，拷贝构造方法和赋值构造函数都放入Private中，禁止外部构造对象 在类里会设计一个获取实例的静态函数，可以全局访问 单例设计模式分为懒汉式和饿汉式，具体见文章,https://juejin.cn/post/6844903928497176584 */ static VideoCtl *GetInstance(); ~VideoCtl(); static int read_thread_wrapper(void *arg);//读取线程包装器 static int audio_thread_wrapper(void *arg);//音频线程包装器 static int video_thread_wrapper(void *arg);//视频线程包装器 static int subtitle_thread_wrapper(void *arg);//字幕线程包装器 /* 首先确保其他播放线程结束，避免资源冲突，使用m_playLoopIndex字段。接下里发送信号给标题栏完成播放的初始化 接下来通过对预置选项的判断，完成标志位初始化，完成SDL初始化。并配置硬件加速，以及渲染。 创建LoopThread线程 */ void StartPlay(QString strFileName, WId widPlayWid);//开始播放 void StopPlay();//停止播放 /* 创建SDL事件， 判断双击事件，显示全屏，通过检测鼠标单击事件的时间差实现。 鼠标隐藏事件 */ void LoopThread(VideoState* CurStream);//循环线程 /* 这个函数是设备初始化的核心，负责配置和打开SDL音频设备。完成音频格式协商，设备参数设置，错误恢复等复杂流程 创建音频结构体，其中包括期望的音频参数，和实际的音频参数。 定义备选声道数和采样率数组，用于降级策略。 成功打开设备后，会返回spec结构体，其中包括 spec.freq: 实际的采样率（可能与请求不同） spec.channels: 实际的声道数 spec.format: 实际的音频格式 spec.samples: 音频缓冲区大小 spec.size: 音频缓冲区的总字节数 */ int audio_open(void *opaque, AVChannelLayout *wanted_channel_layout, int wanted_sample_rate, struct AudioParams *audio_hw_params);//音频打开 /* double pts; // 当前媒体的时间戳 double pts_drift; // 与系统时钟的漂移（pts - gettime） double last_updated; // 最后更新时间（系统时间） double speed; // 播放速率（支持变速） int serial; // 用于检测流是否连续的序列号 int paused; // 暂停状态 int *queue_serial; // 关联队列版本号（跨线程同步） av_gettime_relative()获取自程序启动的相对时间，单位us `set_clock_at`: 设置时钟的基础函数，直接设置时钟的时间戳、序列号和更新时间点 - `pts`: 当前媒体的时间戳(秒) - `serial`: 用于检测流是否连续的序列号 - `time`: 系统当前时间(秒) - `pts_drift`: 计算媒体时间与系统时间的偏移量 `set_clock`: 简化版的时钟设置函数，自动获取当前系统时间并调用`set_clock_at` `get_clock`: 获取时钟当前时间，考虑了暂停状态和播放速度 - 如果序列号不匹配(可能发生了seek操作)，返回NaN - 如果暂停，直接返回保存的pts - 如果正常播放，返回考虑了时间漂移和播放速度的实际时间点 `sync_clock_to_slave`: 将一个时钟同步到另一个时钟(主从同步) - 当两个时钟差距超过阈值(AV_NOSYNC_THRESHOLD)时进行同步 - 通常用于将视频时钟或外部时钟同步到音频时钟 这些函数在音视频同步中的应用： - 音频、视频和外部时钟各有一个Clock实例(audclk, vidclk, extclk) - 通过`get_master_sync_type`决定主时钟(通常是音频时钟) - 其他时钟会通过`sync_clock_to_slave`与主时钟同步 - 视频帧显示时会根据与主时钟的差异决定是加速、减速还是丢帧这种设计确保了即使在网络延迟、解码速度不一致等情况下，音视频仍能保持同步播放。 */ void set_clock_at(Clock *c, double pts, int serial, double time);//设置时钟 void sync_clock_to_slave(Clock *c, Clock *slave);//同步时钟 double get_clock(Clock *c);//获取时钟 void set_clock(Clock *c, double pts, int serial);//设置时钟 /* 维护一个sample_array，实现音频的定长缓存，缓存区为环形 */ void update_sample_display(VideoState *is, short *samples, int samples_size); /* 帧获取与序列检查：从音频帧队列获取下一帧，确保序列号匹配，避免处理过时的帧 音频同步：调用synchronize_audio计算需要的样本数，用于与主时钟同步 动态重采样： 检测音频格式变化（采样率、声道布局、样本格式） 动态创建和配置重采样器 处理音频格式转换，确保输出符合音频设备要求 时钟更新：根据帧的PTS和样本数更新音频时钟，这是音视频同步的关键 内存管理：动态分配和管理音频缓冲区，处理各种边缘情况 */ int audio_decode_frame(VideoState *is);//音频解码 /* 通过动态调整音频样本数量来实现音频与主时钟的同步。 检查是否需要同步（音频不是主时钟时才需要） 计算音频时钟与主时钟的差异 如果差异在合理范围内，累积并计算平均差异 当积累足够样本且平均差异超过阈值时，调整音频样本数 返回调整后的样本数，供重采样器使用 */ int synchronize_audio(VideoState *is, int nb_samples);//同步音频 double get_master_clock(VideoState *is);//获取主时钟 int get_master_sync_type(VideoState *is);//获取主同步类型 /* 创建线程锁 创建AVPacket 创建格式上下文 打开媒体文件并解析格式 获取流信息 seek机制 选择最佳流 处理附加信息 错误处理 */ int read_thread(void *arg);//读取线程 /* 开启解码线程 */ int decoder_start(Decoder *d, int (*fn)(void *), const char *thread_name, void *arg);//解码器启动 /* 用户界面调用OnPlaySeek(double dPercent)函数，该函数内部会计算实际时间戳并调用stream_seek()，并且重启线程 */ void stream_seek(VideoState *is, int64_t pos, int64_t rel, int by_bytes); void step_to_next_frame(VideoState *is);//步进到下一个帧，逐帧前进功能 void stream_toggle_pause(VideoState *is);//处理暂停到播放的状态转换 int stream_has_enough_packets(AVStream *st, int stream_id, PacketQueue *queue);//流是否有足够的包，在读取线程中控制读取数据的速率 /* 解码器初始化， */ int stream_component_open(VideoState *is, int stream_index); /* 进行音频解码，decoder_decode_frame()函数 首先进行初始化，并进入解码循环 解码一帧 检查音频配置是否发生改变 音频过滤处理，实现混音，重采样等操作 帧处理和入队 检查包队列序列号和解码器序列号，判断是否发送seek操作 */ int audio_thread(void *arg); inline int cmp_audio_fmts(enum AVSampleFormat fmt1, int64_t channel_count1, enum AVSampleFormat fmt2, int64_t channel_count2);//比较音频格式。用于配置编码器 int configure_audio_filters(VideoState *is, const char *afilters, int force_output_format);//配置音频过滤器 /* 初始化， 获取视频帧，不仅使用decoder_decode_frame，同时通过检测序列号和时间戳来进行丢帧，进行同步 检测视频格式变化 进行过滤处理 时间戳处理，需要计算过滤器的延时 队列管理 同步控制 */ int video_thread(void *arg);//视频线程 /* 丢帧策略 在两种情况下考虑丢帧： framedrop 0: 强制丢帧模式 framedrop get_master_sync_type(is) != AV_SYNC_VIDEO_MASTER: 开启丢帧且视频不是主时钟 通过判断fabs(diff)决定是否丢弃。 */ int get_video_frame(VideoState *is, AVFrame *frame);//获取视频帧 int queue_picture(VideoState *is, AVFrame *src_frame, double pts, double duration, int64_t pos, int serial);//队列图片 void set_default_window_size(int width, int height, AVRational sar);//设置默认窗口大小 void calculate_display_rect(SDL_Rect *rect, int scr_xleft, int scr_ytop, int scr_width, int scr_height, int pic_width, int pic_height, AVRational pic_sar);//计算显示矩形 /* 将视频帧转换成YUV格式数据 处理视频自动旋转 添加自定义滤镜：宏INSERT_FILT */ int configure_video_filters(AVFilterGraph *graph, VideoState *is, const char *vfilters, AVFrame *frame);//配置视频过滤器 int configure_filtergraph(AVFilterGraph *graph, const char *filtergraph, AVFilterContext *source_ctx, AVFilterContext *sink_ctx);//配置过滤器图 /* 字幕也是当作一个frame帧来进行处理的。 同样利用PTS来进行同步， */ int subtitle_thread(void *arg);//字幕线程 int filter_codec_opts(const AVDictionary *opts, enum AVCodecID codec_id, AVFormatContext *s, AVStream *st, const AVCodec *codec, AVDictionary **dst);//过滤器编码选项 int check_stream_specifier(AVFormatContext *s, AVStream *st, const char *spec);//检查流规范 int create_hwaccel(AVBufferRef **device_ctx);//创建硬件加速 void toggle_pause(VideoState *is);//切换暂停 void do_exit(VideoState *is);//退出 void stream_cycle_channel(int codec_type);//流循环通道 void toggle_audio_display();//切换音频显示 VideoState *m_CurVideoState = nullptr;//当前视频状态 bool m_playLoopIndex;//播放循环索引private: explicit VideoCtl(QObject *parent = nullptr);//构造函数 bool Init();//初始化 bool ConnectSignalSlots();//连接信号与槽 void UpdateVolume(int sign, double step);//更新音量 void refresh_loop_wait_event(VideoState* is, SDL_Event* event);//刷新循环等待事件 VideoState* stream_open(const char *filename, const AVInputFormat *iformat);//流打开 void stream_close(VideoState *is);//流关闭 void stream_component_close(int stream_index);//流组件关闭 int video_open(); void seek_chapter(int incr);//章节跳转 void toggle_full_screen();//切换全屏 void toggle_mute();//切换静音 void init_clock(Clock *c, int *queue_serial);//初始化时钟 // double get_master_clock(); // int get_master_sync_type(); void check_external_clock_speed();//检查外部时钟速度 void set_clock_speed(Clock *c, double speed);//设置时钟速度 void update_volume(int sign, double step);//更新音量 void update_video_pts(double pts, int serial);//更新视频时间戳 double compute_target_delay(double delay);//计算目标延迟 double vp_duration(Frame *vp, Frame *nextvp);//计算视频持续时间 void video_refresh(double *remaining_time);//视频刷新 void video_display();//视频显示 void video_audio_display();//视频音频显示 void video_image_display();//视频图像显示 int upload_texture(SDL_Texture **tex, AVFrame *frame);//上传纹理 int realloc_texture(SDL_Texture **texture, Uint32 new_format, int new_width, int new_height, SDL_BlendMode blendmode, int init_texture);//重新分配纹理 void get_sdl_pix_fmt_and_blendmode(int format, Uint32 *sdl_pix_fmt, SDL_BlendMode *sdl_blendmode);//获取SDL像素格式和混合模式 void set_sdl_yuv_conversion_mode(AVFrame *frame);//设置SDL YUV转换模式 inline void fill_rectangle(int x, int y, int w, int h);//填充矩形 inline int compute_mod(int a, int b);//计算模数 static VideoCtl* m_pInstance;//单例实例 bool m_initIndex;//初始化索引 SDL_Window *window;//窗口 SDL_Renderer *renderer;//渲染器 SDL_RendererInfo renderer_info = 0 ;//渲染器信息 SDL_AudioDeviceID audio_dev;//音频设备 WId play_wid; // 播放窗口 int screen_width;//屏幕宽度 int screen_height;//屏幕高度 int startup_volume;//启动音量 //播放刷新循环线程 std::thread m_tPlayLoopThread;//播放刷新循环线程 int m_frameW;//帧宽度 int m_frameH;//帧高度signals: void SigPlayMsg(QString strMsg); // 错误信息 void SigFrameDimensionsChanged(int nFrameWidth, int nFrameHeight); //视频宽高发生变化 void SigVideoTotalSeconds(int nSeconds);//视频总秒数 void SigVideoPlaySeconds(int nSeconds);//视频播放秒数 void SigVideoVolume(double dPercent);//视频音量 void SigPauseStat(bool bPaused);//暂停状态 void SigStop();//停止 void SigStopAndNext();//停止并下一个 void SigStopFinished(); // 停止播放完成 void SigStartPlay(QString strFileName);public slots: void OnPlaySeek(double dPercent);//播放进度 void OnPlayVolume(double dPercent);//播放音量 void OnPause();//暂停 void OnStop();//停止 void OnSeekForward();//向前搜索 void OnSeekBack();//向后搜索 void OnAddVolume();//增加音量 void OnSubVolume();//减少音量;#endif","tags":["ffmpeg结构体分析","播放器工作流"],"categories":["technology","音视频"]},{"title":"大型C/C++项目的编译噩梦","path":"/2025/07/08/大型CC++项目的编译噩梦/","content":"对于大型的C\\C++项目编译而言，毫无疑问是一个非常复杂，非常令人作呕的过程。C++不同于其他语言，对于编译过程中的ABI兼容都做出了处理。同时，在这门语言中还有非常复杂，近乎于另外一门语言的Cmake，以及两个版本的编译器。你还需要考虑编译过程中的库版本，编译器版本，甚至最后的最后还需要手动将.dll文件复制。下面希望在逐层的抽丝剥茧中可以帮助你我更深刻的理解这个问题，从而解决这个问题。 编译过程实际上对于一个程序员来说，编译过程应该已经非常熟悉了，但是在这里还需要进一步的阐述以下。 预处理预处理器（cpp）将所有的#define删除，并且展开所有的宏定义。 处理所有的条件预编译指令，比如#if、#ifdef、#elif、#else、#endif等。 处理#include预编译指令，将被包含的文件直接插入到预编译指令的位置。 删除所有的注释。 添加行号和文件标识，以便编译时产生调试用的行号及编译错误警告行号。 保留所有的#pragma编译器指令，因为编译器需要使用它们。 使用gcc -E hello.c -o hello.i命令来进行预处理， 预处理得到的另一个程序通常是以.i作为文件扩展名。 编译词法分析：扫描器（Scanner）将源代的字符序列分割成一系列的记号（Token）。lex工具可实现词法扫描。 语法分析：语法分析器将记号（Token）产生语法树（Syntax Tree）。yacc工具可实现语法分析(yacc: Yet Another Compiler Compiler)。 语义分析：静态语义（在编译器可以确定的语义）、动态语义（只能在运行期才能确定的语义）。 源代码优化：源代码优化器(Source Code Optimizer)，将整个语法书转化为中间代码（Intermediate Code）（中间代码是与目标机器和运行环境无关的）。中间代码使得编译器被分为前端和后端。编译器前端负责产生机器无关的中间代码；编译器后端将中间代码转化为目标机器代码。 目标代码生成：代码生成器(Code Generator). 目标代码优化：目标代码优化器(Target Code Optimizer)。 汇编汇编器（as）将hello.s翻译成机器语言指令，把这些指令打包成一种叫做可重定位目标程序的格式，并将结果保存在目标文件中，这是一个二进制文件 链接连接器的主要作用是把各个模块之间相互引用的部分处理好,使得各个模块之间能够正确的衔接。同时这里存在着动态链接和静态链接。静态链接使用静态库进行链接，生成的程序包含程序运行所需要的全部库，可以直接运行，不过静态链接生成的程序比较大。动态链接使用动态链接库进行链接，生成的程序在执行的时候需要加载所需的动态库才能运行。动态链接生成的程序体积较小，但是必须依赖所需的动态库，否则无法执行。 其他语言对于编译过程所做的优化1. CC++ 的问题：ABI不兼容 问题核心：代码被直接编译成特定CPU架构、特定操作系统、特定编译器、特定运行时库的原生机器码。任何一个环节不匹配，就会导致二进制层面的不兼容。 具体表现：.lib.a 链接错误，.dll.so 运行时崩溃，DebugRelease 库混用导致内存错误等。 2. 现代原生编译语言的改进像 Rust 和 Go 这类语言，在设计之初就吸取了 C++ 的教训，从根本上解决了这类问题。 Rust 解决方案：语言自带了官方的构建系统和包管理器 Cargo。 如何解决： 统一的构建标准：所有 Rust 库都通过 Cargo 进行编译，保证了编译器版本和标志的一致性。 中央仓库：有一个官方的包仓库 (crates.io)，开发者可以轻松下载和分享库。 依赖解析：Cargo 会自动处理依赖的版本和传递性依赖，几乎杜绝了版本冲突。 CC++ 互操作：当 Rust需要调用 CC++ 库时，C++的“硬核”问题会再次出现在两种语言的边界上，但 Rust 内部生态是完全免疫的。 Go (Golang) 解决方案：默认静态链接，语言内置包管理工具。 如何解决： 无 DLL 地狱：go build 命令默认会将所有依赖的库（包括 Go 的运行时）静态编译成一个单一的可执行文件。部署时只需拷贝这一个文件，完全没有 .dll 或 .so 的烦恼。 Go Modules：内置的依赖管理系统，可以很好地控制版本。 小结：这类语言依然编译到原生代码，但通过强大的官方工具链统一了构建和分发过程，从源头上避免了二进制不兼容问题。 3. 虚拟机托管语言的改进JavaKotlin (JVM) 和 C#.NET 这类语言，采用了完全不同的策略。 解决方案：引入一个中间层——虚拟机 (VM) 或**运行时 (Runtime)**。 如何解决： 编译到字节码：代码不直接编译成机器码，而是编译成一种平台无关的中间语言（Java 的 Bytecode，C# 的 IL）。 运行时 JIT 编译：在程序运行时，由虚拟机（JVM）或 .NET 运行时将字节码即时编译（JIT）成本地机器码。 依赖是字节码：库依赖（如 Java 的 .jar 文件，.NET 的 .dll 文件）也是字节码。只要目标机器上安装了相应版本的运行时，这些库就可以直接使用，完全不存在编译器版本、运行时库（DebugRelease）、平台架构的匹配问题。 成熟的包管理器：它们拥有非常成熟的包管理器，如 Java 的 MavenGradle 和 .NET 的 NuGet，可以完美处理库的下载、版本和依赖。 小结：这类语言通过牺牲一些启动性能和内存占用，换来了彻底的跨平台和二进制兼容性，依赖管理体验非常好。 4. 动态解释性语言版本与环境兼容问题Python 和 JavaScript (Node.js) 这类语言不存在我们讨论的“编译”问题，但它们有自己的“依赖地狱”。 问题核心：库与库之间、库与解释器版本之间的API兼容性问题，以及环境隔离问题。 具体表现： 一个项目依赖 library-A 的 1.0 版本，另一个项目依赖 2.0 版本，这两个版本不兼容，导致全局安装时会出问题。 代码在一个库的新版本下行为不一致或直接报错。 解决方案： 虚拟环境：通过 venv (Python) 或 nvm (Node.js) 等工具创建隔离的项目环境。 包管理器：使用 pip (Python) 和 npmyarn (Node.js) 来管理 requirements.txt 或 package.json 中定义的依赖版本。 与 C++ 的再次相遇： 当 PythonNode.js 需要高性能计算时，它们通常会调用 CC++ 编写的底层库（例如 Python 的 NumPy, PyTorch）。这时，C++ 的二进制兼容问题就“死灰复燃”了。你用 pip install 安装这类库时，它会尝试下载一个预编译好的二进制包（.whl 文件），这个包必须精确匹配你的操作系统、CPU架构（x86x64）和 Python 版本。如果找不到匹配的包，pip 就会尝试从 C++ 源码开始编译，这时你电脑上就必须装有正确的 C++ 编译器和库，然后你又会遇到我们之前讨论过的各种问题。 实际项目中需要做的准备工作 首先阅读项目文件中对于各个依赖库的版本要求，注意各个库文件的兼容性。当然如果是docker打包就可以减免这个环节了。 接下来修改CMakeLists，改一下其中的文件路径等等。 接下来最好使用命令行进行编译。使用cmake –build build –config Release 注意检查你的工具链和环境变量，由于C++中没有统一的虚拟环境或者包管理（除了docker），你需要格外注意你的编译器工具链配置。在我的电脑中有三个版本的MingW，包括普通版本，多线程版本，和QT中自带的。另外我一般使用Clion，因此需要同时配置普通的工具链和Cmake本身的工具链，以及环境变量。 常见报错及处理方法","tags":["C\\C++","编译流程","库依赖","C、C++混合编译"],"categories":["technology","编程基础"]},{"title":"对网络的理解","path":"/2025/07/03/对网络的理解/","content":"方面一：垂直分层模型 (The “How” - 数据如何传输) TCPIP 五层模型（或更理论化的 OSI 七层模型）是理解网络的基石。 核心思想：它将一个极其复杂的网络通信过程，切分成了一系列定义清晰、功能独立的层次。每一层都只关心自己的任务，并使用下一层提供的服务，同时向上一层提供服务。 具体分工： 应用层 (Application Layer): 定义应用程序如何交互。例如，HTTP 协议定义了浏览器如何向 Web 服务器请求页面。 传输层 (Transport Layer): 提供端到端(End-to-End)的通信。例如，TCP 协议确保数据可靠、有序地送达；UDP 协议则提供更快速但不可靠的数据报服务。端口号是这一层的关键。 网络层 (Network Layer): 负责数据包在整个网络中的路径规划和转发。IP 地址是这一层的核心，路由器工作在这一层。 数据链路层 (Data Link Layer): 负责在相邻的两个网络节点之间（例如，您的电脑和家里的路由器之间）传输数据帧。MAC 地址是这一层的关键，交换机工作在这一层。 物理层 (Physical Layer): 负责传输原始的比特流（0和1）。它定义了网线、光纤、无线电波等的物理特性。 这个模型是自底向上构建的，描述了通信的实现机制。 方面二：水平通信架构 (The “Who” - 谁在和谁通信)客户端、服务端、（服务器）等架构，正是这个方面。它描述了网络中各个参与者的角色和关系。 核心思想： **定义角色与交互模式 (Define Roles and Interaction Patterns)**。它不关心数据包如何穿越网络，只关心谁发起请求，谁提供服务，以及它们之间的逻辑关系。 主要模式： 客户端-服务端架构 (Client-Server, CS): 这是最常见的架构。 服务端 (Server): 被动地等待请求，拥有资源或提供计算能力。通常拥有固定的 IP 地址，并且 7x24 小时在线。 客户端 (Client): 主动地发起请求，消费资源或服务。 特点： 角色分工明确，易于管理和扩展。我们之前讨论的 Web 服务就是典型例子。 对等网络架构 (Peer-to-Peer, P2P): 对等端 (Peer): 网络中没有中心服务器，每个节点既是客户端也是服务器。它们可以直接相互通信，共享资源和服务。 特点： 去中心化，扩展性好，不易产生单点故障。我们讨论的 WebRTC 在建立连接后，其音视频流传输就是 P2P 模式。 这个模型是端到端的，描述了应用的逻辑结构。 两者如何关联无论采用哪种水平通信架构（CS 或 P2P），其底层的数据传输都必须遵循垂直分层模型（TCPIP）。 一个客户端向服务器发送 HTTP 请求时，这个请求数据会从应用层开始，依次经过传输层、网络层……打包后发送出去。 一个 Peer 向另一个 Peer 发送 WebRTC 的音视频流时，这些数据流（通常封装在 UDP 包里）同样会经过这个垂直分层模型进行传输。 通信的动态过程通信模式 (Communication Paradigms)。它描述了数据交换随时间展开的方式。 请求-响应 (Request-Response): 客户端发起请求，然后等待服务器的响应。一次交互就结束了。这是 HTTP 的经典模式。 发布-订阅 (Publish-Subscribe): 一个发布者（Publisher）发布消息，多个订阅者（Subscriber）可以接收到这个消息，而发布者无需知道订阅者是谁。常用于消息队列（如 Kafka, RabbitMQ）。 流式传输 (Streaming)： 一旦建立连接，数据会像水流一样持续不断地从一端传输到另一端。例如视频直播、WebSocket 的数据流。 当分析一个系统（比如 WebRTC）时： 它使用了什么架构？（初始是 CS 获取网页和信令，最终是 P2P 传输媒体） 它的底层遵循什么协议栈？（HTTP, WebSocket, STUN, SRTP 等都运行在 TCPIP 之上） 它的通信模式是什么？（信令是请求-响应或流式，媒体是流式）","tags":["计算机网络","分层模型","通信架构","通信模式"],"categories":["technology","编程基础"]},{"title":"RTP、RTCP、RTSP协议详解","path":"/2025/06/27/RTP协议详解/","content":"三者关系RTSP是一个实时的传输协议，是一个应用层的协议，包RTSP协议，RTP协议，RTCP协议。 RTSP协议主要是负责建立服务器和客户端之间的请求和相应，建立通信链路。 RTP协议是负责在服务器和客户端进行传输数据， RTCP协议四负责提供RTP传输质量的反馈，确保RTP传输的质量。 三者都处于应用层RTSP不会发送媒体数据，知识完成服务器和客户端之间的信令交互，RTP协议负责媒体数据传输，RTCP负责RTP数据包的监视和反馈，RTP和RTCP并没有规定传输层的类型，可以选择UDP或者是TCP，RTSP则要求最好是基于TCP。总体来说，RTSP是建立在RTP和RTCP之上的。 RTP首先要明确一点，RTP是架构在UDP之上的。在TCP协议中由于严格的重传机制，以及可靠协议特性，使其难以成为一个实时音视频领域协议。而UDP是一个不可靠协议，它并不严格要求包到达的顺序以及可靠到达，因此实时性最好。但是如何处理网络抖动以及丢包就成了难题，本部分重点在于RTP是如何解决这些问题的。 UDP 数据报的结构一个UDP数据报非常简单，它由两部分组成： **UDP头 (UDP Header)**：8个字节，包含源端口、目标端口、长度和校验和。 **UDP数据区 (UDP PayloadData)**：用来存放需要传输的数据。 [ UDP头 | UDP数据区 (用来放东西的地方) ] 基于UDP的RTP RTP协议首先构建好自己的数据包： RTP头 (RTP Header)：12字节或更多，包含序列号、时间戳等。 RTP载荷 (RTP Payload)：实际的音视频数据，比如一小段H.264编码的视频帧。 [ RTP头 | RTP载荷 (音视频数据) ] -- 这整个是一个完整的RTP包 RTP把整个RTP包（RTP头 + RTP载荷）不加改变地，“塞”进了上面提到的 UDP数据区。 最终形成的数据包结构 所以，当数据包在网络中传输时，它的嵌套结构是这样的： +-------------------------------------------------------------------+| IP头 (网络层) || +---------------------------------------------------------------+ || | UDP头 (传输层) | || | +-----------------------------------------------------------+ | || | | 这整个部分是 UDP 的“数据区” / “Payload” | | || | | +----------------------+--------------------------------+ | | || | | | RTP头 (应用层) | RTP载荷 (真正的音视频数据) | | | || | | +----------------------+--------------------------------+ | | || | +-----------------------------------------------------------+ | || +---------------------------------------------------------------+ |+-------------------------------------------------------------------+ 丢包问题在RTP头中会对每个数据包进行编号，因此接收端很容易就可以判断哪些包丢失了，这个字段是sequence number RTP扩展头通过设置RTP头中的X字段为1可开启扩展头 其中profile是为了区分不同的配置，{0x10，0x0X}和{0xBE,0xDE}分别代表two-byte-header或者one-byte-header节来解析数据。length表示有几个header_extension。 在header-extension中，one-byte-header表示在he中的数据由一个字节的header和N字节的Body组成。而header中有4位的ID和4位的len。 RTP中的填充数据通过设置RTP头的P位可开启填充数据 当RTP中包含填充数据时数据包最后一个字节记录包中填充数据字节个数（包括自己），解包的时候从后往前去掉即可。 端口数据类型区分 在一个 RTP 会话中，可能会有多个参与者发送媒体流。每个发送者都会选择一个唯一的 SSRC 值来标识自己产生的流。这使得接收端能够区分来自不同发送者的 RTP 包（即使在同一个端口输入或输出）。SSRC 字段是一个 32 位的数值，用于标识产生 RTP 包的源端系统或设备。对于任何给定的 RTP 会话，由同一个源产生的所有 RTP 包都应该具有相同的 SSRC 值。另外需要注意以下两种情况： 当一个混音器接收到来自多个源的 RTP 包并将它们混合成一个单一的流时，混音器会作为新的源产生 RTP 包，并且会使用它自己的 SSRC 值。原始的源 SSRC 值可能会被记录在 RTP 扩展头中。 一个转发器可能会在不同的网络之间转发 RTP 包，它通常会保持原始的 SSRC 值不变。 RTCPRTCP与RTP一样都是属于应用层的协议，其是RTP的控制协议。包括丢包控制；发送或者接受报告，其中包括上次报告到本次报告中间丢包率，延时等信息。 报文分类 SR和RR报文，分别用于发送和接收报文 SDES,用于描述音视频媒体源。 BYE报文用于说明哪些媒体源已经不可用，应该删除 APP报文，自定义报文 RTPFB,PSFB报文，未搞清楚什么作用。 需要注意这里的报文概念，与SDP，json、xml这类消息概念易混。 其中很重要的一个区别就是RTCP报文是二进制的。 RTCP协议头 重点是count字节，对于不同的报文类型，其含义是不同的。length字节表示整个的RTCP大小。 PT即payload Type RTSPRTSP的组成 OPTIONS： 用途： 客户端用 OPTIONS请求服务器支持的 RTSP 方法。 请求示例： OPTIONS rtsp:example.commedia.mp4 RTSP1.0\\r CSeq: 1\\r User-Agent: MyClient\\r \\r 响应： 服务器会回复一个包含 Public:OPTIONS 头部的响应，列出它支持的方法： DESCRIBE, SETUP, PLAY, PAUSE, TEARDOWN DESCRIBE： 用途： 客户端使用 请求服务器上媒体文件的描述信息。这个描述信息通常以 SDP （Session Description Protocol） 格式提供，包含了媒体的类型（例如音频、视频）、编码格式、传输方式等。 请求示例： DESCRIBE rtsp:example.commedia.mp4 RTSP1.0\\r CSeq: 2\\r Accept: applicationsdp\\r User-Agent: MyClient\\r \\r 响应： 服务器会回复一个包含媒体描述信息的 SDP 内容。 SETUP： 用途： 客户端在播放媒体之前，需要使用 SETUP 命令为每个媒体流组件（例如音频和视频轨道）建立传输会话。客户端会指定它希望使用的传输协议（例如 RTPUDP 或 RTPTCP）以及接收数据的端口。 请求示例 （RTPUDP）： SETUP rtsp:example.commedia.mp4trackID1 RTSP1.0\\r CSeq: 3\\r Transport: RTPAVP;unicast;client_port12345-12346\\r User-Agent: MyClient\\r \\r 请求示例 （RTPTCP）： SETUP rtsp:example.commedia.mp4trackID1 RTSP1.0\\r CSeq: 3\\r Transport: RTPAVPTCP;unicast;interleaved0-1\\r User-Agent: MyClient\\r \\r 响应： 服务器会回复确认所选的传输参数，并分配一个会话。 PLAY： 用途： 客户端使用 命令指示服务器开始发送流媒体数据。客户端可以指定播放的时间范围。 请求示例 (从头开始播放): PLAY rtsp:example.commedia.mp4 RTSP1.0\\r CSeq: 4\\r Session: 1234567890\\r Range: npt0.000-\\r User-Agent: MyClient\\r \\r 请求示例 (播放特定时间段): PLAY rtsp:example.commedia.mp4 RTSP1.0\\r CSeq: 4\\r Session: 1234567890\\r Range: npt10.5-25.0\\r User-Agent: MyClient\\r \\r 响应： 服务器会回复确认开始播放。 PAUSE： 用途： 客户端使用 PAUSE 命令暂停流媒体的播放。客户端可以指定暂停的时间。 请求示例: PAUSE rtsp:example.commedia.mp4 RTSP1.0\\r CSeq: 5\\r Session: 1234567890\\r User-Agent: MyClient\\r \\r 响应： 服务器会回复确认已暂停播放。 TEARDOWN： 用途： 客户端使用 TEARDOWN 命令通知服务器终止流媒体会话并释放相关资源。 请求示例: TEARDOWN rtsp:example.commedia.mp4 RTSP1.0\\r CSeq: 6\\r Session: 1234567890\\r User-Agent: MyClient\\r \\r 响应： 服务器会回复确认会话已终止。 其他不太常用但仍然重要的命令： GET_PARAMETER： 用于查询服务器或会话的参数。 SET_PARAMETER： 用于设置服务器或会话的参数。 REDIRECT： 服务器可以发送 响应，指示客户端连接到另一个服务器。REDIRECT RTSP的过程一次基本的RTSP操作过程是，首先，客户端线连接到流媒体服务器，并发送i个（DESCRIBE）。流服务器通过一个SDP描述来进行反馈，反馈信息包括流数量，媒体类型等信息，客户端在分析描述符后 ,并为每个流发送SETUP命令，这个命令来告诉服务器，客户端用于接收媒体数据的端口，流媒体连接建立完成后，客户端发送i个播放命令PLAY服务器就可以在UDP上传送媒体流，RTP包到客户端，在播放过程中客户端还可进行快进，快退，等操作。 RTSP与HTTP的关系 RTSP引入了几种新的方法，比如DESCRIBE、PLAY、SETUP 等，并且有不同的协议标识符，RTSP为rtsp 1.0,HTTP为http 1.1； HTTP是无状态的协议，而RTSP为每个会话保持状态； RTSP协议的客户端和服务器端都可以发送Request请求，而在HTTPF协议中，只有客户端能发送Request请求。 在RTSP协议中，载荷数据一般是通过带外方式来传送的(除了交织的情况)，及通过RTP协议在不同的通道中来传送载荷数据。而HTTP协议的载荷数据都是通过带内方式传送的，比如请求的网页数据是在回应的消息体中携带的。 使用ISO10646(UTF-8) 而不是ISO 8859-1，以配合当前HTML的国际化； RTSP使用URI请求时包含绝对URI。而由于历史原因造成的向后兼容性问题，HTTP1.1只在请求中包含绝对路径，把主机名放入单独的标题域中； RTSP协议格式文章 在client和server的连接中，还需要使用SDP描述符，连接中有关于SDP的协议说明。","tags":["C++","WebRtc","RTP","RTCP","RTSP"],"categories":["technology","音视频"]},{"title":"WebRTC中的拥塞控制","path":"/2025/06/27/拥塞控制/","content":"在WebRTC中有多种控制算法，包括GCC,BBR,PCC。GCC又可以根据基于发送端或接收端，分为Transport-CC，Goog-REMB。 Goog-REMB 图中左侧为发送端，控制码流的发送；右侧为接收端，用于拥塞的评估和码流的计算 RemoteBitrate Estimator是接收端延迟拥塞控制算法的管理模块，从网络收发磨矿获取RTP包的传输信息用于拥塞评估。或者将内部评估出的下一时刻的发送码流大小，输出给网络收发模块，从而进行流控。另一方面，它要组织内部的Inter Arrival、OverUser Estimator等模块，根据当前观测到的延时差，和之前的评估指推断出下一时刻的网络拥塞情况 Inter Arrival首先将数据包按照帧分组，然后对相邻的两组数据包进行单项梯度计算。计算内容包括 每组数据包的发送时长 每组数据包的接收时长 两组数据包的大小差 OverUser Estimator利用IA计算出的结果，通过卡尔曼滤波估算出下一时刻发送队列的增长趋势。网络带宽是不断变化的，卡尔曼滤波器能够根据间接测量值，估算出真实结果。因此选用卡尔曼根据数据包时延来对带宽进行估计。 OverUse Detector用于检测当前网路中的拥塞情况，利用OE计算出的队列梯度延时以及自适应阈值进行比较。决定发包量的策略。 AIMD Rate Controller用于计算发送码流的大小，通过OD模块检测出当前网络状态，从而变更自己的状态，并计算出发送码流的大小 原理很简单，我们假设发送码流越大，状态越好。当OD检测出网络质量相比于现在呈上升，趋势，那么状态也上升。反之亦然 Transport CC在这个算法中，将拥塞算法从接收端移到了发送端，将卡尔曼换成了TrendLine GooCcNetworkController同样是对各个模块的控制。会调用子模块评估出下一时刻的网络拥塞状态和码流大小。并将评估出的码流交由Pacer和编码器模块进行码流控制 SendSideBandwidthEstimation比较基于接收端延时与发送端延时评估出的码流值，以及基于丢包，从中选择最小的码流值作为最终 DelayBaseBwe由多个模块构成，用于延时拥塞评估 trendline最小二乘法滤波器，拟合曲线。通过某一时刻线的斜率来判断此时线路是否拥塞，评估下一时刻码流大小 基于丢包的拥塞评估前面已经有两种方法用于拥塞评估，分别是卡尔曼和TrendLine，都是基于延时的。 还有一种基于丢包的，实际上就是通过设置丢包门限来评定此时的网络传输质量。 2%,网络质量很好，可以加大码率 2%x10%,说明网络与发送速率匹配 10%,需要降低码率至（1-0.5丢包率）当前码率 拥塞控制算法","tags":["C++","WebRtc","拥塞控制"],"categories":["technology","音视频"]},{"title":"WebRTC中的SDP规范","path":"/2025/06/26/WebRTC中的SDP规范/","content":"SDP结构1 v=0 2 o=- 3409821183230872764 2 IN IP4 127.0.0.1 3 … 4 m=audio 9 UDP/TLS/RTP/SAVPF 111 103 104 … 5 … 6 a=rtpmap :111 opus /48000/2 7 a=rtpmap :103 ISAC /16000 8 a=rtpmap :104 ISAC /32000 标准SDP规范的规定较为简单，前三行为会话描述，对整个SDP有约束作用；第四行为媒体描述，各个媒体描述之间互不影响。在整个SDP中只能有一个会话描述，但是可以有多个媒体描述。 SDP的描述格式同样较为简单type=valueSDP中的信息webrtc为了实现实时的通信，对标准的SDP做了较大的调整。这里仅展示wR中的SDP内容 会话部分v:协议版本o:会话创建者s:会话名t:会话时长 (下面部分选自李超老师书籍WebRTC音视频技术) 媒体描述 媒体信息在SDP中最重要的内容就是媒体信息。我们看一下 SDP中媒体信息的具体格式，如下所示：m＝＜media＞＜port＞／＜numbers＞＜transport＞＜fmt＞．．． 其中，＜media＞表示媒体类型，可以是audio、video等。 ＜port＞／＜numbers＞表示该媒体使用的端口号。对于WebRTC而言，由于它不使用SDP中描述的网络信息，所以该端口号对它没任何意义。＜transport＞表示使用的传输协议，可以是UDP、TCP等。 ＜fmt＞表示媒体数据类型，一般为PayloadType列表，其具体含义需要使用＂a＝rtpmap：＂属性做进一步阐述。 我们来看一个具体的例子，如代码7．2所示。从代码中可以看到， media的值为audio，表示该媒体的类型为音频；port为9，可以直接忽略，因为WebRTC不使用标准SDP中的网络信息，所以这里的端口也就失去了意义；transport为UDP／TLS／RTP／SAVFP，表示底层使用了哪些传输协议；fmtlist的值为一串从111到126的数字，每个数字代表一个PayloadType，不同的PayloadType表示媒体数据使用了不同的编解码器或编解码器参数。 上面提到的UDP／TLS／RTP／SAVFP，其含义为：传输时底层使用 UDP；在UDP之上使用了DTLS协议来交换证书；证书交换好后，媒体数据由RTP进行传输（RTP运行在UDP之上），保证传输的可靠性；媒体数据（音视频数据）的安全性是由SRTP负责的，即对RTP包中的Body部分进行加密。此外，传输时还使用RTCP的feekback机制对传输信息进行实时反馈（SAVPF），以便进行拥塞控制。代码7．2 媒体信息 1 ...2 m=audio 9 UDP/TLS/RTP/SAVPF 111 103 104 9 0 8 106 105 13110 112 113 1263 ... 通过上面的介绍，我们已经清楚了SDP中的媒体信息是用来做什么的。不过媒体信息不只有上面的这些内容，它还有很多＂$a$＂的属性用来对前面的信息做进一步解释，如每个PayloadType的详细参数就是由它们说明的。音频媒体的描述前面已经介绍过了，但还有很多细节没有介绍。这些细节是无法通过一条＂ $\\mathrm{m}$＂行就能够描述清楚的，必须通过 ＂$ar t p m a p$＂对其做进一步解释才行。如代码7．3所示，在这段代码中，使用大量的＂ $\\mathrm{a}\\mathrm{rtpmap”}$ 属性对＂ $\\mathrm{m}$＂行做进一步阐释。 代码7．3 音频媒体示例 m = audio 9 UDP/TLS/RTP/SAVPF 111 103 104 9 ......a=rtpmap :111 opus /48000/2a=rtcp -fb:111 transport -cca=fmtp :111 minptime =10; useinbandfec =1a=rtpmap :103 ISAC /16000a=rtpmap :104 ISAC /32000a=rtpmap :9 G722 /8000... 这段代码中的第 1 行代码是对音频媒体的描述；第 $3 、 6 、 7 、 8$ 行代码使用＂a＝rtpmap＂解释了PayloadType使用的编解码器及其参数是什么；第 5 行代码＂$af m t p$＂属性指定了PayloadType的数据格式，即音频帧最小 10 ms —帧，使用带内FEC。 在WebRTC的SDP中，＂a＝rtpmap＂＂a＝fmtp＂属性随处可见。无论是音频媒体中，还是视频媒体中，都使用它们对媒体做进一步的解释。 ＂a＝rtpmap＂属性 rtpmap（rtp map），通过字面含义可以知道它是一张 PayloadType与编码器的映射表，每个PayloadType都对应一个编码器。其格式定义在RFC4566中，如下所示：a＝rtpmap：＜payload type＞＜encoding name＞／＜clock rate＞［／＜encodingparameters＞］ 通过上面rtpmap的格式，可以很容易理解代码7．3中第3行代码的含义：Payload Type值为 111 的编码器是Opus，其时钟频率（采样率）为48000，音频通道数为2。同理，PayloadType值为103的编码器是ISAC，采样率为 16000 ；PayloadType值为 104 的编码器也是 ISAC，只不过其采样率变成了 32000 ；PayloadType值为 9 的编码器是G722，采样率是 $8000 . . . . .$. ＂ $\\mathrm{a}\\mathrm{fmtp}$＂属性fmtp（format parameters）用于指定媒体数据格式。 ＂$af m t p$＂属性的格式与rtpmap一样也是定义在RFC4566的第6节中，如下所示：a＝fmtp：＜format＞＜format specific parameters＞ 现在再来看一下代码7．3中的第5行代码，它描述了PayloadType值为 111 的数据（Opus数据）：以 10 ms 长的音频数据为一帧，并且数据是经FEC编码的。其中，＂usein bandfec $1$＂是WebRTC针对 Opus增加的fmtp值。如果你想了解这些细节，可以看一下相关的草案。 与音频媒体信息相比，视频媒体信息要复杂一些，在SDP中视频相关的描述如代码7．4所示。 代码7．4 视频媒体 m=video 9 UDP/TLS/RTP/SAVPF 96 ... 102 121 124 ...a=mid:1a=rtpmap :96 VP8 /90000...a=rtpmap :97 rtx /90000a=fmtp :97 apt =96...a=rtpmap :102 H264 /90000...a=fmtp :102 level -asymmetry -allowed =1; packetization -mode =1; profile -level -id =42001f13 a=rtpmap :121 rtx /9000014 a=fmtp :121 apt =10215 ...16 a=rtpmap :124 red /9000017 a=rtpmap :119 rtx /9000018 a=fmtp :119 apt =12419 ... 其中，第 1 行代码为视频的＂ $\\mathrm{m}$＂行，其与音频的＂ $\\mathrm{m}$＂行类似，区别在于两者的媒体类型不同：一个是＂video＂，另一个则是 ＂audio＂。此外，第1行中的PayloadType列表也发生了变化，这个很好理解，视频媒体使用的编码器本就与音频媒体使用的不同。第3行代码表明视频媒体的ID编号为1，而音频媒体的ID编号为0。如果有更多的媒体，编号会一直累加。第 $5 \\sim 18$ 行代码是对不同 PayloadType的解释，下面看一下它们是如何解释PayloadType的吧。 第 5 行代码，PT（PayloadType）值为 96 表示媒体数据使用的编码器是VP8，其时钟频率为 90000 。又因为其排在＂ $\\mathrm{m}$＂行PT列表的第一位，所以它还是视频的默认编码器。同理，代码第 10 行，PT值为102表示媒体数据使用的是H264编码器，时钟频率也是 90000 。 第 7 行代码，PT值为 97 表示的含义与之前 PT值为 96 的情况有所不同，rtx表示的不再是编码器，而是丢包重传。要想弄明白第 7 行代码的含义，必须与第 8 行代码结合着一起看。在第 8 行代码中， apt（associated payload type）的值为 96 ，说明 96 与 97 是关联在一起的，PT＝97是PT＝96的补充。因此第7行代码的含义是：当 WebRTC使用的媒体数据类型（PayloadType）为96时，如果出现丢包需要重传，重传数据包的PayloadType为97。同理，第13～14行代码指明121是PT＝102重传包的PayloadType。 第16～18行代码较为特殊，要想了解这三行代码的含义，你还需要了解一些额外知识：一是red，它是一种在WebRTC中使用的FEC算法，用于防止丢包；二是red编码流程，默认情况下WebRTC会将 VP8／H264等编码器编码后的数据再交由red模块编码，生成带一些冗余信息的数据包，这样当传输中某个包丢了，就可以通过其他包将其恢复回来，而不用重传丢失的包。了解了上面这些内容后，第 $20 \\sim 22$行代码的含义应该就清楚了，即PT值为 124 表示需要使用red对之前编码好的数据再进行 red 处理， 119 是 PT $124$ 重传数据包的 PayloadType。如果用Wireshark等抓包工具抓取WebRTC媒体数据包时会发现它们都是red包，而在red包里装的是VP8／H264编码的数据。 再看一下与 H 264 相关的 fmtp 内 容。第 12 行代码，level－ asymmetry－allowed $1$ 指明通信双方使用的 H264Level是否要保持一致：0，必须一致；1，可以不一致。packetization mode指明经 H264编码后的视频数据如何打包，其打包模式有三种：0，单包；1，非交错包；2，交错包。三种打包模式中，模式0和模式1用在低延时的实时通信领域。其中模式 0 的含义是每个包就是一帧视频数据；模式1的含义是可以将视频帧拆成多个顺序的RTP包发送，接收端收到数据包后，再按顺序将其还原。profile－level－id由三部分组成，即 profile＿idc、profile＿iop以及level＿idc，每个组成部分占8位，因此可以推测出profile＿idc $42$ 、profile＿iop $00$ 、level＿idc $1$ f。关于这几个值的具体含义，如果读者感兴趣，可以自行查看H264规范手册。 以上分析将SDP中视频媒体信息相关的内容及其含义讲解清楚了。音视频媒体信息是SDP中最为重要的内容，读者一定要牢牢掌握。 另外一个媒体描述是SSRC，它是媒体源的唯一标识。需要注意的是，虽然原则上要求每一路媒体流都只有一个唯一的SSRC来标识它。但是我们可以使用 a = ssrc -grou:FID XXXXX MMMMM 不同的ssrc标识符来区分真正的视频流，以及重传的视频流。 SDP的版本标准SDP-PlanB-UnifiedPlan PlanB和Unified的最大的区别是，前者只有两个媒体描述，而如果要穿上多路的音视频流，那么这个时候要使用SSRC来进行区分，而在后这中可以有多个媒体描述，因此对于多路视频的情况只需要拆分成多个媒体描述（“m ”）即可 RTP扩展头通过使用“aexemap”扩展头，在原有的UDP基础上完完成扩展，进行SDP传输 服务质量“artcp-fb”,需要注意的是，这个字段即可以表示RTCP中专门反馈消息的一类消息。二是设置终端支持哪些feedback消息，通过设置编码器，拥塞算法等参数，影响服务质量。","tags":["C++","WebRtc","音视频服务质量"],"categories":["technology","音视频"]},{"title":"提高实时通信中音视频服务质量的方法","path":"/2025/06/23/webrtc中的实时通信增强方法/","content":"实时通信与带宽大小网络质量息息相关，根据香农定理和奈奎斯特定理其实很容易知道，码率、延迟和服务质量本身就是相悖的。而再加上信号传输本身的带宽有限（排除WebRtc中使用的架构），更加难以达到一个均衡。 那么为了提高音视频服务质量又该如何下手呢。有以下五个方面，这篇文章主要记录每个方面的一些重要算法。 增加带宽 减少数据量 适当增加时延 提高网络质量 快速准确评估带宽 增加带宽首先应该提到的肯定不是WebRtc中的一些算法，而是譬如5G网络，星链，新型传输材料，波分复用，时分复用，频分复用，等等通信方向的知识。但这并不在笔者将要探讨的WebRtc框架体系之内。 在WR内，客户端方面主要使用了一种极妙的选路方案来提高整体通信的带宽，即TURN-STUN结构。 STUN-TURN架构减少数据量 压缩算法，通过更好的压缩算法可以实现更高的码率 SVC技术，将视频按照时间、空间、质量分成多层编码、，然后将他们装在同一路发送给服务端，服务端收到后再根据每个用户的带宽情况不同来选择不同的层下发。 simulcast，将视频编码分成多个不同分辨率的多路码流，然后上传至服务端，服务端在根据客户的不同情况来进行下发。 动态码率 甩帧，减少业务， 增加时延实际上增加时延是增加一个缓冲区，先把到来的数据方法队列中缓冲一下，这样的话就可以减少网络抖动造成的卡断、快播、吞音等现象。一般而言对于实时音视频延迟应该控制在500ms以内。 提高网络质量对于网络质量主要有三个影响因素 丢包，优质网络丢包率应该小于2%，对于WR丢包率应该限制在2%-10% 延迟，拥塞 抖动，抖动较小的情况下，可以通过循环队列将其消除，抖动过大就会将乱序包作为丢包处理。在WR中抖动时长不能超过10ms，超过10ms会被视为丢包 解决上面问题的方法： NACKRTX NACK是RTCP的一种消息类型，向接收端报告一段时间内有哪些包丢失了，RTX是指向发送端重新发送丢失包 前向纠错，使用异或方式进行发送，以便在丢包时可以通过这种机制恢复丢失的包 JitterBufer 用于防抖动， 可以将少量乱序包恢复成有序 NetEQ 用于音频的防抖动","tags":["C++","WebRtc","音视频服务质量"],"categories":["technology","音视频"]},{"title":"SIMPLEST_FFMPEG_PLAYER源码阅读","path":"/2025/06/10/SIMPLEST_FFMPEG_PLAYER源码阅读/","content":"对于FFmpeg的使用中，理解各个结构体的作用至关重要。首先在使用之前，avdevice_register_all()和 avformat_network_init()来分别对设备和网络进行初始化 解协议（http,rtsp,rtmp,mms）AVIOContext，URLProtocol，URLContext主要存储视音频使用的协议的类型以及状态。URLProtocol存储输入视音频使用的封装格式。每种协议都对应一个URLProtocol结构。（注意：FFMPEG中文件也被当做一种协议“file”） AVIOContext是FFmpeg中用于执行输入输出操作的抽象层，提供协议层之上的抽象接口，它负责处理数据流的读写和定位，而不需要知道底层数据的来源，因此可以处理本地，网络，内存缓冲区多个流来源。这个结构体包含了读写缓冲区的指针，缓冲区的大小，当前读写位置，和读写位置的指针（这些具体的指针指向集体的协议实现）等 在古早版本的FFmpeg中UP用于定义和注册不同的底层协议（如file\\http\\rtp\\tcp\\udp等），每个这样的结构体中都包含了针对该协议的一组回调函数（如url_open\\url_read\\url_read\\url_write\\url_seek\\url_close等）。但是在现代的FFmpeg中已经更多的整合和抽象进入AC中了。 同样的在古早版本中，UC是UP的一个具体实例，用于存贮某个已经打开协议连接的上下文信息。但是在新版的FFmpeg中这个结构也已经被整合到了AC中 解封装（flv,avi,rmvb,mp4）AVFormatContext主要存储视音频封装格式中包含的信息；AVInputFormat存储输入视音频使用的封装格式。每种视音频封装格式都对应一个AVInputFormat 结构。 avformat_alloc_contex()申请一个AVFormatContext内存 avformat_free_contex 释放该结构里的所用东西以及该结构本身 avformat_close_input() 关闭解复用器，关闭后就不需要使用avfoemat_free_contex来进行释放，常用 avformat_open_input 打开输入视频文件 avformat_find_stream_info 获取音视频文件信息 afvv_read_frame 读取音视频包 avformat_seek_file 定位文件，拖拉进度条，根据pts av_seek_frame 定位文件，根据比例 在阅读雷博士写的播放器的时候能够轻易地发现这个结构体是一个很重要的结构体，它不仅是用于解封装到解码中间，在其他地方也是可以看到的。但是在这个结构体中实际上并没有什么很复杂的信息。只有类似音视频流的个数，音视频流，时长，比特率之类的东西。以及显示音视频流（文件）的源信息 解码（h264,mpeg2,aac,mp3） avcodec_alloc_contex3() 分配解码器上下文 avcodec_find_decoder() 根据ID查找解码器 avcodec_find_decoder_by_name() 根据名字查找解码器。不同厂家所制造的解码器ID相同，但是名字可以不同 avcodec_open2 打开编解码器 avcodecd_send_packet() 发送编码数据包 avcodec_recieve_frame() 接收解码器数据 avcodec_free_contex 释放解码器上下文包含 avcodec_close 关闭解码器每个AVStream存储一个视频音频流的相关数据；每个AVStream对应一个AVCodecContext，存储该视频音频流使用解码方式的相关数据；每个AVCodecContext中对应一个AVCodec，包含该视频音频对应的解码器。每种解码器都对应一个AVCodec结构。 AVStream 这个结构体可以理解成为媒体文件中的轨道信息。 AVCodecContex 这个结构体在编码和解码中都有应用，用于存储编解码器的上下文实例 解码过程，用于存储和接收编码器配置，打开一个媒体文件时候FFmpeg会从文件头部解析出视频流的编码参数，包括像视频宽度高度，像素格式，时间基准，音视频采样率等。另外配置编码器选项，跳帧策略，线程数，错误隐藏策略，是否允许多线程解码。传递压缩数据和接收原始数据： 会把压缩后的 AVPacket （例如一个H.264 NALU）传递给 AVCodecContext 对应的解码器（通过 avcodec_send_packet）。解码器处理后，会从 AVCodecContext 对应的解码器中读取解码后的 AVFrame （例如YUV像素数据或PCM采样数据，通过 avcodec_receive_frame）。 编码过程。首先还是设置编码参数，包括输入原始视频的尺寸和格式，编码器的时间基准，B帧最大数量等。配置编码选项，例如一些预设和调优，编码速度，编码模式等。传递原始数据和接收压缩数据： 你会把原始的 AVFrame （例如YUV像素数据或PCM采样数据）传递给 AVCodecContext 对应的编码器（通过 avcodec_send_frame）。编码器处理后，你会从 AVCodecContext 对应的编码器中读取压缩后的 AVPacket （例如H.264 NALU或AAC帧，通过 avcodec _receive_packet）。 这个接口一般是应用程序和底层编解码算法之间的桥梁，FFmpeg由此提供了统一的接口来配置不同的编解码器。有关于其他参数的解析还是看一下雷博士的博客。 AVCodec AVCodec代表了一个具体的已经注册的编码器算法，它是一个只读的结构体，包含着这个编码器本身的静态通用信息，和能力。以及只想内部实现函数的指针。一般通过avcodec_find_decoder或者avcodec_find_encoder来获取这样一个指针。可以理解这是一个解码算法所提供的指针。 要注意AC的存储是以一个全局的注册列表形式（可能是一个链表或是其他的数据结构）实现的。由于FFmpeg时支持多种音视频编解码的这些编解码器在编译时可以被静态链接，作为共享库进行动态加载，允许 FFmpeg 在运行时动态地查找和选择合适的编解码器。 AVCodec 定义了编解码器的抽象接口（例如 decode, encode, init, close 等函数指针）。具体的编解码器实现（例如 libx264、libvpx、libfdk_aac 等第三方库或 FFmpeg 内部实现）则通过 AVCodec 结构体将自己注册到 FFmpeg 中。这种设计使得 FFmpeg 核心库无需知道所有编解码器的具体实现细节，只需通过统一的 AVCodec 接口来调用它们。 存数据视频的话，每个结构一般是存一帧；音频可能有好几帧 解码前数据：AVPacket 这个结构体比较简单，都是一些时间戳，大小之类的数据， 解码后数据：AVFrame AF中包含了多个码流参数，其中又以data数组为核心，主要是存储原始数据。在data数组中对于packed和planar数据的存储格式是不一样的。 在AVPictureType结构体中IBP较为常见，但是要注意S\\SI\\BI\\BP帧类型，S 帧是一种特殊的编码帧，它本身是帧间预测的（像 P 帧），但它的预测信息（运动矢量、残差）可以被后续的 I 帧或 P 帧作为参考。SI 帧是一种特殊的 I 帧。它所有的宏块都是帧内编码的（像 I 帧一样），所以它是一个独立的帧，不依赖其他帧进行预测。 它的主要作用也是提供随机访问点，但它通常是为了更快速、更鲁棒的切换而设计。与普通的 I 帧相比，SI 帧可能在编码方式或解码端处理上有一些特定优化，以确保在它这里可以立即开始一个新的解码序列。BI 帧是一种非常特殊的帧，它包含的宏块全部是帧内编码的（就像 I 帧），但它却像 B 帧一样，既可以被向前参考，也可以被向后参考。SP 帧是一种特殊的 P 帧。它的大部分宏块都是帧间预测的（像 P 帧），但它的预测信息（运动矢量、残差）可以被后续的 I 帧或 P 帧作为参考。 qscale_table，网上绝大部分关于这个结构体的论述都是搬得雷博士的，需要注意宏块在视频帧指的是一个矩形块，而QP值其实是QP_step的一个索引，规定了宏块的采样步数，这个索引表是可以被查到的。 另外以及像运动矢量和运动估计参考帧都比较容易理解 在内存中packet和frame是如何进入队列，并等待被利用的呢 首先packet的拷贝有两种，深拷贝和浅拷贝，packet内部会初始化一个buffer指针，通过引用这个指针实现对数据包的引用。以浅拷贝为例，由于指针固定，无法精准保证释放的时候别的部分没有利用这部分数据空间，因此引入计数器，引用+1.释放—1，如果引用计数为0，那么就可以释放这片空间了。Frame的机理也是一样的 av_packet—alloc,ava_packet_free。申请和释放空间 av_init_packet 初始化AVpacket字段 av_new_packet为buffer分配内存，计数初始化为1 av_packet_ref 增加计数 av_packet_unref 减少计数 av_pakcet_move_ref 转移计数 av_packet_clone 申请结构体，并且计数加1 接下来是以雷博士做的SIMPLEST_FFMPEG_PLAYER为例（注意是第一版），在上面添加注释，详细分析每个语句的作用，以及视频播放器的工作流程。 /** **核心流程：****FFmpeg 部分：*** 初始化 FFmpeg 库。* 打开视频文件并查找视频流。* 查找并打开视频解码器。* 分配用于存储解码帧和转换后YUV帧的内存。* 初始化 SWS_Scaler (用于图像格式转换)。**SDL 部分：*** 初始化 SDL 库。* 创建 SDL 窗口、渲染器和纹理。**主循环：*** 从视频文件中读取数据包 (`AVPacket`)。* 将数据包发送给解码器 (`avcodec_decode_video2`)。* 如果解码器成功解码出图像 (`got_picture` 为真)，则：* 使用 SWS_Scaler 将解码后的帧转换为 YUV420P 格式。* （可选）将 YUV420P 数据写入文件。* 使用 SDL 更新纹理、清空渲染器、复制纹理到渲染器并呈现，从而显示视频帧。* 延时一小段时间以控制播放速度。* 刷新解码器（处理剩余的帧）。* 释放所有分配的资源并退出。**//** * 最简单的FFmpeg播放器 2 * Simplest FFmpeg Player 2 * * 作者：雷霄骅 Lei Xiaohua.注释作者：yahei * 版本2：使用SDL 2.0取代了版本1中的SDL 1.2。 * Version 2 use SDL 2.0 instead of SDL 1.2 in version 1. * * 本程序实现了一个视频文件的解码和显示（支持HEVC, H.264, MPEG2等）。 * 这是一个最简单的FFmpeg视频解码方法。 * 通过学习这个示例可以初步了解FFmpeg的解码流程。 * This software is a simplest video player based on FFmpeg. * Suitable for beginner of FFmpeg. * */#include cstddef#include stdio.h// 宏定义，确保stdint.h中的常量宏可用，例如UINT64_C#define __STDC_CONSTANT_MACROS// 根据操作系统类型包含不同的头文件路径#ifdef _WIN32// Windows 平台extern C // 声明为C风格链接，因为FFmpeg和SDL库是C语言编写的#include include/libavcodec/avcodec.h // 包含FFmpeg编解码器库头文件#include include/libavformat/avformat.h // 包含FFmpeg封装格式库头文件#include include/libswscale/swscale.h // 包含FFmpeg图像缩放/格式转换库头文件#include SDL2/SDL.h // 包含SDL2库头文件;#else// Linux 或其他类Unix平台#ifdef __cplusplus // 如果是C++编译器，使用extern Cextern C#endif#include libavcodec/avcodec.h#include libavformat/avformat.h#include libswscale/swscale.h#include SDL2/SDL.h#ifdef __cplusplus;#endif#endif// 宏定义：是否将YUV420P数据输出到文件// 如果定义为1，则会将解码并转换后的YUV420P数据写入output.yuv文件// 如果定义为0，则不写入文件#define OUTPUT_YUV420P 0int main(int argc, char* argv[]) // FFmpeg 相关的结构体指针 AVFormatContext *pFormatCtx; // 封装格式上下文，包含了文件的整体信息（如流的数量、时长等） int i, videoindex; // i用于循环，videoindex用于存储视频流的索引 AVCodecContext *pCodecCtx; // 编解码器上下文，包含了编解码器操作所需的所有参数（如宽度、高度、像素格式等） AVCodec *pCodec; // 编解码器，代表一个具体的编解码器（如H.264解码器） AVFrame *pFrame, *pFrameYUV; // pFrame用于存储解码前的数据包（原始数据），pFrameYUV用于存储解码后并转换为YUV420P格式的帧 uint8_t *out_buffer; // 用于存储转换后YUV420P数据的缓冲区 AVPacket *packet; // 数据包，存储从文件中读取的压缩数据（如H.265或H.264帧） int y_size; // Y分量的大小，用于计算YUV数据的总大小和写入YUV文件 int ret, got_picture; // ret用于接收函数返回值，got_picture指示是否解码出一张完整的图片 // SWS_Scaler 上下文，用于图像格式转换（例如从解码器的原生像素格式转换为YUV420P） struct SwsContext *img_convert_ctx; // 输入文件路径 char filepath[] = bigbuckbunny_480x272.h265; // 要播放的视频文件路径 // SDL 相关变量 int screen_w = 0, screen_h = 0; // 屏幕（窗口）的宽度和高度 SDL_Window *screen; // SDL 窗口对象 SDL_Renderer* sdlRenderer; // SDL 渲染器，用于在窗口上绘图 SDL_Texture* sdlTexture; // SDL 纹理，用于存储YUV数据并渲染到屏幕 SDL_Rect sdlRect; // SDL 矩形，定义纹理在窗口上的显示区域 FILE *fp_yuv; // 用于输出YUV文件时的文件指针 // FFmpeg 初始化 av_register_all(); // 注册所有可用的编解码器、复用器/解复用器等组件 avformat_network_init(); // 初始化网络模块，如果需要处理网络流（例如HTTP, RTSP等） pFormatCtx = avformat_alloc_context(); // 分配一个AVFormatContext结构体 // 打开输入流（文件或网络流） // avformat_open_input 负责打开媒体文件并读取其头部信息 if (avformat_open_input(pFormatCtx, filepath, NULL, NULL) != 0) printf(Couldnt open input stream. ); // 如果文件无法打开，打印错误信息 return -1; // 查找输入流信息 // avformat_find_stream_info 负责读取媒体文件的一部分，填充pFormatCtx中的流信息（nb_streams, streams等） if (avformat_find_stream_info(pFormatCtx, NULL) 0) printf(Couldnt find stream information. ); // 如果无法找到流信息，打印错误信息 return -1; // 找到视频流的索引 videoindex = -1; // 视频流索引初始化为-1（未找到） for (i = 0; i pFormatCtx-nb_streams; i++) // 遍历所有流 // 检查当前流的类型是否为视频流 if (pFormatCtx-streams[i]-codec-codec_type == AVMEDIA_TYPE_VIDEO) videoindex = i; // 找到视频流，记录其索引 break; // 退出循环 if (videoindex == -1) printf(Didnt find a video stream. ); // 如果没有找到视频流，打印错误信息 return -1; // 获取视频流的编解码器上下文 pCodecCtx = pFormatCtx-streams[videoindex]-codec; // 从视频流中获取其对应的AVCodecContext // 找到视频解码器 // avcodec_find_decoder 根据编解码器ID（pCodecCtx-codec_id）找到对应的解码器 pCodec = avcodec_find_decoder(pCodecCtx-codec_id); if (pCodec == NULL) printf(Codec not found. ); // 如果没有找到解码器，打印错误信息 return -1; // 打开解码器 // avcodec_open2 负责打开解码器，并为它分配必要的资源 if (avcodec_open2(pCodecCtx, pCodec, NULL) 0) printf(Could not open codec. ); // 如果无法打开解码器，打印错误信息 return -1; // FFmpeg 内存分配 pFrame = av_frame_alloc(); // 分配一个AVFrame结构体，用于存储解码后的原始帧数据 pFrameYUV = av_frame_alloc(); // 分配一个AVFrame结构体，用于存储转换为YUV420P格式后的帧数据 // 计算YUV420P格式的图像数据所需的大小，并分配缓冲区 out_buffer = (uint8_t *)av_malloc(avpicture_get_size(PIX_FMT_YUV420P, pCodecCtx-width, pCodecCtx-height)); // 将分配的缓冲区与pFrameYUV关联起来，avpicture_fill会设置pFrameYUV-data和pFrameYUV-linesize // 注意：在FFmpeg 4.0+版本中，PIX_FMT_YUV420P 已被 AV_PIX_FMT_YUV420P 取代 avpicture_fill((AVPicture *)pFrameYUV, out_buffer, PIX_FMT_YUV420P, pCodecCtx-width, pCodecCtx-height); packet = (AVPacket *)av_malloc(sizeof(AVPacket)); // 分配一个AVPacket结构体，用于存储从文件中读取的压缩数据包 // 输出文件信息 printf(--------------- File Information ---------------- ); av_dump_format(pFormatCtx, 0, filepath, 0); // 打印媒体文件的详细信息到控制台 printf(------------------------------------------------- ); // 初始化SWS_Scaler上下文，用于图像格式转换 // 从解码器输出的原始像素格式（pCodecCtx-pix_fmt）转换为YUV420P格式 // SWS_BICUBIC 是一个常用的缩放算法 img_convert_ctx = sws_getContext(pCodecCtx-width, pCodecCtx-height, pCodecCtx-pix_fmt, pCodecCtx-width, pCodecCtx-height, AV_PIX_FMT_YUV420P, SWS_BICUBIC, NULL, NULL, NULL);// 如果定义了OUTPUT_YUV420P宏，则打开YUV文件#if OUTPUT_YUV420P fp_yuv = fopen(output.yuv, wb+); // 以二进制写模式打开output.yuv文件#endif // SDL 初始化 // 初始化SDL视频、音频和定时器子系统 if (SDL_Init(SDL_INIT_VIDEO | SDL_INIT_AUDIO | SDL_INIT_TIMER)) printf(Could not initialize SDL - %s , SDL_GetError()); // 初始化失败，打印错误信息 return -1; screen_w = pCodecCtx-width; // 设置窗口宽度为视频宽度 screen_h = pCodecCtx-height; // 设置窗口高度为视频高度 // 创建SDL窗口 // SDL_WINDOWPOS_UNDEFINED 表示窗口位置由系统决定 // SDL_WINDOW_OPENGL 提示使用OpenGL渲染 screen = SDL_CreateWindow(Simplest ffmpeg players Window, SDL_WINDOWPOS_UNDEFINED, SDL_WINDOWPOS_UNDEFINED, screen_w, screen_h, SDL_WINDOW_OPENGL); if (!screen) printf(SDL: could not create window - exiting:%s , SDL_GetError()); // 窗口创建失败，打印错误信息 return -1; // 创建SDL渲染器 sdlRenderer = SDL_CreateRenderer(screen, -1, 0); // 创建SDL纹理 // SDL_PIXELFORMAT_IYUV 指定纹理的像素格式为IYUV (即YUV420P) // SDL_TEXTUREACCESS_STREAMING 表示纹理数据会频繁更新 sdlTexture = SDL_CreateTexture(sdlRenderer, SDL_PIXELFORMAT_IYUV, SDL_TEXTUREACCESS_STREAMING, pCodecCtx-width, pCodecCtx-height); // 设置SDL矩形，定义纹理在窗口上的显示区域 sdlRect.x = 0; sdlRect.y = 0; sdlRect.w = screen_w; sdlRect.h = screen_h; // SDL 初始化结束---------------------- // 主循环：读取、解码和显示视频帧 // av_read_frame 从输入流中读取一个AVPacket while (av_read_frame(pFormatCtx, packet) = 0) // 检查当前数据包是否属于视频流 if (packet-stream_index == videoindex) // 解码视频包 // avcodec_decode_video2 将压缩的AVPacket解码为AVFrame（原始帧） // got_picture 会在成功解码出完整图像时设置为非0 ret = avcodec_decode_video2(pCodecCtx, pFrame, got_picture, packet); if (ret 0) printf(Decode Error. ); // 解码错误 return -1; if (got_picture) // 如果成功解码出了一张完整的图片 // 图像格式转换 // sws_scale 将pFrame中的图像数据转换为YUV420P格式，并存储到pFrameYUV中 // pFrame-data 和 pFrame-linesize 包含原始帧的像素数据和行步长 // 0 表示从图像的第0行开始转换 // pCodecCtx-height 是图像的高度 // pFrameYUV-data 和 pFrameYUV-linesize 接收转换后的YUV数据和行步长 sws_scale(img_convert_ctx, (const uint8_t* const*)pFrame-data, pFrame-linesize, 0, pCodecCtx-height, pFrameYUV-data, pFrameYUV-linesize); // 如果定义了OUTPUT_YUV420P宏，则将YUV数据写入文件 #if OUTPUT_YUV420P y_size = pCodecCtx-width * pCodecCtx-height; // Y分量大小 fwrite(pFrameYUV-data[0], 1, y_size, fp_yuv); // 写入Y分量数据 fwrite(pFrameYUV-data[1], 1, y_size / 4, fp_yuv); // 写入U分量数据 (YUV420P中U/V是Y的1/4大小) fwrite(pFrameYUV-data[2], 1, y_size / 4, fp_yuv); // 写入V分量数据 #endif // SDL 渲染部分--------------------------- #if 0 // 这是一个旧的SDL_UpdateTexture用法，通常用于YUV数据的更新 SDL_UpdateTexture( sdlTexture, NULL, pFrameYUV-data[0], pFrameYUV-linesize[0] ); #else // 使用SDL_UpdateYUVTexture更新YUV纹理，更适合YUV420P三平面格式 SDL_UpdateYUVTexture(sdlTexture, sdlRect, pFrameYUV-data[0], pFrameYUV-linesize[0], // Y分量数据和行步长 pFrameYUV-data[1], pFrameYUV-linesize[1], // U分量数据和行步长 pFrameYUV-data[2], pFrameYUV-linesize[2]); // V分量数据和行步长 #endif SDL_RenderClear( sdlRenderer ); // 清空渲染器 // 将纹理复制到渲染器，NULL表示复制整个纹理到整个sdlRect定义的区域 SDL_RenderCopy( sdlRenderer, sdlTexture, NULL, sdlRect); SDL_RenderPresent( sdlRenderer ); // 更新屏幕显示 // SDL 渲染部分结束----------------------- // 延时以控制播放速度，这里简单固定延时40ms，约每秒25帧（1000ms / 40ms = 25帧） SDL_Delay(40); av_free_packet(packet); // 释放当前AVPacket的内存，准备读取下一个 // 刷新解码器（处理解码器中剩余的帧） // 在文件末尾，解码器内部可能还缓存了一些帧，需要通过不断调用解码函数直到没有更多帧输出 // 此时packet参数可以设置为NULL或一个空packet while (1) ret = avcodec_decode_video2(pCodecCtx, pFrame, got_picture, NULL); // 注意这里 packet 为 NULL if (ret 0) // 解码错误或没有更多数据 break; if (!got_picture) // 没有解码出新的图像 break; // 对剩余的帧进行格式转换和显示 sws_scale(img_convert_ctx, (const uint8_t* const*)pFrame-data, pFrame-linesize, 0, pCodecCtx-height, pFrameYUV-data, pFrameYUV-linesize); #if OUTPUT_YUV420P int y_size=pCodecCtx-width*pCodecCtx-height; // 重新计算y_size，虽然这里应该和之前一样 fwrite(pFrameYUV-data[0],1,y_size,fp_yuv); // Y fwrite(pFrameYUV-data[1],1,y_size/4,fp_yuv); // U fwrite(pFrameYUV-data[2],1,y_size/4,fp_yuv); // V #endif // SDL 显示剩余帧 SDL_UpdateTexture( sdlTexture, sdlRect, pFrameYUV-data[0], pFrameYUV-linesize[0] ); // 修正，这里应该用 SDL_UpdateYUVTexture SDL_RenderClear( sdlRenderer ); SDL_RenderCopy( sdlRenderer, sdlTexture, NULL, sdlRect); SDL_RenderPresent( sdlRenderer ); SDL_Delay(40); // 释放资源 sws_freeContext(img_convert_ctx); // 释放SWS_Scaler上下文#if OUTPUT_YUV420P fclose(fp_yuv); // 关闭YUV输出文件#endif SDL_Quit(); // 退出SDL子系统 av_frame_free(pFrameYUV); // 释放YUV帧的内存 av_frame_free(pFrame); // 释放原始帧的内存 avcodec_close(pCodecCtx); // 关闭编解码器上下文 avformat_close_input(pFormatCtx); // 关闭输入流上下文 return 0; // 程序成功退出","tags":["C++","FFmpeg"],"categories":["technology","音视频"]},{"title":"CMakeLists中的常见字段","path":"/2025/06/07/CMakeLists常见字段/","content":"CMakeLists.txt 中的核心是一系列的命令（commands）和变量（variables）。通过这些命令，我们向 CMake 声明项目的各种特性和构建规则。 以下是一些 CMakeLists.txt 中最常见和重要的“字段”（或者说，命令和变量）： 核心项目配置命令 cmake_minimum_required(VERSION major.minor [FATAL_ERROR]) 作用： 指定项目所需的最低 CMake 版本。这是每个 CMakeLists.txt 文件的第一行。它确保你的项目不会在旧版本的 CMake 上编译，旧版本可能不支持你使用的某些命令或特性。 示例： cmake_minimum_required(VERSION 3.10) project(PROJECT_NAME [LANGUAGES language...] [VERSION major[.minor[.patch[.tweak]]]]) 作用： 定义项目的名称。这是顶级 CMakeLists.txt 中仅次于 cmake_minimum_required 的第二条命令。它也可能指定项目支持的语言（如 CXX, C, Fortran）和版本。 示例： project(simplest_ffmpeg_player CXX VERSION 1.0) 源文件、目标和依赖管理 add_executable(target_name [source1] [source2] ...) 作用： 定义一个可执行目标。这是最常见的命令之一，它告诉 CMake 将指定的源文件编译并链接成一个可执行程序。 示例： add_executable(my_app main.cpp helper.cpp) add_library(target_name [STATIC | SHARED | MODULE] [source1] [source2] ...) 作用： 定义一个库目标。你可以指定它是静态库 (STATIC)、动态库 (SHARED) 还是模块库 (MODULE)。 示例： add_library(my_static_lib STATIC static_func.cpp) add_library(my_shared_lib SHARED shared_func.cpp) target_sources(target [PRIVATE|PUBLIC|INTERFACE] source1 [source2] ...) 作用： 向一个已存在的 target 添加源文件。当源文件很多或需要根据条件添加时，这个命令比直接在 add_executableadd_library 中列出更灵活。 示例： target_sources(my_app PRIVATE main.cpp) target_include_directories(target [PRIVATE|PUBLIC|INTERFACE] [dir1] [dir2] ...) 作用： 指定某个目标（可执行文件或库）的头文件搜索路径。 PRIVATE：只影响当前目标本身的编译。 PUBLIC：影响当前目标本身的编译，也影响链接到此目标的任何其他目标。 INTERFACE：只影响链接到此目标的任何其他目标。 示例： target_include_directories(my_app PUBLIC $CMAKE_SOURCE_DIR/include) target_link_libraries(target [PRIVATE|PUBLIC|INTERFACE] [item1] [item2] ...) 作用： 指定某个目标需要链接的库。这可以是其他 CMake 目标，也可以是外部库。链接顺序在某些情况下很重要。 示例： target_link_libraries(my_app PRIVATE my_shared_lib Qt5::Widgets) add_subdirectory(source_dir [binary_dir] [EXCLUDE_FROM_ALL]) 作用： 包含另一个子目录中的 CMakeLists.txt 文件。这对于组织大型项目结构非常有用。 示例： add_subdirectory(src) 变量和属性设置 set(variable value [CACHE type docstring [FORCE]]) 作用： 设置 CMake 变量的值。变量在 CMake 脚本内部使用，可以存储路径、选项等。CACHE 选项用于创建用户可以在 CMake GUI 或命令行中配置的缓存变量。 示例： set(SOURCE_FILES main.cpp) set(CMAKE_CXX_STANDARD 17) (设置C++标准，这是一个重要的内置变量) set(BUILD_SHARED_LIBS ON CACHE BOOL Build shared libraries FORCE) option(variable Help string [initial value]) 作用： 创建一个布尔选项，用户可以在 CMake 配置时启用或禁用。 示例： option(BUILD_TESTS Build unit tests ON) 查找包和依赖 find_package(PackageName [version] [REQUIRED] [COMPONENTS comp1 comp2...] [OPTIONAL_COMPONENTS comp3...] [NO_MODULE] [NO_CONFIG]) 作用： 查找并加载外部依赖包（如 Boost, OpenCV, Qt 等）。如果找到，它会设置一些变量（如 PackageName_FOUND，PackageName_INCLUDE_DIRS，PackageName_LIBRARIES）或导入目标（如 Qt5::Widgets）。 示例： find_package(SDL2 REQUIRED) 条件和循环控制流 if (...) ... elseif (...) ... else (...) ... endif() 作用： 条件语句，根据条件执行不同的命令。 示例： if(WIN32) message(Building on Windows)elseif(UNIX) message(Building on Unix-like system)endif() foreach(loop_var item1 [item2 ...] ) ... endforeach() 作用： 循环遍历列表。 示例： set(MY_SOURCES a.cpp b.cpp c.cpp)foreach(src_file $MY_SOURCES) message(Processing $src_file)endforeach() 其他常用命令 message([STATUS|WARNING|AUTHOR_WARNING|FATAL_ERROR|CHECK_START|CHECK_DONE|CHECK_FAIL] message to display) 作用： 在 CMake 配置过程中输出信息到控制台。对于调试和用户提示非常有用。 示例： message(STATUS Configuring $PROJECT_NAME project...) file(GLOB variable [LIST_DIRECTORIES true|false] [RELATIVE path] [pattern1] [pattern2] ...) 作用： 查找匹配给定模式的文件，并将结果存储到变量中。常用于收集源文件。 示例： file(GLOB SOURCE_FILES src/*.cpp src/*.c) 注意： 虽然方便，但 file(GLOB) 在某些情况下可能不是最佳实践，因为它不处理文件删除的情况（需要重新运行 CMake）。更推荐显式列出源文件或使用 target_sources。 install(...) 作用： 定义项目的安装规则，例如将可执行文件、库、头文件安装到系统目录或指定目录。 示例： install(TARGETS my_app DESTINATION bin)install(DIRECTORY include/ DESTINATION include)","tags":["C++","编程基础","CMake"],"categories":["technology","编程基础"]},{"title":"音视频传输","path":"/2025/06/01/音视频/","content":"视频播放器原理视频播放器拓扑结构 解协议的作用，就是将流媒体协议的数据，解析为标准的相应的封装格式数据。视音频在网络上传播的时候，常常采用各种流媒体协议，例如HTTP，RTMP，或是MMS等等。这些协议在传输视音频数据的同时，也会传输一些信令数据。这些信令数据包括对播放的控制（播放，暂停，停止），或者对网络状态的描述等。解协议的过程中会去除掉信令数据而只保留视音频数据。例如，采用RTMP协议传输的数据，经过解协议操作后，输出FLV格式的数据。解封装的作用，就是将输入的封装格式的数据，分离成为音频流压缩编码数据和视频流压缩编码数据。封装格式种类很多，例如MP4，MKV，RMVB，TS，FLV，AVI等等，它的作用就是将已经压缩编码的视频数据和音频数据按照一定的格式放到一起。例如，FLV格式的数据，经过解封装操作后，输出H.264编码的视频码流和AAC编码的音频码流。解码的作用，就是将视频/音频压缩编码数据，解码成为非压缩的视频/音频原始数据。音频的压缩编码标准包含AAC，MP3，AC-3等等，视频的压缩编码标准则包含H.264，MPEG2，VC-1等等。解码是整个系统中最重要也是最复杂的一个环节。通过解码，压缩编码的视频数据输出成为非压缩的颜色数据，例如YUV420P，RGB等等；压缩编码的音频数据输出成为非压缩的音频抽样数据，例如PCM数据。视音频同步的作用，就是根据解封装模块处理过程中获取到的参数信息，同步解码出来的视频和音频数据，并将视频音频数据送至系统的显卡和声卡播放出来。 流媒体协议 封装格式 视频编码 音频编码 名称 推出机构 推出时间 目前使用领域 LDAC Sony Corporation 2015 高分辨率无线音频传输，主要应用于索尼耳机播放器与安卓设备之间（需要设备支持） 关于LDAC的补充说明： 高分辨率音频传输： LDAC是索尼开发的一种音频编码技术，旨在通过蓝牙连接传输高分辨率（Hi-Res Audio）音频。它能够传输比传统蓝牙编解码器（如SBC）更高码率的数据，从而在无线传输中保留更多的音频细节。 码率： LDAC支持多种传输码率，最高可达990 kbps（在最佳连接条件下），这远高于SBC（最高约328 kbps）和aptX HD（576 kbps）。 应用场景： 主要用于索尼自家的音频产品（如WH-1000XM系列耳机、Walkman播放器）以及支持LDAC的安卓智能手机。它是安卓8.0（Oreo）及更高版本系统中的一个标准蓝牙音频编解码器。 局限性： 尽管LDAC能够传输高码率音频，但其传输质量受限于蓝牙连接的稳定性。在复杂的无线环境下，码率可能会自适应下降以维持连接。此外，其使用范围主要集中在索尼和安卓生态系统内，苹果iOS设备目前不支持LDAC。 与传统编码器的区别： 与你表格中列出的AAC、MP3、AC-3、WMA等主要用于音频文件存储和流媒体分发的编码器不同，LDAC更侧重于无线传输过程中的高质量编码，尤其是在蓝牙这个带宽有限的载体上。AAC、MP3等通常是音频文件的格式，而LDAC是传输协议的一部分，用于将这些格式的音频数据通过蓝牙高效传输。 上面介绍了常见的协议、封装、编码。下面举其中经典的例子来做原理说明 协议之RTSP封装之FLV flv封装由文件头和文件体组成，其中body部分由多个previous tag size四个字节，要来标志前一个tag的字节数据长度，第一个PTS为0 + tag有三种类型，包括音频、视频、和脚本类型.其中同样包括header和data。header一般为11字节组成。 具体如下： UI表示无符号整形，后面跟的数字表示其长度是多少位。比如UI8，表示无法整形，长度一个字节。UI24是三个字节,UI[8*n]表示多个字节。UB表示位域，UB5表示一个字节的5位。可以参考c中的位域结构体。 tag部分详解 脚本类型tag这里会存放一些相关与FLV视频和音频的元信息。比如:duration，width,heigth 等。通常该类型Tag会作为FLV文件的第一个tag，并且只有一个，跟在File Header后。该类型Tag DaTa的结构如下所示:第一个AMF包：第1个字节表示AMF包类型，一般总是0x02，表示字符串。第2-3个字节为UI16类型值，标识字符串的长度，一般总是0x000A（“onMetaData”长度）。后面字节为具体的字符串，一般总为“onMetaData”（6F,6E,4D,65,74,61,44,61,74,61）。 第二个AMF包：第1个字节表示AMF包类型，一般总是0x08，表示数组。第2-5个字节为UI32类型值，表示数组元素的个数。后面即为各数组元素的封装，数组元素为元素名称和值组成的对。常见的数组元素如下表所示。 音频类型tag第一个字节是音频信息，第二个字节之后是音频信息。 视频类型tag第一个字节信息第二个字节之后是视频流 视频编码之H264视频帧内编码视频编码词用压缩技术来减少码率，而压缩的理论依据主要来源于： 数据冗余，通过关联图像中的各像素，来实现无损压缩 视觉冗余，在人眼的可分辨范围外通过引入客观失真来实现有损压缩。 变换编码：首先将源图像切割，然后对切割后的小块进行DCT变换，这个小块叫做宏块，在对图像块经过DCT变换后的系数进行量化，在传送过程中只传递一部分数据。实现有损压缩。实现有损压缩。 视频帧间编码采用运动估计和运动补偿的方法来实现，第一步还是实现图像分割，然后在前一图像或者后抑恶图像某个搜索窗口的范围内未每一一个图像块寻找最为相似的图像块，通过计算这两个图像块的变换关系得到运动矢量。将两个图像块相减得到残差图像。前一个过程叫做运动估计，后一个过程叫做运动补偿。在H264中为了提高视频压缩质量，引入I帧、P帧、B帧。 I帧只使用本帧内数据编码，不需要考虑消除时间序列相关性。P帧使用前面的I帧或P帧来做运动估计和补偿。B帧使用前面的一个I帧或P帧，或后面一个I帧或P帧；来进行预测。使用B帧可以实现高压缩比。但是如果P帧和参考B帧遭到破坏，其他所有依赖于它们的帧就不能完整解码，这会直接导致视频故障。视频通常无法从此类问题中恢复。然而，当被破坏的视频流到达I帧，因为I帧被独立地编码解码，所以视频问题可以从I帧恢复。 一个序列的第一个图像叫做IDR 图像（立即刷新图像），IDR 图像都是 I 帧图像。引入 IDR 图像是为了解码的重同步，当解码器解码到 IDR 图像时，立即将参考帧队列清空，将已解码的数据全部输出或抛弃，重新查找参数集，开始一个新的序列。这样，如果前一个序列出现重大错误，在这里可以获得重新同步的机会。IDR图像之后的图像永远不会使用IDR之前的图像的数据来解码。 一个序列就是一段内容差异不太大的图像编码后生成的一串数据流。当运动变化比较少时，一个序列可以很长，因为运动变化少就代表图像画面的内容变动很小，所以就可以编一个I帧，然后一直P帧、B帧了。当运动变化多时，可能一个序列就比较短了，比如就包含一个I帧和3、4个P帧。 在视频编码序列中，GOP即Group of picture（图像组），指两个I帧之间的距离，Reference（参考周期）指两个P帧之间的距离。两个I帧之间形成一组图片，就是GOP。 编码器算法视频编码器能够自主的比较帧内预测和帧间预测的结果，选择出最佳结果，即模式选择。并且编码器应该对每个宏块能做出如下处理： 后向预测（使用未来的帧） 前向预测（使用过去的帧） 无帧间预测，仅帧内预测 完全跳过（帧内或帧间预测） 下面重点解释一下B帧预测的逻辑。 我们用一个简化的模型来描述 B 帧的预测过程。假设我们有一个 GOP 结构，例如：I B B P B B I。 当编码器处理某个 B 帧时，例如，在 P1 和 P2 之间的 B1 帧：P1 --- B1 --- P2 B帧的预测通常涉及以下步骤： 确定参考帧列表 (Reference Picture Lists)： 每个 B 帧在编码时会维护两个参考帧列表： List 0 (L0)： 包含在其显示时间戳之前的参考帧（通常是 I 或 P 帧）。 List 1 (L1)： 包含在其显示时间戳之后的参考帧（通常是 I 或 P 帧）。 这些参考帧可以是比当前 B 帧更早或更晚解码的 IP 帧。例如，对于 B1，P1 位于 L0，P2 位于 L1。 宏块或子块级别预测：B帧的预测是以宏块（Macroblock，16x16 像素）或更小的子块为单位进行的。对于当前 B 帧中的一个宏块： a. 向前预测 (Forward Prediction)： 编码器在 List 0 中的参考帧（例如 P1）中搜索与当前宏块最相似的区域。 找到最相似的区域后，计算出**运动矢量 (Motion Vector, MV)**，这个 MV 指示了从参考帧中的哪个位置到当前宏块位置的位移。 记录下这个运动矢量和对应的预测残差（当前宏块与向前预测结果的差异）。 b. 向后预测 (Backward Prediction)： 编码器在 List 1 中的参考帧（例如 P2）中搜索与当前宏块最相似的区域。 计算出另一个运动矢量 (MV’)。 记录下这个运动矢量和对应的预测残差。 c. 双向预测 (Bi-directional Prediction)： 这是 B 帧特有的强大功能。编码器会尝试结合 向前预测的结果 和 向后预测的结果 来生成一个更准确的预测。 加权平均： 最常见的方法是对向前预测和向后预测的结果进行加权平均。例如，如果 B1 刚好位于 P1 和 P2 的中间，可能会对两个预测结果各取 50% 进行叠加。 选择更好的预测模式： 编码器会比较三种预测模式（向前、向后、双向）产生的预测残差大小，选择残差最小的模式。残差越小，说明预测越准确，需要编码的数据量就越少。 编码残差和运动信息： 无论选择哪种预测模式，B 帧最终编码的都是预测残差（当前宏块的实际像素值与预测结果之间的差异）以及用于预测的运动矢量和参考帧索引。 由于预测残差通常包含的能量非常小（因为预测得很准确），所以经过变换、量化和熵编码后，数据量会非常小。 举例说明 假设我们有三帧画面，编码顺序和显示顺序可能如下： 显示顺序： F1 (I) - F2 (B) - F3 (P) - F4 (B) - F5 (P) 解码顺序（为了先解码参考帧）： F1 (I) - F3 (P) - F2 (B) - F5 (P) - F4 (B) 我们聚焦在 F2 (B帧) 如何编码： 解码 F1 (I帧)： F1 是一个完整的独立帧，不依赖其他帧。 解码 F3 (P帧)： F3 依赖 F1 进行预测。编码器从 F1 中找到 F3 各个宏块的相似区域，记录下运动矢量和残差。 解码 F2 (B帧)： F2 知道它在显示顺序上介于 F1 和 F3 之间。 对于 F2 中的一个宏块： 向前预测： 编码器在 F1 中找一个最像的块，记录 MV。 向后预测： 编码器在 F3 中找一个最像的块，记录 MV’。 双向预测： 将 F1 的预测块和 F3 的预测块进行平均或加权平均，形成一个双向预测块。 编码器会比较这三种方式的预测残差大小。例如，如果 F2 上的一个物体是从 F1 运动到 F3 过程中的中间位置，那么双向预测往往能得到最小的残差。如果 F2 上的一个静止背景在 F1 和 F3 中都有，那么向前或向后预测就足够了。 最终，F2 编码并存储：哪个预测模式、哪个参考帧（L0或L1）、运动矢量、以及实际的预测残差。 H264解析同样的在H264中也有IBP帧类型，但是更重要的时其中的两层功能概念、NALU概念、slice、以及两种格式： 在H264中图像以序列为单位进行组织，一个序列是一段图像编码后的数据流。即NALU，它的功能分为两层，VCL（视频编码层）和NAL（网络提取层）。 两层功能 VCL包括核心压缩引擎和块，宏块和片的语法级别定义，设计目标是尽可能独立于网路进行高效的编码。具体步骤如下： 压缩：预测（帧内预测和帧间预测）- DCT 变化和量化 - 比特流编码； 切分数据，主要为了第三步。这里一点，网上看到的“切片（slice）”、“宏块（macroblock）”是在VCL 中的概念，一方面提高编码效率和降低误码率、另一方面提高网络传输的灵活性。 压缩切分后的 VCL 数据会包装成为 NAL 中的一部分。 NAL负责将VCL产生的比特字符串适配到各种各样的网络和多元环境中去。覆盖了所有片级以上语法。 NALUNALU header+Payloadheader一般有一个字节组成，如下图 forbidden位在网络发生i错误的时候会被置为1，告诉对方丢掉这个单元。 nal_ref_idc表示当前NALU的重要性，若值小，在解码器处理不过来的时候可以选择丢掉 nal_unit_type表示NALU类型 1-4：IPB帧，如果 nal_ref_idc 为 0，则表示 I 帧，不为 0 则为 PB 帧。 5：IDR帧，I 帧的一种，告诉解码器，之前依赖的解码参数集合（接下来要出现的 SPS\\PPS 等）可以被刷新了。 6：SEI，英文全称 Supplemental Enhancement Information，翻译为“补充增强信息”，提供了向视频码流中加入额外信息的方法。 7：SPS，全称 Sequence Paramater Set，翻译为“序列参数集”。SPS 中保存了一组编码视频序列（Coded Video Sequence）的全局参数。因此该类型保存的是和编码序列相关的参数。 8: PPS，全称 Picture Paramater Set，翻译为“图像参数集”。该类型保存了整体图像相关的参数。 9：AU 分隔符，AU 全称 Access Unit，它是一个或者多个 NALU 的集合，代表了一个完整的帧，有时候用于解码中的帧边界识别。 SPS 和 PPS 存储了编解码需要一些图像参数，SPS,PPS 需要在 I 帧前出现，不然解码器没法解码。而 SPS,PPS 出现的频率也跟不同应用场景有关，对于一个本地 h264 流，可能只要在第一个 I 帧前面出现一次就可以，但对于直播流，每个 I 帧前面都应该插入 sps 或 pps，因为直播时客户端进入的时间是不确定的。 对于Payload,H264也做了不同类型的规定 SODB，英文全称 String Of Data Bits，称原始数据比特流，就是最原始的编码压缩得到的数据。 RBSP英文全称 Raw Byte Sequence Payload，又称原始字节序列载荷。和 SODB 关系如下：RBSP SODB + RBSP Trailing Bits（RBSP尾部补齐字节），引入 RBSP Trailing Bits 做 8 位字节补齐。 EBSP英文全称 Encapsulated Byte Sequence Payload，称为扩展字节序列载荷。和 RBSP 关系如下： EBSP ：RBSP插入防竞争字节（0x03）这里说明下防止竞争字节（0x03）：可以先认为 H264 会插入一个叫做 StartCode 的字节串来分割 NALU，于是问题来了，如果 RBSP 中也包括了 StartCode（0x000001 或 0x00000001）怎么办呢？所以，就有了防止竞争字节（0x03）： sliceH264视频压缩后会成为一个序列帧，帧里包含图像，图像分为很多片，每个片可以分为宏块，每个宏块由许多子块组成 H264结构中，一个视频图像编码后的数据叫做一帧，一帧由一个片（slice）或多个片组成，一个片由一个或多个宏块（MB）组成，一个宏块由16x16的yuv数据组成。宏块作为H264编码的基本单位。 场和帧：视频的一场或者一帧可以用来产生一个编码图像。在电视中，每个电视帧都是通过扫描屏幕两次而产生的，第二个扫描的线条刚好填满第一次扫描所留下的缝隙。每个扫描即称为一个场。因此 30 帧秒的电视画面实际上为 60 场秒 片：每个图像中，若干个宏块被排列成片。片的目的：为了限制误码的扩散和传输，使编码片相互间保持独立。片共有5种类型：I片（只包含I宏块）、P片（P和I宏块）、B片（B和I宏块）、SP片（用于不同编码流之间的切换）和SI片（特殊类型的编码宏块）。NALU中承载的就是这些片 宏块：一个编码图像首先要划分成多个块（4x4 像素）才能进行处理，显然宏块应该是整数个块组成，通常宏块大小为16x16个像素。宏块分为I、P、B宏块，I宏块只能利用当前片中已解码的像素作为参考进行帧内预测；P宏块可以利用前面已解码的图像作为参考图像进行帧内预测；B宏块则是利用前后向的参考图形进行帧内预测 两种格式分别为字节流AnnexB格式 和 AVCC格式。前者用于实时播放，后者用于存储 AnnexB格式在这种格式中每个NALU都必须使用start code来分割（0x000001,单帧多个slice或0x00000001，帧之间，或者SPS、PPS等之前一般是四字节），并且SPS和PPS按流的方式写在头部。 NALU header+EBSP AVCC在这种格式中，每一个NALU包都加上了一个指定其长度(NALU包大小)的前缀(in big endian format大端格式)，这种格式的包非常容易解析，但是这种格式去掉了Annex B格式中的字节对齐特性，而且前缀可以是1、2或4字节，这让AVCC格式变得更复杂了，指定前缀字节数(1、2或4字节)的值保存在一个头部对象中(流开始的部分)，这个头通常称为’extradata’或者’sequence header’。 音频编码之AAC同样在音频方向也包括有损压缩和无损压缩。有损即去掉弱音信号或者去掉人耳听觉范围外的频率（20Hz||20KHz）. 关于音频的采样量化等方法以传统的PCM为例。 常见的无损方法： FLAC (Free Lossless Audio Codec): 目前最流行的无损音频编码格式，开源、免费。 APE (Monkey’s Audio): 另一种流行的无损格式，但解码复杂度较高。 ALAC (Apple Lossless Audio Codec): 苹果开发的无损格式，用于其生态系统。 WavPack (WV): 灵活的混合模式无损格式。 DSDDSFDFF: 用于高解析度音频的特殊无损格式，不完全是 PCM 编码。 有损方法较多，后面再详细学习，这里只聊一下AAC。 AAC编码文件格式文件有两种： ADIF：Audio Data Interchange Format 音频数据交换格式。这种格式的特征是可以确定的找到这个音频数据的开始，不需进行在音频数据流中间开始的解码，即它的解码必须在明确定义的开始处进行。故这种格式常用在磁盘文件中。 ADTS：Audio Data Transport Stream 音频数据传输流。这种格式的特征是它是一个有同步字的比特流，解码可以在这个流中任何位置开始。它的特征类似于mp3数据流格式。这种格式可以用于广播电视。 简言之。ADIF只有一个文件头，ADTS每个包前面有一个文件头。 对于AAC的头，一般为七个字节或者五个字节。具体头格式查表。","tags":["RTSP","音视频传输","音视频编解码"],"categories":["technology","音视频"]},{"title":"MCP中的细节问题","path":"/2025/05/23/MCP/","content":"MCP协议以及其中的客户端和服务器 首先附上up画的对我启发极大的一张图片。这张图片中讲了各大部件之间的关系。 从MCP协议为起点，MCP（Model Context Protocol），即模型上下文协议，正是这样一个旨在解决大型语言模型（LLM）与外部世界交互问题的开放标准。 MCP采用客户端-服务器（Client-Server）架构模式： Host（主机）LLM 应用： 代表大型语言模型应用程序，例如Claude Desktop、Cursor等，它们是发起连接的一方。 Client（客户端）： 在Host应用程序内部负责与MCP服务器建立连接，其实可以理解成Agent与MCP协议的集合。 MCP Server（MCP服务器）： 这是MCP系统中最关键的环节。它是一个程序，提供工具和数据访问能力供LLM使用。MCP服务器可以作为本地应用运行在用户设备上，也可以部署到远程服务器。每个MCP服务器都提供一组特定的工具（Tools）、资源（Resources）和提示（Prompts）： 1. 工具（Tools）： 供AI模型调用的函数或操作，例如查询数据库、发送邮件、执行代码等。在面对一些没有提供程序接口的软件的时候，可以考虑写一些Py脚本或者命令行工具来实现我们的需求，例如打开项目文件，修改模型参数，运行仿真，提取仿真结果等。另外一种方式，时可以选择一些自动化的GUI库，这样的话就需要很多OCR的token了2. 资源（Resources）： 供用户或AI模型使用的上下文和数据，例如API回复、文件内容等。3. 提示（Prompts）： 用于完成特定任务的预定义提示模板。当LLM需要获取信息或执行操作时，它会通过MCP客户端向MCP服务器发送请求。MCP服务器会与相应的外部数据源或工具进行交互，获取数据并按照MCP协议规范进行格式化，最后将格式化后的数据返回给LLM。 回到上图，由于这个协议是用来规范Agent和各种tools之间的通信，调用格式规范的，由此可以将客户端的开发与服务器的开发分离开。因此开发可以分成三个大部分， 大模型部分的工作与RAG架构第一个部分是大模型部分，包括微调、如何设计一个专用模型，如何减少幻觉、目前的RAG架构如何进行优化等等工作。 简单介绍一下RAG架构 想象一下，LLM就像一个博览群书但只活在“过去”的人（因为它的知识截止于训练数据）。RAG给它配了一个“实时图书馆管理员”和一套“搜索工具”。 RAG核心思路：当用户提出一个问题时，RAG不是直接让LLM回答，而是分两步走： 检索 (Retrieval)： 从一个外部知识库（你的“实时图书馆”）中找出与用户问题最相关的几段信息。 增强生成 (Augmented Generation)： 将这些检索到的信息和用户的问题一起喂给LLM，让LLM基于这些“上下文”来生成答案。 RAG架构详解与举例：假设你正在研究一个新的相控阵天线设计，并且你有一个内部的技术文档库，里面包含了最新的天线设计规范、材料特性和仿真结果。 用户问题： “最新的MIMO相控阵天线设计中，氮化镓（GaN）材料的关键优势是什么？” 第一步：知识库准备 (提前进行)这是RAG的基础，你需要把你的“实时图书馆”整理好。 文档收集： 收集所有相关的技术文档、研究论文、设计规范等。 Chunking (分块)： 概念： 大文档被分割成更小的、有意义的文本片段，称为“Chunk”（块）。 目的： LLM的输入有长度限制（上下文窗口），而且太大的块会稀释关键信息。把文档切成小块，可以更精准地检索。 举例： 你的一篇关于GaN材料特性的长论文，会被切分成多个Chunk，例如： Chunk 1: “GaN在射频（RF）应用中的基本特性和历史…” Chunk 2: “GaN在MIMO相控阵天线中的功率密度和效率优势…” Chunk 3: “GaN与其他半导体材料（如GaAs）的对比…” Chunk 4: “GaN器件的散热挑战和解决方案…” 切分策略： 可以按句子、段落、固定长度（带重叠）等方式切分。对于技术文档，考虑语义完整性很重要。 Embedding (嵌入)： 概念： 将每个文本Chunk转换成一个高维的数字向量（一串数字），这个向量能够捕捉Chunk的语义信息。语义相似的Chunk，它们的Embedding向量在向量空间中也会靠得很近。 技术： 使用专门的Embedding模型（例如OpenAI的text-embedding-ada-002，或者开源的BERT、Sentence-BERT等模型）来完成。 举例： Chunk 1的Embedding向量：$[0.1, -0.5, 0.3, …, 0.8]$ Chunk 2的Embedding向量：$[0.15, -0.48, 0.32, …, 0.79]$ (与Chunk 1在向量空间中距离较近，因为都与GaN相关) Chunk 3的Embedding向量：$[0.6, 0.2, -0.1, …, 0.9]$ (与前两个距离较远，主题不同) 存储： 这些Embedding向量会被存储在一个向量数据库（Vector Database，如Pinecone, Weaviate, Milvus, ChromaDB等）中，以便快速检索。 第二步：实时查询 (当用户提问时) 用户问题Embedding： 当用户提出问题 “最新的MIMO相控阵天线设计中，氮化镓（GaN）材料的关键优势是什么？” 时，首先会使用与Chunk Embedding相同的Embedding模型将这个问题也转换成一个Embedding向量。 举例： 问题的Embedding向量：$[0.12, -0.51, 0.31, …, 0.81]$ 向量相似度搜索 (Retrieval)： 将用户问题的Embedding向量与向量数据库中所有Chunk的Embedding向量进行比较。 寻找语义上最相似的Chunk（即向量距离最近的Chunk）。 举例： 向量数据库会找出 Chunk 2 (“GaN在MIMO相控阵天线中的功率密度和效率优势…”) 和其他几个与GaN或MIMO相关的Chunk，因为它们的向量与问题向量距离最近。通常会检索Top-K个（比如Top-3或Top-5）最相关的Chunk。 增强生成 (Augmented Generation)： 将检索到的相关Chunk的原文内容（不是Embedding向量）和用户的问题一起打包成一个Prompt，发送给LLM。 Prompt结构示例： 请根据以下提供的信息，回答用户的问题：---信息1：[Chunk 2 的原文内容] GaN在MIMO相控阵天线中的功率密度和效率优势使其成为关键材料。其高击穿电压和电子迁移率，使得GaN器件能够工作在更高的频率和功率水平，从而实现更紧凑、更高性能的天线模块...信息2：[Chunk 5 的原文内容] 此外，GaN在高温下的稳定性也优于其他半导体材料，这对于MIMO天线在高功率运行时的散热设计至关重要...---用户问题：最新的MIMO相控阵天线设计中，氮化镓（GaN）材料的关键优势是什么？ LLM接收到这个“增强”后的Prompt，它现在不仅有自己原有的知识，还有了来自外部知识库的最新、最具体的信息。 LLM结合这些信息进行理解、推理和生成，给出更准确、更专业的答案。 LLM的最终回答： “在最新的MIMO相控阵天线设计中，氮化镓（GaN）材料的关键优势体现在其高功率密度、高效率以及在高温下的卓越稳定性。GaN的高击穿电压和电子迁移率使其能在更高频率和功率水平下运行，从而实现更紧凑、高性能的天线模块。此外，其优异的热稳定性对高功率MIMO天线的散热设计至关重要。” 但是就像我之前读过的一个知乎大佬所写的文章所说的，能不自己部署模型，就不自己部署。 自己部署的硬件成本和维护成本，对于小团队来说，很可能是压垮骆驼的一座大山。 Agent开发第二个是Agent的开发部分，也就是客户端部分，关于这部分已经写过一些内容了。 这里还应该注意的是，由于MCP协议，其实不需要关注agent输入与输出的设计，只需要根据不同的业务场景选择，Agent的输出究竟选择JSON格式还是选择使用Prompt格式即可，如何设计Prompt也就成了重点。 服务器部分第三个是服务器部分，未来会在这个方向做一些探索。 这里包含很多的部分，像Tools的设计，也就是如何根据业务场景写一个函数的库来供Agent进行调用。另外在写库函数时要格外注意docstr的书写，函数变量的命名，这里其实和Prompt设计有异曲同工之妙了。 最后，一些思考。关于整套架构，其中的工具设计是比较容易做到的（除了大模型部分的算法部分），但是如何为MCP的落地提供应用场景就成了难事，巨大的token耗费成本极大的限制了应用场景，如何落地呢？","tags":["MCP","AI"],"categories":["technology","AI"]},{"title":"C++中的STL标准库","path":"/2025/05/05/STL_r1_output/","content":"C++ STL标准库源码解析与设计思想 最近在学习侯捷老师关于STL源码的解析（以GNU 2.9实现为例），本文记录核心知识点与设计哲学 一、STL六大组件全景图 STL主要分成了六个部分，其中包括容器，迭代器，分配器，算法，仿函数以及一些适配器。在学习STL之前应该首先对泛型编程以及对象编程有清晰的认识，对象编程倾向于设计一个Class类，实现一个具备自身数据和自身功能的一个整体，并提供复用的接口。泛型编程广泛的应用了模板的相关知识，通过模板参数T或者Foo来分别设计函数和数据的具体实现。对于不同版本的库文件，各家的编写方式也不尽相同，例如VC库文件和GNU库文件。同时由于标准规范存在，代码能够有较好的可移植性 STL（Standard Template Library）由以下六大核心组件构成： 容器（Containers）：管理数据的集合（如vector、list、map） 迭代器（Iterators）：泛化的指针，提供容器元素的访问接口 分配器（Allocators）：内存管理的底层实现（如std::alloc） 算法（Algorithms）：通用算法（如sort、find） 仿函数（Functors）：行为类似函数的对象（如lessT） 适配器（Adapters）：组件接口转换器（如stack、queue） 容器主要分成关联式和序列式容器，对于序列是容器能够支持一些排序等操作。而关联式容器支持快速的查找工作在学习容器部分的时候应该格外关注他们的底层实现，这关乎于不同算法的实现效率，另外以及内存占用情况，以及容器内部定义的可以调用的一些基本函数。注意容器内部定义的一些函数和全局定义的函数的区别，例如find、sort等函数。 对于vector是使用三个指针进行控制，头部指针，内容尾部指针，以及内存尾部指针。vecotr的迭代器，不必设计成一个类。 deque是使用分段连续实现前后端均可以扩充对于deque的迭代器，使用四个属性进行控制。cur.first.last,node,deque的底层索引表也是通过vector来写的，进行二倍增长 stack 和queue的底层都是采用qeque来实现的。两者都不允许进行遍历，那么就是不提供迭代器 不同的容器其本身由于包括了多个迭代器，其指针等其本身就占用多个字节，例如deque占用40个字节，其内容要根据动态分配分配内存。需要注意的是，deque查找等动作，都需要首先检查指针是否已经在边界，进行索引表的步进，然后进行具体查找。 红黑树和散列表是关联式容器实现的关键。红黑树是一种平衡的二元搜寻树。不应该使用迭代器改变红黑树的元素值。因为红黑树内部有一定的排序规则。红黑树有多个参数，其中包括key，value，KeyOfValue,compare,alloc。红黑树内部有两种插入方式，包括insert_equal和insert_unique 二、容器实现深度解析2.1 序列式容器 容器 底层结构 关键特性 vector 动态数组 三指针控制：start, finish, end_of_storage deque 分段连续+索引表 迭代器含cur, first, last, node指针 list 双向链表 节点含prev, next, data指针 vector内存增长示例： vectorint v;v.push_back(1); // 容量1v.push_back(2); // 容量2（翻倍）v.push_back(3); // 容量4（再次翻倍） 2.2 关联式容器graph TD A[关联式容器] -- B[红黑树实现] A -- C[哈希表实现] B -- set/multiset B -- map/multimap C -- unordered_set C -- unordered_map 红黑树关键特性： 每个节点非红即黑 根节点必须为黑 红色节点的子节点必须为黑 任意节点到叶子的路径包含相同数量黑节点 三、迭代器设计哲学3.1 迭代器核心接口templateclass Tstruct iterator typedef T value_type; typedef ptrdiff_t difference_type; typedef T* pointer; typedef T reference; typedef random_access_iterator_tag iterator_category;; 迭代器是一种泛化的指针。要注意迭代器内部操作符重载的写法，例如++操作符、*、等重载的具体实现。另外以及iterator中的设计原则，iterator必须提供五种Type。这些参数在 iterator 头文件中通过 iterator 结构体定义，并在自定义迭代器时需要用到。这五个参数按顺序分别是： value_type: 迭代器所指向的元素的类型。通过迭代器，我们可以访问到容器中存储的元素，而 value_type 就定义了这些元素的类型。例如，对于 std::vectorint::iterator，其 value_type 就是 int。 difference_type: 用于表示迭代器之间距离的类型。通常情况下，这个类型是带符号的整型，例如 std::ptrdiff_t。它可以用来计算两个迭代器之间的元素个数。例如，如果你有两个指向 std::vectorint 中不同元素的迭代器 it1 和 it2，那么 it2 - it1 的结果类型就是 difference_type。 pointer: 指向 value_type 的指针类型。通常情况下，它是 value_type*。这个类型在某些迭代器（例如原始指针迭代器）中直接使用。 reference: 指向 value_type 的引用类型。通常情况下，它是 value_type。当我们通过解引用迭代器（使用 * 运算符）访问元素时，得到的就是一个 reference 类型的对象。 iterator_category: 描述迭代器所支持的操作的标签类型。STL 定义了五种主要的迭代器类别，它们之间存在着功能上的包含关系： std::input_iterator_tag: 只支持单向读取操作，即只能使用 *it 读取元素，并使用 ++it 使迭代器前进。输入迭代器通常用于单次遍历的输入流。 std::output_iterator_tag: 只支持单向写入操作，即只能使用 *it = value 写入元素，并使用 ++it 使迭代器前进。输出迭代器通常用于单次遍历的输出流。 std::forward_iterator_tag: 支持输入迭代器的所有操作，并且可以多次遍历容器中的元素。这意味着你可以保存一个前向迭代器的副本，并在之后再次使用它从相同的位置开始遍历。 std::bidirectional_iterator_tag: 支持前向迭代器的所有操作，并且可以双向移动，即可以使用 --it 使迭代器后退。std::list、std::set 和 std::map 等容器的迭代器通常是双向迭代器。 std::random_access_iterator_tag: 支持双向迭代器的所有操作，并且提供随机访问的能力。这意味着你可以像操作数组指针一样，使用 it + n、it - n、it[n] 以及比较运算符（、、=、=）在常数时间内访问任意位置的元素。std::vector、std::deque 和数组的迭代器都是随机访问迭代器。 3.2 迭代器分类与能力 迭代器类型 支持操作 典型容器 随机访问迭代器 ++, --, +n, -n, [] vector, deque 双向迭代器 ++, -- list, setmap 前向迭代器 ++ forward_list 输入输出迭代器 单次遍历 istream, ostream 对于STL的容器等部件实际上是一个类模板，而算法实际上是一个函数的模板。另外函数一般会有多个重载方式，通过参数类型、数量等来区分。算法只会接收迭代器，看不到容器，所以它所需要的所有信息必须从迭代器中获得，而迭代器必须能够回答算法的所有问题。 四、算法与仿函数协作机制4.1 算法模板示例template class InputIterator, class TInputIterator find(InputIterator first, InputIterator last, const T value) while (first != last *first != value) ++first; return first; 仿函数（functors），仿函数是通过设计一种类通过重载小括号来近似实现函数的功能，是为算法进行服务的，分别有算术类，逻辑运算类，以及相对关系类。例如针对自定义的一种类，来定义一种独特的排序方式。 再STL中规定了每个Adaptor都应该挑选一个适配者继承，因为在函数应用到仿函数的时候很有可能会询问仿函数一些基础参数问题，因此需要像迭代器那样，给它一个继承的身份。 4.2 仿函数与适配器算术仿函数示例： template class Tstruct plus : binary_functionT, T, T T operator()(const T x, const T y) const return x + y; ; 适配器应用场景： // 将普通函数转换为仿函数ptr_fun(my_function); // 绑定参数bind2nd(lessint(), 40); 五、内存管理：分配器实现5.1 GNU 2.9 allocator设计class __malloc_alloc_template // 一级分配器 static void* allocate(size_t n) /* 直接调用malloc */ ;class __default_alloc_template // 二级分配器 enum __ALIGN = 8 ; static size_t ROUND_UP(size_t bytes) return (((bytes) + __ALIGN-1) ~(__ALIGN - 1)); ; 5.2 内存池工作流程 维护16个自由链表（$8-128$字节） 内存不足时向系统申请大块内存 碎片回收通过自由链表管理 六、STL设计精髓总结 泛型编程思想：通过模板实现算法与数据类型的解耦 低耦合高内聚：容器、迭代器、算法通过标准接口协作 效率优先：通过内存池、红黑树等结构优化性能 可扩展性：允许用户自定义分配器、仿函数等组件","tags":["C++","STL"],"categories":["technology","编程基础"]},{"title":"MiniAgi源码阅读笔记","path":"/2025/05/03/MiniAgi 源码阅读/","content":"spinner.py在这个文件中定义了一个光标效果 def spinner_task(self): while self.busy: sys.stdout.write(next(self.spinner_generator)) sys.stdout.flush() #强制立即刷新 time.sleep(self.delay) # 定义帧率 sys.stdout.write(\\b) # 光标回退， 实现覆盖字符 sys.stdout.flush() def __enter__(self): # 启动动画线程 self.busy = True threading.Thread(target=self.spinner_task).start()def __exit__(self, exception, value, tb): #停止动画 self.busy = False time.sleep(self.delay) if exception is not None: return False return True exceptions.py这个文件主要是用来捕获模型输出中的异常，例如格式不对，缺字段，非json等。然后将这个异常抛回给上层进行处理。继承了python内置的Exception类 class InvalidLLMResponseError(Exception): Exception raised when the LLM response cant be parsed. Attributes: None commond.py在这个文件中规定了不同命令的思考链 库文件说明 import subprocess 作用：用于创建子进程，执行外部命令或脚本，并获取其输入输出结果。 典型用途： 调用系统命令（如 ls, ping, gcc, python 等）； 执行外部程序或脚本（如 shell 脚本、批处理）； 控制输入输出重定向。 from io import StringIO 作用：提供一个类 StringIO，它创建一个内存中的字符串缓冲区，可像文件一样读写。 典型用途： 在不涉及实际文件的情况下模拟文件操作； 用于测试代码中涉及文件读写的部分； 捕捉输出文本（通常与 redirect_stdout 配合使用）。 from contextlib import redirect_stdout 作用：上下文管理器，用于临时将标准输出重定向到指定对象（比如 StringIO）。 典型用途： 捕捉 print() 语句的输出； 在测试或调试中查看函数内部输出； 搭配 StringIO 捕获控制台输出为字符串处理。 from duckduckgo_search import DDGS 作用：导入 DuckDuckGo Search 的 Python 接口 DDGS 类，用于调用 DuckDuckGo 的搜索功能。 典型用途： 用代码直接进行 DuckDuckGo 搜索并获取结果； 抓取网页搜索摘要、链接、图像等； 用于构建搜索引擎接口或信息爬取工具。 class类说明在execute_commond中首先将命令进行分发 if command == memorize_thoughts: 调用 Commands.memorize_thoughts(arg)elif command == execute_python: 调用 Commands.execute_python(arg)...else: 返回 Unknown commandcommond如果过程中出现异常，返回异常信息 然后分别定义各个函数内容 miniagi.pyprompt设计关于prompt的具体设计原则，会写另外一篇博客进行说明在MiniAgi项目中prompt的设计是这样的设计中融入了思维链、少样本提示，并且强调了自我一致性。同时，在prompt的设计中加入了自我批评CRITIC_PROMPT，以及记忆重整HISTORY_SUMMARY_HINT等。具体如下 角色设定（Role Conditioning）fYou are an autonomous agent running on operating_system. 明确模型的“身份”：你是运行在某操作系统上的自主代理智能体；通过设定操作系统，有利于后续与 Shell 命令、文件路径等交互时保持一致（如 Linux vs Windows）。 目标导向任务（Objective Conditioning） OBJECTIVE: objective (e.g. Find a recipe for chocolate chip cookies) 为当前任务设定一个清晰目标，使模型行为聚焦； 模仿人类代理行为，把目标当成“长期任务”，以实现规划式思维。 历史上下文注入（Context）Previous steps: context 引入以往已执行的动作观察结果，作为“记忆”或状态追踪； 支持多步推理和上下文保持，是链式思维（Chain-of-Thought）的关键。 明确命令集（命令语言接口设计） 定义一个有限状态机风格的 API 接口，明确智能体能执行的动作范围； 强制每一步只能执行一个命令，避免无控制的自然语言混乱； 命令覆盖典型任务：记忆、推理、代码执行、数据处理、与用户对话、终止。 明确格式约束（动作语法模板） r[YOUR_REASONING]/rc[COMMAND]/c[ARGUMENT] r：模型的推理或动机说明； c：结构化命令名称（对应预定义命令集）； [ARGUMENT]：命令参数； 该格式是构化动作标注，利于解析、监督、记录、回放等； 防止输出中出现自然语言噪声或模糊行为。 行为限制与安全提示 不要重复命令 不要链式多个命令 Python 要以 print 输出结尾 process_data ingest_data 只能处理单文件 不搜索 GPT 已知知识 保证行为唯一性、可解释性、可控性； 限制模型可能的幻觉或冗余行为； 强化对命令执行前提条件的检查（如输出格式约束）。 示例示范（Few-shot Prompting） rThink about skills and interests.../rcmemorize_thoughts/crSearch for websites.../rcweb_search/c 提供多个风格统一、结构良好的行为范例； 用作 few-shot learning 的提示模板，让模型模仿人类代理行为； 示例覆盖了多种命令使用方式、输入格式、常见应用。 MiniAgi类class MiniAGI: 表示一个自主智能体（Agent）类。 属性（Attributes）定义了 agent 的各种组件和运行状态。 def __init__( # 参数初始化列表 self, agent_model: str, summarizer_model: str, objective: str, max_context_size: int, max_memory_item_size: int, debug: bool = False ): 构造函数：创建 MiniAGI 实例，初始化内部模型和参数。 # 初始化用于生成行为的主模型 self.agent = ThinkGPT( model_name=agent_model, request_timeout=600, verbose=False ) # 初始化用于生成摘要的模型 self.summarizer = ThinkGPT( model_name=summarizer_model, request_timeout=600, verbose=False ) # 保存目标、内存限制、是否调试等配置参数 self.objective = objective self.max_context_size = max_context_size self.max_memory_item_size = max_memory_item_size self.debug = debug # 以下是状态相关的字符串属性，初始设为空 self.summarized_history = self.criticism = self.thought = self.proposed_command = self.proposed_arg = # 使用 tiktoken 获取模型的 tokenizer 编码器 self.encoding = tiktoken.encoding_for_model(self.agent.model_name) def __update_memory(self, action: str, observation: str, update_summary: bool = True): 内部方法：根据行动和观察结果更新记忆。 如果 observation 太长，会先进行摘要处理。 # 如果 observation 超过允许大小，进行摘要 if len(self.encoding.encode(observation)) self.max_memory_item_size: observation = self.summarizer.chunked_summarize( observation, self.max_memory_item_size, instruction_hint=OBSERVATION_SUMMARY_HINT ) # 构造新记忆格式 if memorize_thoughts in action: new_memory = fACTION: memorize_thoughts THOUGHTS: observation else: new_memory = fACTION: action RESULT: observation # 如果需要更新摘要，调用 summarizer 的 summarize 方法 if update_summary: self.summarized_history = self.summarizer.summarize( fCurrent summary: self.summarized_history Add to summary: new_memory, self.max_memory_item_size, instruction_hint=HISTORY_SUMMARY_HINT ) # 将新记忆交由 agent 存储 self.agent.memorize(new_memory) def __get_context(self) - str: 内部方法：构造 agent 当前的上下文字符串。 上下文包括摘要、最近的行为和批评。 summary_len = len(self.encoding.encode(self.summarized_history)) criticism_len = len(self.encoding.encode(self.criticism)) if self.criticism else 0 # 从 agent 中获取最多能容纳的最近记忆片段 action_buffer = .join( self.agent.remember( limit=32, sort_by_order=True, max_tokens=self.max_context_size - summary_len - criticism_len ) ) # 构建最终上下文字符串 return fSUMMARY self.summarized_history PREV ACTIONS: action_buffer self.criticism def criticize(self) - str: 调用模型对 agent 最近的行为进行批评。 context = self.__get_context() self.criticism = self.agent.predict( prompt=CRITIC_PROMPT.format(context=context, objective=self.objective) ) return self.criticism def think(self): 调用模型进行推理，生成下一步操作计划。 context = self.__get_context() if self.debug: print(context) # 基于 prompt 和上下文生成原始响应 response_text = self.agent.predict( prompt=PROMPT.format(context=context, objective=self.objective) ) if self.debug: print(fRAW RESPONSE: response_text) # 使用正则表达式提取 r思考/rc命令/carg PATTERN = r^r(.*?)/rc(.*?)/c *(.*)$ try: match = re.search(PATTERN, response_text, flags=re.DOTALL | re.MULTILINE) _thought = match[1] _command = match[2] _arg = match[3] except Exception as exc: raise InvalidLLMResponseError from exc _arg = _arg.replace(```, ) # 去除可能的 markdown 格式符号 # 保存模型推理结果 self.thought = _thought self.proposed_command = _command self.proposed_arg = _arg def read_mind(self) - tuple: 获取 agent 最近的思考、命令和参数。 _arg = self.proposed_arg.replace( , \\ ) if len(self.proposed_arg) 64\\ else fself.proposed_arg[:64]....replace( , \\ ) return (self.thought, self.proposed_command, _arg) @staticmethod def __get_url_or_file(_arg: str) - str: 根据参数读取 URL 或本地文件内容。 if _arg.startswith(http://) or _arg.startswith(https://): with urlopen(_arg) as response: html = response.read() data = BeautifulSoup(html, features=lxml).get_text() else: with open(_arg, r) as file: data = file.read() return data def __process_data(self, _arg: str) - str: 对 URL 或文件进行处理，格式为：prompt|url或文件路径 args = _arg.split(|) if len(args) == 1: return Invalid command. The correct format is: prompt|file or url if len(args) 2: return Cannot process multiple input files or URLs. Process one at a time. prompt, __arg = args try: input_data = self.__get_url_or_file(__arg) except urllib.error.URLError as e: return fError: str(e) except OSError as e: return fError: str(e) if len(self.encoding.encode(input_data)) self.max_context_size: input_data = self.summarizer.chunked_summarize( input_data, self.max_context_size, instruction_hint=OBSERVATION_SUMMARY_HINT ) return self.agent.predict( prompt=fRETRIEVAL_PROMPT prompt INPUT DATA: input_data ) def __ingest_data(self, _arg: str) - str: 只读取 URL 或文件内容（不进行指令解析），返回文本或摘要。 try: data = self.__get_url_or_file(_arg) except urllib.error.URLError as e: return fError: str(e) except OSError as e: return fError: str(e) if len(self.encoding.encode(data)) self.max_memory_item_size: data = self.summarizer.chunked_summarize( data","tags":["MCP","AI","MiniAGI"],"categories":["technology","AI"]},{"title":"Prompt设计（2）","path":"/2025/05/02/prompt设计(2)/","content":"零样本提示提示 将文本分类成中性、负面或正面文本：我认为这次假期还可以情感： 输出 中性 指令调整已被证明可以改善零样本学习Wei等人（2022）。指令调整本质上是在通过指令描述的数据集上微调模型的概念。此外，RLHF（来自人类反馈的强化学习）已被采用以扩展指令调整，其中模型被调整以更好地适应人类偏好。这一最新发展推动了像ChatGPT这样的模型。我们将在接下来的章节中讨论所有这些方法和方法。 少样本提示即在prompt中给出一个实例，来帮助模型进行理解 这太棒了！// Negative这太糟糕了！// Positive哇，那部电影太棒了！// Positive多么可怕的节目！// Negative COT 关于零样本COT：即在后面加入”让我们逐步思考” 自动思维链（Auto-Cot），即利用 LLMs “让我们一步一步地思考” 提示来生成一个接一个的推理链。这种自动过程仍然可能在生成的链中出现错误。为了减轻错误的影响，演示的多样性很重要。 一般首先要先将任务分解成为不同的、连续的步骤 使用XML来构建清晰的交接 对每个任务要求构建清晰的目标 要根据模型的表现进行Prompt的迭代 自我一致性自我一致性旨在“替换链式思维提示中使用的天真贪婪解码方法”。其想法是通过少样本 CoT 采样多个不同的推理路径，并使用生成结果选择最一致的答案。这有助于提高 CoT 提示在涉及算术和常识推理的任务中的性能。其实本质上是设计相同范式的问题与解答，帮助模型建立一致性 Q：林中有15棵树。林业工人今天将在林中种树。完成后，将有21棵树。林业工人今天种了多少棵树？ A：我们从15棵树开始。后来我们有21棵树。差异必须是他们种树的数量。因此，他们必须种了21-15 6棵树。答案是6。 Q：停车场有3辆汽车，又来了2辆汽车，停车场有多少辆汽车？ A：停车场已经有3辆汽车。又来了2辆。现在有3 + 2 5辆汽车。答案是5。 …. 当我6岁时，我的妹妹是我的一半年龄。现在我70岁了，我的妹妹多大？ TOTTOT本质上是将思考过程建模成一个多步，分支的思考树。每个节点都是一个思考过程。可以通过合理设计Prompt来实现TOT的结构。目前较为流行的TOT结构包括基于深度搜索、广度搜索等策略的。另一种基于强化学习训练出的TOT训练器。假设三位不同的专家来回答这个问题。所有专家都写下他们思考这个问题的第一个步骤，然后与大家分享。然后，所有专家都写下他们思考的下一个步骤并分享。以此类推，直到所有专家写完他们思考的所有步骤。只要大家发现有专家的步骤出错了，就让这位专家离开。请问...如何将TOT应用于模型的建构中是下一步要了解的方向自动推理并使用工具（ART）是在2023年提出的一个新的框架，这个框架使用冻结的LLM来自动生成包含中间推理步骤的程序 在接到新的任务的时候，从任务库中选择多部推理和使用工具的示范 在测试中，调用外部工具，先暂停生成，将工具整合后继续生成 就目前所了解到的，基本的Prompt设计主要还是基于普通的设计，或加入一些思维链提示链等。另外还有一部分为了提高泛化性能，使用了LLM来生成prompt进而生成答案，","tags":["AI","Prompt"],"categories":["technology","AI"]},{"title":"Prompt设计（1）","path":"/2025/05/01/prompt设计/","content":"prompt是用户输入给LLM的文本信息，是用来明确告知模型想要解决的问题，或者完成的任务。市面上已经有了一些关于prompt扩写、完善的工具，例如百炼。另外对prompt的设计实际上是一个迭代过程，可以通过openai等平台的playground进行大量的试验。在prompt中避免说不要做什么，而是应该要做什么。要非常具体地说明你希望模型执行的指令和任务。提示越具描述性和详细，结果越好。特别是当你对生成的结果或风格有要求时，这一点尤为重要。不存在什么特定的词元（tokens）或关键词（tokens）能确定带来更好的结果。更重要的是要有一个具有良好格式和描述性的提示词。事实上，在提示中提供示例对于获得特定格式的期望输出非常有效。 在设计提示时，还应注意提示的长度，因为提示的长度是有限制的。想一想你需要多么的具体和详细。包含太多不必要的细节不一定是好的方法。这些细节应该是相关的，并有助于完成手头的任务。这是你需要进行大量实验的事情。我们鼓励大量实验和迭代，以优化适用于你应用的提示。 基础结构较为通用的prompt结构如下： 输出：应该明确指出模型的输出内容的具体形式，确保LLM的输出能够满足后续的需求。 受众：需要明确指出面向的读者群体。以及适用的平台，在输出代码时可以有好的兼容性。 优化prompt 在prompt中提供期望的输出样例，可以让LLM模仿我们所要求的规范、格式、概念等要求进行输出。同时也能够使输出更加的统一。从而稳定模型表现。背景你很擅长编写小红书种草笔记，喜欢增加丰富的emoji元素。目的请生成一篇小红书种草笔记，推广强森吹风机。吹风机的优点是：体积小、高颜值、风力大、干得快、智能控温不伤发。受众喜欢追求时尚的年轻人，尤其是年轻女性输出小红书文章格式，充满emoji元素，简洁但内容充实语气与风格（提供了几种示例）我亲测过+n种好物+谁适合谁受益 这个秘诀让你的话语超有信服力！ 比如：亲自尝试了很多美白神器，终于挖到宝！仅俩月，肌肤变得嫩滑透亮，自我感觉飘飘欲仙~ 此法特为想大晒体验的小伙伴们量身定制，还能精准安利，助人避坑！难题出没+揭秘原因+终极解药 这公式助你条理清晰地分享，内容价值爆棚！ 案例：渴望秀发如丝？揭秘时刻来啦！原来我一直遗漏关键一步，直到遇见它！换用这款洗发水，秀发显著改善，光泽get！ 此法逻辑严密，不仅分享秘籍，还引导读者找到问题破解之道。独到见解+深度剖析+巧妙推荐 这公式帮你自然流露心声，还能温馨种草！ 示例：我觉得每个女孩都该有份挚爱，生活因此而精彩。手帐成了我的小确幸，每当提笔，幸福指数飙升！ 它助你畅所欲言，同时不经意间传递心头好，双赢策略！亲身经历+成果展示 这公式让你的情感表达鲜活又感人！ 场景：回想起夏夜海边的蚊灾，满身红包的绝望，直到遇见救星！现在，光滑肌肤让我裙摆飞扬，自信回归！ 它让你的故事活灵活现，分享喜悦与感恩之情，触动人心！ 而对于复杂任务，为LLM设定一个任务完成的步骤是十分重要的。（但如何设计一个泛化能力更强的任务步骤） 使用不常见的分隔符号来区分内容区域的界限标识。在构建复杂的 Prompt 时，采用特定的分隔符来界定不同内容单元是极为关键的，这一做法显著增强了 LLM 对 Prompt 正确解析的能力。随着任务复杂度的增加，合理利用分隔符越能提升 LLM 的表现。分隔符的选择应着眼于那些在自然语言文本中罕见的、独特的字符组合，例如：###、===、等。这些特殊符号序列并无固定规则，关键在于其辨识度高，确保模型能够明确区分这些符号是作为内容区域的界限标识，而非文本中的普通标点或语法组成部分。 思维链和提示链我们可以通过要求输出整个的推理过程进行思维链，另外还有思维树，Boosting of thought等。 另：文生图prompt指南提示词 主体（主体描述）+ 场景（场景描述）+ 风格（定义风格）+ 镜头语言 + 氛围词 + 细节修饰 主体描述：确定主体清晰地描述图像中的主体，包括其特征、动作等。例如，“一个可爱的10岁中国小女孩，穿着红色衣服”。场景描述：场景描述是对主体所处环境特征细节的描述，可通过形容词或短句列举。定义风格：定义风格是明确地描述图像所应具有的特定艺术风格、表现手法或视觉特征。例如，“水彩风格”、“漫画风格”常见风格化详见下方提示词词典。镜头语言：镜头语言包含景别、视角等，常见镜头语言详见提示词词典。氛围词：氛围词是对预期画面氛围的描述，例如“梦幻”、“孤独”、“宏伟”，常见氛围词详见提示词词典。细节修饰：细节修饰是对画面进一步的精细化和优化，以增强图像的细节表现力、丰富度和美感。例如“光源的位置”、“道具搭配”、“环境细节”，“高分辨率”等。 另：文生视频prompt提示词 主体 + 场景 + 运动 主体：主体是视频内容的主要表现对象，可以是人、动物、植物、物品或非物理真实存在的想象物体。场景：场景是主体所处的环境，包含背景、前景，可以是物理存在的真实空间或想象出来的虚构场景。运动：运动包含主体的具体运动和非主体的运动状态，可以是静止、小幅度运动、大幅度运动、局部运动或整体动势。运镜描述： 运镜描述 + 主体（主体描述）+ 场景（场景描述）+ 运动（运动描述）+ 镜头语言 + 氛围词 + 风格化","tags":["AI","Prompt"],"categories":["technology","AI"]},{"title":"agent学习","path":"/2025/04/28/agent/","content":"Agent工作逻辑以AutoGPT为例子，记录一下Agent的工作逻辑 1. 什么是像 AutoGPT 这样的 Agent 框架？它们是高级自动化系统，基本逻辑是： 不是简单「单轮提问-回答」 而是根据任务自己制定计划，分步行动，多轮决策，直到任务完成。普通的大模型是通过一轮轮的问答来实现最终的任务的但是创建一个合适的Agent可以实现自己想目标，自己想策略，自己执行，自己检查。 2. AutoGPT类 Agent 的运行框架核心步骤 它们基本遵循下面这个 循环逻辑： (1) 接收目标用户给一个高层目标，比如：- 写一份关于人工智能历史的详细报告，并生成成 Word 文档。 (2) 自主规划Agent自己思考出**计划 (Plan)**，比如：- 查询人工智能历史资料- 按时间线整理事件- 写成条理清晰的段落- 格式化成Word文档 (3) 行动(Action)Agent根据计划，开始一步步执行：- 调用搜索引擎 API- 分析网页内容- 写文档- 保存文件每一步都是自己调用工具、处理结果！(4) 观察(Observation)每次行动后，会自己**检查行动结果**：- 成功了？继续下一步- 失败了？重新想方法- 信息不够？再去找资料(5) 决策(Thinking)根据观察结果，决定：- 修改计划- 补充信息- 结束任务**这就是所谓的：自主决策、自主行动循环。** 3. 它们内部通常包括哪些模块？ 模块 功能 Memory（记忆） 记录任务过程，避免忘记之前做过什么 Planning（规划） 自动分解任务成小步骤 Tools（工具链） 能用的外部接口（如Web搜索、文件系统、数据库等） Reasoning（推理） 分析当前状况，决定下一步怎么做 Critic（自我评估） 检查结果，判断是否需要修正 4. 模型的参数设置 Temparature简单来说，temperature 的参数值越小，模型就会返回越确定的一个结果。如果调高该参数值，大语言模型可能会返回更随机的结果，也就是说这可能会带来更多样化或更具创造性的产出。（调小temperature）实质上，你是在增加其他可能的 token 的权重。在实际应用方面，对于质量保障（QA）等任务，我们可以设置更低的 temperature 值，以促使模型基于事实返回更真实和简洁的结果。 对于诗歌生成或其他创造性任务，适度地调高 temperature 参数值可能会更好。 top_p 同样，使用 top_p（与 temperature 一起称为核采样（nucleus sampling）的技术），可以用来控制模型返回结果的确定性。如果你需要准确和事实的答案，就把参数值调低。如果你在寻找更多样化的响应，可以将其值调高点。 使用Top P意味着只有词元集合（tokens）中包含top_p概率质量的才会被考虑用于响应，因此较低的top_p值会选择最有信心的响应。这意味着较高的top_p值将使模型考虑更多可能的词语，包括不太可能的词语，从而导致更多样化的输出。 一般建议是改变 Temperature 和 Top P 其中一个参数就行，不用两个都调整。 MAX Length您可以通过调整 max length 来控制大模型生成的 token 数。指定 Max Length 有助于防止大模型生成冗长或不相关的响应并控制成本。 stop sequence这同样是一种控制模型响应长度和结构的另外一种方法 Frequency Penalty是对下一个生成的token进行惩罚，控制重复数量。 Presence Penaltypresence penalty 也是对重复的 token 施加惩罚，但与 frequency penalty 不同的是，惩罚对于所有重复 token 都是相同的。出现两次的 token 和出现 10 次的 token 会受到相同的惩罚。 此设置可防止模型在响应中过于频繁地生成重复的词。 如果您希望模型生成多样化或创造性的文本，您可以设置更高的 presence penalty，如果您希望模型生成更专注的内容，您可以设置更低的 presence penalty。 5. 具体以 AutoGPT 举例（运行时流程）1. 用户输入：我要了解马斯克的一生2. AutoGPT: - 想一想：需要做哪些事？ - 计划出步骤： ① 搜索马斯克的生平资料 ② 按时间整理重要事件 ③ 生成简要介绍文档3. AutoGPT: - 开始第1步：调用搜索API - 得到网页结果4. AutoGPT: - 第2步：分析网页 - 挑出马斯克生平重要事件5. AutoGPT: - 第3步：组织成文档 - 保存成文本文件6. AutoGPT: - 任务完成，提示用户 这一整套都是 Agent 自己思考-执行的！ 一些典型Agent框架 项目 特点 地址 AutoGPT 早期爆火，超全面，但偏重实验 https://github.com/Torantulino/Auto-GPT BabyAGI 极简Agent，只要几百行代码，便于学习 https://github.com/yoheinakajima/babyagi CrewAI 多Agent协作系统（模拟一个小团队） https://github.com/joaomdmoura/crewAI LangChain Agent LangChain框架内置的Agent模块，商业项目多用 https://docs.langchain.com/docs/modules/","tags":["AI","agent"],"categories":["technology","AI"]},{"title":"先验概率与后验概率","path":"/2025/03/28/先验概率与后验概率/","content":"贝叶斯公式P(A|B) P(AB)P(B) {P(AB)P(A)}*P(A)P(B) 先验概率与后验概率的概念理解在区分先验概率和后验概率的时候，首先的任务是确定结果与因素。确定之后就像概率论所学，由因推果为先验概率，由果推因为后验概率。在上面的公式中，假设B为结果A为因素，那么我们在上式就完成了先验概率到后验概率的转换。 与粒子滤波的联系在粒子滤波中我们将位姿的估计转换为了求解一个联合后验概率，为了求解这个联合后验概率，通过使用CK方程将它拆解成了各个时刻的状态乘积，并求解了在已知控制输入与传感器观测值的状态先验概率，即为预测。接下来利用下一个时刻得到的传感器输入融合这个时刻的位姿和环境特征来修正先验概率，即为更新。","tags":["SLAM","概率"],"categories":["technology","SLAM"]},{"title":"视觉问题中的手眼标定算法","path":"/2025/03/20/标定/","content":"手眼标定分为两种情况，眼在手外与眼在手上手眼标定的目标是获得相机坐标系到机器人的基坐标系变换矩阵 对于基矩阵到摄像头矩阵，首先选取标定板的三个基向量拼接成为R矩阵。然后以标定板原点的坐标为t。最后为了防止标定板的xy向量不正交，最好在xz方向重新叉乘得到新的y向量，以此提升精度在选取标定板基向量时选取较远的起点与中点较为准确 将标定板放置在机械臂的末端法兰上，而这个矩阵是较为难以估计的，想办法消除左乘基坐标到摄像头矩阵的逆，左乘法兰到基坐标的矩阵的逆多次照相并联立方程","tags":["SLAM","标定"],"categories":["technology","SLAM"]},{"title":"台球训练心得","path":"/2024/07/06/台球训练/","content":"入位我之前常用的入位方式是找到那根瞄准线，然后用杆延申向后拉，同时把身体趴下去。同时要注意双脚的平行。 现在采用的方式是先用右脚踩在那根瞄准线上，然后俯身，注意无所谓两只脚是否平行。俯身时夹紧大臂，小拇指完全放松，虎口靠住台球杆。 运杆 首先选中白球击球点，确定走位方式。我现在击打球时居然会偏右{% emoji blobcat 0_0 。这实在是令人难以接受，打了这么多年台球居然现在打点不纯，不过今天晚上的训练自认为已经纠正过来了。 在瞄准白球击球点的时候应该向左偏移一些。 %} 击打这个地方没什么太大改变，只需要注意运杆和击打的时候幅度不要变化太大，避免身体的剧烈起伏。同时，要注意在末尾的时候要提高杆速，这样才能够打出效果，另外，我现在的杆打杆非常硬的，杆的支撑性很强，皮头也偏硬，击打反也很明显，这都是要求我在击打中缓慢去感知的。 击打后不要急着起身。其实根本在于动作的连贯性，如果动作很连贯，那么应该是有惯性存在的，想快速起身也做不到。 总的来说现在的标准流程应该是 踩中那根瞄准线 注意后手的稳定性 调整白球击打点 运杆，击打","tags":["台球"],"categories":["life","运动"]},{"title":"C++阅读笔记","path":"/2024/04/05/c++/","content":"左值引用 左值引用是一种绑定，在使用时必须进行初始化 引用并非一种对象，而只是为一个已经存在的变量所起的另一种名字（我们把具有存储空间的叫做对象）。因此引用无法再绑定到其他对象。 引用类型的初始值必须是一个对象。不应该是一个值。除了常量引用。 指针 指针本身也是一个对象。与引用类似，也实现了对其他对象的间接访问。 指针一定要初始化 指针类型需要和它所指向的对象严格匹配。但有两种例外：指向常量的指针允许指向一个非常量对象。 指针的值应该为以下四种状态之一 指向一个对象 指向紧邻对象的下一个位置 空指针，即没有指向任何对象 无效指针，即除上述情况的其他值。访问无效指针将发生错误。 某些符号具有多重含义 int i = 42; int r = i; //紧随类型名出现，因此是声明的一部分r是一个引用int *p; //紧随类型名出现，因此是声明的一部分，p是一个指针p = i; //出现在表达式中，是一个取址*p = i; //*出现在表达式中，是一个解引用int r2 = *p; //是声明的一部分，*是解引用 生成空指针的方法 int p1 = nullptr;//int*p1 = 0;可以转换成任意其它类型的指针 int *p2 = 0; int *p3 = NULL; void* 指针是一种特殊的指针类型，可以存放任意对象的地址。 如何检查指针是否指向了一个合法的对象呢？ 检查是否为NULLif (p != NULL) // p 可能是一个有效指针（但不保证） 确保指针指向的是已分配的内存p = malloc(sizeof(int));p = new int;if (p) // new 在分配失败时通常会抛出异常，除非使用 `nothrow` 检查指针是否为悬空指针int *p = (int*)malloc(sizeof(int));free(p); // p 现在是悬空指针if (p) printf(p 不是 NULL，但仍然是无效的！ );//处理方法free(p);p = NULL;//智能指针std::unique_ptrint p = std::make_uniqueint(10); // 自动管理内存 const int i = 42;\tauto j = i;\tconst auto k = i;\tauto *p = i;\tconst auto j2 = i,k2 = i;\tcoutj k *p j2 k2; //42 42 42 42 42 auto与decltype指示符 auto是自动配置声明变量的类型 auto一般会忽略掉顶层const，而底层const会被保留 string 注意在字符串相加时，必须确保“+”两侧至少有一个string类型。，不能直接使用字面值相加。 string中包含了相当多的库函数，使用时可以问问gpt 迭代器 容器的访问有两种方式//下标访问，这里有一行比较巧妙地代码vectorunsigned scores(10,0);unsigned grade;while (cingrade) if(grade=100) ++scores[grade/10]; 但是需要注意的是，我们无法通过下标来实现添加元素。，应该实验push_back; 另外值得注意的是，通过下标访问容器中不存在地元素会导致严重的错误，即缓冲区溢出。 另外一种访问方式是迭代器方法 string s(my name); auto it = s.begin(); *it = toupper(*it); 在这种方式下要注意迭代器与指针的相似性与差异性 数组 数组是一种类似vector的数据结构，但是数组的大小不变，不能够随时向数组内添加元素。 在数组初始化的时候要注意字符数组的特殊，字符串字面值的结尾处还有一个空白字符。 对于复杂数组的理解（类型修饰符从右向左依次绑定）int *ptrs[10];//10个整型变量数组指针int (*Parray)[10] = arr;//指向十个整型变量的数组的指针int (arrRef)[10] = arr;//引用十个整型变量数组int *(arry)[10] = ptrs;//arry是数组的引用，该数组含有10个指针 在使用数组时编译器一般会自动将其替换成为一个指向数组收地址的指针。 运算符 重载运算符不能改变运算对象的个数，运算符的优先级，结合律 当一个对象被用作右值时，用的时对象的值（内容）。当一的对象被用作左值时，用的是对象的身份（在内存中的位置）。 对于逻辑与和逻辑或而言，都是先求左侧对象的值再求右侧对象的值，当且仅当左侧对象无法确定表达式的结果的时候才会继续计算右侧对象int i = 0, j = 0;j = i++; //j = 0,i = 1j = ++i; //j = 2;i = 2cout*p++endl;//输出当前值并指针后移一个单位 static_cast(name); 类型强转 const_cast(name); 常用于去掉变量的const属性 但是强制类型转化干扰了正常的类型检查，所以应该减少使用。 C++11版本的for循环语句for(declaration:expression)//expression所表达的必须是一个序列。例如一个花括号括起来的初始值列表、数组、容器//declaretion需要是一个能转换成该变量的类型。最好使用auto来声明。 statement; 泛型算法 标准库定义了一组泛型算法实现了一些经典算法的公共接口，如排序和搜索，他们可以用于不同类型的元素和多种容器类型。 注意泛型算法并不会改变容器本身的大小，并不能执行容器操作。 常见函数 find（） accumulate() sort() unique()函数可以将重复元素放在末端，并返回一个指向最后一个不重复元素之后的位置。再通过erase函数实现元素的删除。 lamda表达式又称为匿名函数，一般的表达形式为 [capture list](parameter list) -return type {function body} 其中capture list是一个局部变量列表 我们可以忽略列表和返回类型，但是必须永远包含捕获列表和函数体。 迭代器的类型也有很多，包括输出迭代器，输入迭代器，前向迭代器，双向迭代器，随机访问迭代器。 关联容器 关联容器并不支持顺序容器位置相关的操作，也不接受构造函数或者插入操作。 map容器可以用于键值-值的算法。set容器可以用于查找算法。 对于multimap，同样一个键值可以对应不同的值，对于multiset，容器内可以存放重复的值 pair标准库类型，可以用于生成一个键值对，并可以为这个键值对命名 动态内存（堆） 全局对象再程序启动时分配，程序结束时销毁；局部对象第一次使用前分配，函数结束时销毁，static程序启动时在静态存储区分配内存，程序结束时释放内存，析构函数会在程序退出时调用（如果有）。const如果是基础类型（如int、float），且编译器能够确定值，则通常优化为编译期常量，直接替换为字面值，不分配实际内存。如果编译器无法确定值（如引用外部变量），会分配在栈上。如果分配在栈上，则函数调用结束时销毁如果被优化为字面值，不存在分配和销毁的过程。 而对于动态变量我们可以指定他的生存周期，也即我们需要显式的销毁这个对象。 新标准库提供了两种新的智能指针，并且都在memory头文件中。 shared_ptr 允许多个指针指向同一个对象 unique_ptr 单独指针指向对象 weak_ptr 弱引用，指向shared_ptr的对象 最安全的分配使用动态内存的方式时调用make_shared函数shared_ptrint p3= make_sharedint 42; 当指向这个对象的最后一个shared_ptr被销毁的时候，sahred_ptr类会自动销毁这个对象 传递给delete的指针必须要指向动态分布的内厝或者一个空指针，要注意，编译器无法分辨指针指向的是静态还是动态分配的一个对象。 const指针指向的对象同样可以被释放 当我们delete一个指针后指针变为无效了，但是可能指针仍保存着已经被释放了的动态内存的地址，这儿时候我们应该将其赋值为NULL 智能指针需要遵守的规范 不使用相同的内置指针初始化多个智能指针 不delete get（）返回的指针 不使用get（）初始化或者reset（）另一个智能指针 如果使用了get返回的指针，那么最后一个智能指针销毁的时候，对应的指针会无效 使用的指针管理的资源不是new分配的内存，那么应该传递给他一个delete weak_ptr是一种不控制所指向对象生存期的智能指针。他指向一个shared_ptr管理的对象，并且将一个weak_ptr绑定到shared_ptr不会改变shared_ptr的引用次数 要注意动态数组在新版本下的性能往往不如一个容器。并且我们所创建的动态数组往往是数组元素类型的一个指针 面向对象程序设计 面向对象程序设计基于三个基本概念：数据抽象，继承，动态绑定。数据抽象即设计一个类来实现同类数据的存储，可以帮我我们将类的接口与实现相分离；继承可以帮助我们定义一个相似但是并不完全相同的新类；动态绑定是与继承相适应的一个函数形态，是一种多态的函数，通过传入不同的形参来实现绑定不同的派生类。","tags":["C++","编程基础"],"categories":["technology","编程基础"]},{"title":"一篇菜谱速记","path":"/2024/02/18/菜谱速记/","content":"虎皮鸡爪所需材料：鸡爪，香料1.首先处理鸡爪的指甲，然后把鸡爪劈半2.油温烧至五成热(150度左右，油略微翻涌)；倒入鸡爪（记住要盖锅盖）。刚下的时候不要翻动成型后分开炸大概5-6分钟，有小泡即可出锅。3.凉水浸泡待鸡爪表面出现大泡，调酱汁：耗油一勺；生抽两勺；老抽一勺；五香粉少许；糖醋黄酒适量4.起锅烧油，倒入葱姜桂皮八角香叶（葱姜后下）。炒出香味后导入鸡爪，酱汁翻炒上色5.倒热水炖至软烂 小炒黄牛肉所需材料：牛肉，香料1.切牛肉（横切牛羊竖切猪）。加入：烧烤料，生抽两勺，老抽一勺，一勺小苏打，适量食用油，适量耗油花椒油2.整个过程中不要加盐，先拌匀香料再油封。腌制一天。3.拍蒜末（多一些），下锅翻炒，不要超过两分钟！出锅。 红烧鸡块所需材料：鸡肉，土豆，粉丝（配菜在加盐时放入）1.备料：干辣椒，蒜，姜。鸡块焯水（冷水），倒黄酒，打浮沫。2.下入一勺豆瓣酱炒出红油，下姜葱，下蒜干辣椒3.炒至香味混合均匀，下鸡块炒至变色。再沿锅边烹生抽老抽，炒至变色。加入八角大料，适量冰糖，热水。4.炖半小时后加适量盐（汤微咸为宜）。再炖半小时出锅。5.出锅后汤汁勾芡，烹少量香油 肉末香菇所需材料：香菇，肉末1.酱汁：两勺生抽，一勺老抽，一勺耗油，适量糖，勾碗芡。香菇焯水，加黄酒，打浮沫。2.加小米辣，葱蒜翻炒，后加肉末，后加香菇。翻炒出汁后加芡汁再翻炒。出锅烹香油 地三鲜所需材料：茄子，土豆，青椒1.茄子土豆切滚刀块，青椒手掰。茄子表面拍粉（可以用塑料袋把茄子和粉装起来然后摇晃塑料袋）2.过油：茄子（三分钟，最好复炸）土豆（五分钟，至表面酥脆）青椒（过油即可）3.酱汁：生抽三勺，耗油两勺，老抽一勺，糖一勺，老抽半勺，勾碗芡。4.加蒜爆香，翻炒出锅。 地三鲜所需材料：茄子，土豆，青椒1.茄子土豆切滚刀块，青椒手掰。茄子表面拍粉（可以用塑料袋把茄子和粉装起来然后摇晃塑料袋）2.过油：茄子（三分钟，最好复炸）土豆（五分钟，至表面酥脆）青椒（过油即可）3.酱汁：生抽三勺，耗油两勺，老抽一勺，糖一勺，老抽半勺，勾碗芡。4.加蒜爆香，翻炒出锅。 五香毛豆所需材料：毛豆，香料1.先用清水和盐搓洗两遍毛豆，减去两头2.冷水下毛豆，加小苏打，盐（不要盖盖烧开5分钟）3.煮好后放入冰水，4.卤水配比：桂皮5克，香叶五片，八角三个，花椒五克，草果三个，干辣椒适量，小茴香五克，葱姜适量。加入盐30克，白糖十克，黄酒一勺，鸡精适量。5.烧开小火十分钟，加毛豆，密封冷藏。 炒蚬子所需材料：花岘1.先用清水，香油，盐，让蚬子吐沙（3小时以上）。凉水下锅焯水，加黄酒，打浮沫。2.豆瓣酱，干辣椒，蒜末翻炒（可放鸡精）3.出锅烹香油 葱爆羊肉所需材料：羊肉，葱1.备料：姜米，蒜末，蒜片，葱（滚刀块，多一些）2.起锅烧油，先放姜爆锅。下羊肉，翻炒至变色，烹陈醋，下黄豆酱油。3.待羊肉出汤后，放蒜末。收汁。放葱，再放蒜片，再烹醋。4.翻炒均匀，出国烹香油 红烧鲤鱼所需材料：鲤鱼，五花肉，香菇等配菜1.处理鱼：去背鳍，喉牙，血线；打花刀（可截两段）。2.起锅烧油，先放葱姜蒜大料桂皮，五花肉。料炸香3.鱼肉拍粉下锅煎（油温七成，即冒青烟）。全程大火4.另起锅加油，煸香菇等配料。5.将24的料放入，加热水，倒入黄酒，酱油，炖至软烂出锅。出锅加盐味定味。6.出锅勾芡少量多次。 咸蛋黄茄子所需材料：咸蛋黄，茄子1.取咸蛋黄磨碎（现用现取！）。茄子去皮切条，拍粉2.油温六成，茄子过油3.放入蒜，干辣椒，翻炒。再加咸蛋黄翻炒（用小火，会立刻起泡），加茄子，加味精4.翻炒出锅，加葱花","tags":["菜谱"],"categories":["life","菜谱"]},{"title":"周记","path":"/diary/index.html","content":"cbbe6a3acccd59c99d38aeb80053a158d9f251172eea86fbc56d73b32e1ca55d3fdd5cdef5437bf8230db9392b2cca0fb234c340bffc78e6e2367fbd2b99b0a6a4ca232a364c40a28f219e9fbb9c21c77e2a70d6d5110614989c51168d201d5dffb901fd64359fc227a5f2c34941779769fab6e4a93455fde9214a521b7b6b0e95f18d741187ef13a138f1b6ec63c4f585652a9bd938a6c0746e746f9d503ff049b27ce0f73e227513e2ad9e343307edaae6968c707f556486203723f429bdc8ec2ef503c8117c88f23a67c5db2b8e01624761181c9135fe73c2808a42c6045569bebaf4d76a70de7b0c64b7f4e578dece7f88ba9e51288d25bcd5edc60d94083503ecefc1faa4c388013c5d448cf39e371063fd318c2fb28b245fe72cbd8e74033fd7ae61b88457722060a6ef3b06cc9b0ddf2be65a804512b04d12188933a70d112bf4b2505dbef3de57a2cfcb5271ef31655eb9a7569085a8e5d6b2bedaefa03e39dccd34c5aa4ff5a174181587025cf5cb8c015170de42b5529fa82b3ae1125d06eb9d9c66634efda7cedeefcb0467bf36b7a65abe74d659a61b98366062defa04969a9aba23061c02d52bac5f7280eda285697926c2bc94af813cc7c1b1406f7a9ce9f7924650c9d1782fc79291eb7784b0beff01aec649537f8dac65dbc9d5aa739cc1db79f98ae9f340595906bbec213c5cae90e56bde98d009c1839a04128c5497f4fef4909128859d1c7e26808645ca781b2697895fa28d72f0b94c21046d2a7443fbdaabe2f138bf93f8584054e239a0e82e59b247fc9280f28f7f9b2cf55c71564187fba0be5ae47fe0c24f410c2ee331e3c38c3f8169ffa099f7321b821deef4af053105036a3aec2885ccdb7048d536b48f85259e91750fa04c8c51c91fd9c831a810698fbbeae6d1ab6c1793195c510217eb9e7124f0a64899dd2837bf211fa5d237521a3f4aedb391936c6f1e9c21e49297881982b20ad2228b302507fddc52c8c9e4bbc77f1e3808b923324e57f5e9a7fb8871e6d5810d1910628a5e2b9a150afb43739a6c3d251dc9ef3fdb93662a2af0aafe1e9140e59a4f6f63da166f9f95dbebafdf613640f35a88a869b3e493d01b0249bce0e4069624a2771c4c79b76ef7c32e8d95356cd51ee7685706c88e1dd6370d577481a3514fdeb38801d0e2aa3a3c5085373264bde507afef831f4a63b5180360d9ed1818dffc6538f51090899b094c5faa39b5547e71de37678f874ec6dc3df466cca7a01698c29275ba752d5ed6a290892af4e4978df48a70d5068cd5f442553eb1e1ccf20567d3e266c6a9b79d450fa08bccf80f99219eb718f1adc9bd28d24cba02a5836d0e4b89d195c14926cd3a6b430ce066171ecbba5d687fc58ee725bcffac02850385d389c6ed1ee5a377f150fdfcfc46f60d80f9e602a34a1bc0ef789efd7d778592a4ef6040f391fd5ac2cb47246f2bd0193d5b48031f7496897804e063606b087efd229fc901b581e4992e4c544d2752e6cf711083605c105f468a5e057bcf70c8919651084fc006b02829deb2ef72ade274a3ea230c7f11c8847696d0200e2098d936c55b8f152dfbe8b8363747780c1734892385b39f6b19a49c4f587bd09c1691867cd0cbde8dfd2cf2948bce0407e7fcfe03f3087b9240479ae8b6653bdfc45e5a03603693f91d665cdbf360e29630149756a890434ab46b7265933eeabf51566ceacd7dc7aae6a34e13213b7103a4658f4ec1fcf0a156d5f55eb3c18f26711b23bebce93000c99953be22c1f6651b8a6914b3a6e0de1dd2ef434e6a4c625446253d21df9e53fd212ea15db35895564b83e931e73466605e7e1bcc7bb708280976287732538c96808bc66374fb136687d6f754246b0849049875bc3ac151dc3c360a9c72e782727d8b45ad8c28656ef3bcc4643126c7cf8d4eaea357ae2e29e44dc1dc72f602948914526f8e42fea10f33a54b6309795be986a3f7b7b97c60b1cd0414762359395612def1b77349c40ed4fa7ed3bc988558fbe21a81876ee3053050d0acddc60f29a7a235f0a6b7ef463a064ff6a910ab90b2a613688ed374059bf653bfac413f2bbd8a5c0b0e339e1adedce8b18312bf9d2afc0637229c13c97577c908faf7606f27acb04c3a90b9851334165896148b53f063774af52bca6761022945493103f76305ca028b7dbaca9d8e72653e671e9e203f620b2b966dfcc1ca30623830e16884d40886142d4eb1b5c8d555401e464423dcb622ec5b113b0b5383ae6eb124ef6470d64f458c54bdd36127b034325f8877f99f40729378be57b42782a87e305a56be75ab5e3cd0f47f94a290d963e04e45cc90b1e17109b3838a4d20898f3bf01dc216de98f0010c75dba064434568629cc1039eb30194bd6067079e52b24264f4d513059637916868f641e588bb165a6989eaa36f33f12bc6634836ae6c7b54ffea209edfafb6a32586c795c82ade09e31c6546d4cb827a7b2ecd89a2d97bd0b91571f39943dc9974794be8b920dfa14390f9c89ac54e422d840ce5904a1afbf9a1cb04a1e57e3bda27ef376b7053c3bf20123db5da25fac7ceec0c9051389e3eee6d7ba7b229fa51cee7c12e29b81c3be792f84f432dcd4b99f0c0af54eb219784b79c654493874497c8865d94e7ef6614518b810db54b7fc0f042fda5194c737f49139f483765550978a1fb7db7e550f1fa309e29de1a3de314a9de4be8c85e078136af9803b71b753791132e53b94c43a4aceee4ccede27ac1b8803df8bbb2f93d3b2af91670d39065f1cfe09983881697f9b46f814850e7e253a993c9014967eb8b5a80328c9d16a562b026229023ca42672448787f87e52a12885328159d1081b850856261f696fa193cb0a6591a2d74620ad395714e5230cb77c2d6614d22ceee1a565558025aaa12c67e3e8d3d21d41986bd6f8dfb32e8b42fddcf403c23b4ebd6622ed8be00d95e7e8ad8aed882e84f8f6c87c32d2d0d8765b873f40abde3853164ebad306bbda1f16d8d333357574ede8ac6e30316cb04e0e053ae23444f5a2607718444db516e4e155c1d0df0a3362ca462fb53ac65ae83cf9248d2de2c4180639d54038df623a5f9aa96513d931abe7071d95b9d84d9d2b156501d54672343febad17b8df7e2b2f3ae5b4bb3168dc58880dafa1a4257b9837c5a07cfd5a3d313102d655810e8b3d2f929538b30da90dab01e3a42971d95154fbab0823c003356d144588713a29a116604111663930fcd0d92979cccb1348ebd8c5995f772b5485d48f8ab2f1b52291b7ebab1c5d3986bf9090bd5a0ca135bac7599d6941148ac88a16482748cfd0b6d4ccd87bd16631df593f6c0ccd029754e5891c951f4e7af12b1fcad7b97518c3aa8b2169f63192110685b39d498590aaf4dc4a5f6f5fa9beab75265c735c753bed2e4506648a662b994b33870e4754841e922a99e3880e133ca8e721726be9b3e06bbaf86c81092d767540695a54de0bdd47b4c085dd1d02354e4087dd02b72cc9110b3de9dc3a57068960af3422d4f7f07c5bf2e1f3bcac078facae54495b6f49b5ecd819aa1fe6526c3135efe3e3ae066c80455329651a61072fef5d600fdd992bf2b836b6d9f45144f9c195b0757d00101cb21a5a0a1e8c398a3de638482e6e119f4e74fc6a7a66c112a682a8f7d06b406c48cd18c3647d948997bcf9973a8f03cdd649a8a15c701b31cc11a2f0ebef075e17e0bd619371b10062dd9814e8e8a2a8642d1bd7f53a444771eab998ff8dfcbdc2333ec20829f700f5234fa53552e2f369f4a17727fa45c16f559ce4aaba34c82c04a740cb0c28dee67c135a12a432946fbdb083938a5729b35269ec4f5df26e34938164440fd01c5d1f7b6123951c85428624d1a02a7f2b79a59a87934e36d6806962bce5a4e88f78eded34fea38375981263cc84b82c47cdeee39651339457a8f9e74044935d3e1b2ff0f1db341b49fe2ba06e6815ab4d855796323b8c83160e4599bd3d3131e1cda1f9da33d972368e68db670c76855598e126b60fce9227f83f9c34c6846ecf2df4a6c0f935f458b1f9119946e8a9fb4ddbfc597c4a039ab43ca7b44839ff3163c5fd953dce5385484b6b7be4fcc2acae3addb7b5453650cf710150d64aa03520364aa8154d42b84b8100c30bbbc3ad8b4c0643303f81a5313f2d4f825c0c001da69600206f704db3c6c5f0185d9f2d2217a6f264434472347b76f5fb546cd03541c4e6db5af7d60072d559614ef8358495e69c7c70edd53952bed9f9697fffaaa2b16fbaa39ccf45374775a2d8d5c35b9eb2f03157df79d6bec06cefd10aa17e344ab98a54cbdb7b9d952796c6cbc146a7d45b456cb1d23fe76502b8cb8c724531ebf03ec206ad95851cebdac216909017e9e90b945e454f81d13c04354fc61405d320b46c754d1739aba616d7bd8fb9f6d032f2cf1874d1832d70e41a7511acea313b3f52ef97c35d7053284864abecc2be610c94771a3b0ce9cd9a8285cbc5047f122d493f101da0e8b97797ed40c0b076524826d9bdbca37fd575dc00350014337aef669d589d5b91afa779969b241d87653a619a4057a9c417c53ce980fd5de11044d8bb69a3329ce72e2c55577bb087178db888d72b051d0980bc47a625cc1c8da7140ecdc60b3b72abfee6f98061564dd2eb5264b6f9f6742e830cf16c64b5357b76ca35dbd7401124295590a80b087cbc3ba662318ed65d9082f0d6e1869e78708682ff7f90b56f8dbc2a07cce03834fecb4b7a817363298d6239f6e4a15607eddd44e5c02dcee2172ec1d9a6410e8f2c7d1d47b3aa435c20c25988ecaabdaf16e46ab5d0c8725c50c5dae42abd797c69053f93ad0dd7e4bd03234a8894932adff8ef803677b88d37f77bb8dc640ac229d473b7073b37c36e921ab7435f89b76cd57a4c9413d4c9520b47919f2aacc2ff5c063be43a5bbb62e718ec787816604372961f8d7eb27606e158c339443c6ef59bfe001e20226cbd9c93d97974b2082cf556fd262725f0e26093394301e135cde98bf64d610bfc8917a846c4c51c6522ef7aff231b26c1f2425de5a96693d465e7644e9abf882fd8afe88fac43ff117d79f55bacd3471ac4d70dfcb819c2253436b028b7f3b8af32528280fb0d10cb0830b6ece48bfa777576eb34ba25493e00efe2c6c1596b18ac28e52840d977ebc119d0909742ad38639b28c2156dbb5d34adba87cea483970585de44cba49ab33bdb5666e5a3a02be082bb4a709a60e3a040f0b64c3ddd736b740c1649fdc32dccfc5961908f1b5d6a6429856cac6e5d570ebf59c0f8ac3386b1e9ecd8478b88be98d1b2ef5f37a3494b96ef16a830472c69b820b917496c40478ab95ce94c2a4841910cb9f11482fbf35be6a274aa770d169f0896608d79c12764c477b18e63101a13c5aac88dbafe6f13cee462e763a4f076db4df31be83be275522f7b628723b60a87a281ad6a0a46ec367d69b173a179703e36587adb58990d7ec118c21be05ec3893fb8a318928a6d01f0ad07d5561b663a1706287d6ba14849cd65ae80c8b59c20b0c7f3136164e43a6288773946f905d24075016133a73ee64e2ea8e6805a2a9e590b754831a91cb2802f7a394c0cf6c905b205099597127ea80169126fc229e135546e559f933407943487a65d3d9c9a24938df2a239424df79fdf77fa9dea33385a9a3a3a7a2f15ecad0beff143524896faf8cb5e92e681a80e192328293ca2e58bb1327508d3782b3fe199b09a83dc42f34451b0ccdff7f9a1f4018fd9b0f96b65a12560fee7a4a5ff92d0fbc24a7d5846e7ba7eb8f1d68d5ccecc3e557621ebeb51116048b76a9c0719a839aa325fbc62a21ddbaa768e19f2e758cbb4513933b3b0decced05894368640d0c44b1e3b9cdfb7ba4cd40e15d5cc4f02dc693a2cf31c7f33ca5c0d8744d6fe62228f30a0db5b42dc85e532dab108748a647c36265a34abdda677c4572ef09f8b44137ec573095f5d9530e09ccec7c654f39cd51572f7077313759ee6d473797d90cdd76619b7524e918fc88bd73002de1909961c24ac1692ccea938649e19dfde879244c386259e4b96a25ad5664a1a1b16861c0accf8789d2168180ea6a00c01b3282a676836c9209b6f6fb2c7daad10365161a6e7ac8c822a476adfacb443137838f01ef9ddd1789d03143da615aaf995bade6cdbdcf67e72ce2f469e0ea8d9f7c84146b2af75c7ecf2e39d1a4f07a4e8514a4d54b88750a3b412027965af39f578f8f787e243b6be0a3d4db8e158d3073e85a39fbf0f05b9d307fb27164288481234ed4788849a82cae1a5426da1c31d232b2e8deab8b8647c52b32bab8fb9e0e7f7247f3a9da15f45b6dfdbc47852caa90e732e7509f5b8ce52732794d7016bc1cf7e4513ee728094e5ccfa90b65d2279f59abfa6138b406c702e3f143d3360e25ee3d4b3fe014a1ae7e6a0a858d8fbf459a709c95cd2cd6b6f06060669b8f635d3c5c55d0c1718a0071f6a836613ca5c0dcf9fc4f12e4c4ecd9ca197980174621d722ff8c3f94236633d6eb0c8908b00f4a7b41fc290b320895c325bbbe683f43ab6ea71c6bd925d57bef5ec77871e21fc6dc1fa4abd8f1c834ad8cb77cd07d7c7bc8c3a2ac021efd63f8a799fd8fed3b72ac4e889164f9f8bb70e44bf0fd452c5d74a4c1ed7f9a6c6d1880156ed56cb6b3ee6b75d7e20aeb1467278a2268873a8b13e041bedf10e3753f4dcb2895e33275e10db87a4dece0601c33cbadfa05e66682f5493c1b70e8df9b2b082ae26c174ad1053d1f9755da3f6a33801c3bdae4292032e53c2629257a1c99bc199b55a43065027956f01277d4ea7c234339b8efc888729fc2a0aebe818a52ef05c659655d2c6c62fa716c22827f92f033850f98af280c3de7f8d1124c44471134a513efef1408801d67503c45ac9d0a6245ac140aae51f81200ff424f33a444d95c62fcfd4a6391267de41f2d160341e4f2ba62e10d68e56f618fc242c17d1a91147066417165887d1ad08b6d9d78dbfdb58b3e01dec19cd57f500d05f5d809b81a4e6f2f895ca24ac85a52bc657b374aae856c0ddff82c3d3843c3269716e9c00f61cb09d420cb3d25c34b17b1b663c1fcf4a066e92a9ba5985db01a8dae7ee03e3e1b68184d60726c8dd589b54d8ae89746d4bb7092699d68f21da6230a36d23c333d906db7ca724ca30b417e519e0161e9c3a008f8d2783839a9573cd3277592b339a5d9400ae163bd236e0a2af6559123b037919e530dda86e411100848cd16dc139f55b72fd86d878bdabcebe909cc5715ad0905da5b55b47a9f70f85cea560244bb10b7c1c120fac668dc8e4bd17464487571b3c44d9e1634aa2d89054802c9e60889f972b3bf966b9077db5d309f7b990ff3711547a24409631dcd0d2704886a6c0dee86c6c512bdeeafaecebe733279b467093eabb937d928b1bc7f481f36f8407eafa056d6e6b69406647a3a1461ab225ef851d91947724480b39929feff4bc6e4e9614cdb3348620946bf4a5e9e822cee925d75660451c32c1567a9479538ba30604349feaf404414b7e4d99eb6550f7e2ed14bee92a5b002d40307d626030273150be3acec3de2b0000e766b002d9407068fbdf504533addf425b23c531ca15e39452b3dee309ecade32741f7dbe59946d92ff1b29fa88b5411074818a2681ac1dacc97fe9fee35b02706fbd0c5dae130cbf7efc6eb051edc88044075baf6fb0160fa1ae2736c08f63e14969a072982d971f612eb75e16de011c66d0d89131802296f9a6af3e1e138ac7866238faf82c23383ecf9bf39a25ca55c2c53f787ef84b2836c6a993a8885d11c4ab326e2884f97b8773440dff056c192e8fc6fdaa09b24df9a6717b13f8ebf67bf7b4ba9653ef55f9bfa293b0ff25dd25d3a494efe45784bd41e7ae17cffe25e61fb88d98a3edf72fe7225797e1e664eda7239488f7ff1f0834a2753d7d10ab389708ad386371477dee738951c18fb93e29a44977bdc9a7edca77047da9920fa8fbb9c450df04514f47002800be3ca9938d7c8e67a7d60cc9fbd124262a8b1493c697e2fd3c226a7a9890e90717c5db08a1ea25ce544502355ab0ecdcb15086b6299ed178eb7c015ca551526d6e2c424efd4bb80191c72ca3cb7dbf65ceecd12d40f1e7f521f67ad00828f67ab5c955a72df29d76a03c2af4b8c13c324e284d53edceeddbce75c09c387cbb0205c35b7c43e8790f56e704100433b60fda70fdab1e34d4833f55461f65ac236da881eeecb553aadd43f437c0078f7fb7c53868f2845587259f8f0d803b37a770c4734c354afeb0221d4f0a580f98779543493ca51529c1ed1b312b01810fbf1e6eb8b662525f5a665699bde5873b55cdedebed9e65426d5f7525d82ebdb07f7eae6e1fba4ec4d2c688551a4dee615ee362b03f5a1a706b256319737bb8ed433682a3551042d7ca48225e11babbe4b0b090d0d5cfd29399b8499718c50370569ac7fea78adb198aeb807141c98ff4d0a6732c439a826ed543c6db3fe7f35ce35974a65ac6c331967dbd29525167c2878cc6c5f0071c79bd35545fd3421b120d54ccb1e95613a5bc242feb94b5b9a449f498169025986967b095d9ee4c3811cb19ad047287eed2a5d94f5cb8fa2546b8c638e50c2b7e1bf896edd7c1f01b1ba98399717a74cf695ac14340f7cbaf0261da6a264da2b5181fe25d6e64eb5e46abfe690de2b1b32f3b999a9ab93fb370a224e8fb6d865ded9853893ddae5b66766419633a479345686d8e326c4c609e453f5220daf59d247bdf08e456e3dc8968fdc2231d95b7127b2b49d01d8e0f027d96fba02ced291697040bbb0d439ebf942a8b6e1c888d1597faa6e4feab302bcf58f2724a39331324ea219c3a21cf41332db46607549f7c140af7155b44f3d8723e4e48467d9b7d3a1e3a37a5bb5830a9b6b890c5e179a782420ec9b533d88c25dad01a3311527f207cd48627dab0f8f0c172ff9883e9ae65c64d6fa2160efe4a7a6faad0f67a0778e0706989b62c68ebac7f78bb7aaccdef9131add9f5451b81836b5de031aceaad53460e83df7173de0d46d8f99b02628aee278645a18405fa318ec61a384e4c8ca1cd4c53c1edd23ee5871de11e53ef4d8539b8a5da39976318929a9a59ae16b7388b53ef0131a9612a03be370e67c725eb0f29243391313b48432fd44a80a74a8e1c92f51e409b7df6d0ccf4b0cbfef99ebc805661ff2fee26581eec5567d39fbb9286a45b539e3acac91928fe50bde7799885c5420b880e870c76cbeb26bec53937cef4407ddfe52e55d933e0e22825cd72a73dab7831da5f962009db6aecc34ea82524bf5e4479e4e8c04769df8d3400d52a050122b14fb3ec864c33b92a1e37cf27d7cbba6e4f9a635b85e05dcf4a63f7dd42bf5dfc807793e234cc248f1bd2b54ce7f104b02c4c4d99381bc6bb1d170df8363ced1bd61c11639e575713746a5ff90d4b9a1cd78bd8db2ff0e284b9a7dffee7251371f145cdb8063ffd9fce014458b1d12ae0ff3fbdab0e6f42d0db70643d9cf2730c3b5214c463ba95855b3e8f813a1a0acab45df560cd219d7a89382fc656f92a455595da08cd695dae64aea72e211e3a2fb1d2ad0f97959fa9d03cc752fc95f6e6abe8b5d96173d6f427dc2a4b32e0af634ba2e87ed087c2c6560839528d66bf85ff327723f1c530ac45a735dc39d1bdf454faaa2d79244a4eb204be8940569bdd7f0650b6d7d27a01e907c5c76d09e1976032d42a74a6af1f77e4004ea44ebd88b11af5d2e3e94f6dcb4af430d0572316909d6e32390ab5ae905d5e1de505856b61cbc5bee15998274034dd6518e64b5fb55e95ebabc9c31d76d8bd9ed0e7c40fdd90fe5b396ac2faf43fa3333cacbcb63e4cb0d8c237959515971914e931dc836cf71deb7ce76594329702979eb04f98822225b668be924e3cb206291239338f939e1d2be0ad5598b81f204915186050d42d82c65c40d97fb4d565241acc53bbbd6c0dea6028eca0e2621c14edea9a63b757979e6b89e08ac93ee40ae163d4d5be201345f61f2222b7dafdb301a86d0de8ae90902d719946dae62e490c0d21c8051036f1c4b46ff9a681b1e50858acd57ca6ebfed67659ec8a0ec65dcd366c8599b2558bca785101005112c058f85c86f4f880ddcb225ecc08241fca7d875eecfb0e2a368a23c85b18c8e9d0d8889598febb357cf5433b136b9a192b41d056b577cd81b524eda4c16042e0a445de5563201f1602bf8136bd8c6f6e084347357c5a5c2111926929a2473fc1914179dddb4e294512445ab5cb1e371a89b8121a62a1b88ef173446abf93b39dbbb8029c9077c09be65e781211a4709622c28516619903326ead71ca22ee7ef6a8c2553c83e264ac3a9bd171a2da6341e0582ba5d34b0490952497b86e38704d05e6a18950c4e291560d294afe2566a63f857de8af7e26a785731364eadcfd565d4ef1065786d74c45173135c2f9aed920c13c7ff02ff8dd4121b94361714b64bc690a5e77f6a314f09439e8db5d1bed6d698051a6eb09bc817f08c523ac273fb8a582c737a3734c919bf4f5ebd57d9a0d2f7f501f6dd770067ec27e35a2e98a0d246c68cbd57d3b1c0b799397d879ff60946012514ec51eda5bcfb9dd4d77a37d40548b6f68d48bad729c0405386d60761f8f366fcfa62cf485d96fd461bf4c838befb2f33406daae512bfd7f94f8232e1882cd339d1acc069ab1d130677c600841a1159adf0349f9d1b0432f8f8b8a52d5a7a506b027fb55978951d2b0c4c6b2bd5a9e4cd2ff67bfcb2f910e9506878687aee1a1cfc62a21b81033778383ff13f9bff2fc1a9982dcba66e1a249c99bf4cf7b992cafd5cf7b5cfae9c948daa5b702df14c9fbb0e59c76d95ea92f345b67e88b38e942d2581bf57d00caf2432373c28364aa86f36ff1df3dfe674ad9ff34040bc36f729c1d277a94238ae092eb24351c6588319183bc93e1c9073b0cabaf9aca30c35064c538a4125911bc5c5a83576896fd022d41c8ffb6646bccd67b2f74a30cd283c188c18e3669fca4361dc98e96aa6e3c5403c2dc36f381991c6ca67c01a001f1ee3e1e37cf7a45004c57af772b2f0c3657e0f0bde86eb84b7de1900ae3bb6bac218f5e43263c97745bc9fc26d21f5edfcbd9df7bd0f36bda3de6b632f8cb3d6f2c03930aa1145fc9d24e1bf45a2aa3f9ba2297e7f6e01da66fb8760b1b3fcc24a8cf366921c19b3a82f299a1dca76a28a5aa736feb6e80f1182a293856d6ca8b1641cdf1b52225020635bbd778bd9f31b42b25cc99d4338684d212ac2857531833893a62e22f9f152957ed673c72db9fc28083c0325e75d8b27eeaa8aebd9e10b17c215f55e754178c280280d28d6abf9af9a6c3e65daf311c1fc20ea0669a17af6f179285f0a16bc5eee24b65313d320e682bb2240ff3d8c4a5305e0944ca3519c7072d4914809471ba6152db4f742a9f2f6e9fcda77d349a3d0f786bf3d46d19516ecdda554741c9cf5eb05d3454c560b6813ffbdeaf47cc559311ac2b46a02dadeb34464dc83de38c7bde84968bbeaf28e52fc01298c50d0393a6d397d97e928be799a670d0e322c530e16a4888895d4aa45769e1602891588bcb4d26be36ba2b06db6b52103c61f901c4bea93386d5c3f3a1d90bf7587e63f36e09ce9cf09809f9795ccd04cc236ade5a88c1d0e4868d56a7645c87a4933829faf567c411af9da2b73041dd194e6f64fae33834e125efbc34179b7e95267340e52a728340aeeb97ff0ee30c7c6d63c567e481e28e4547f9f9a44b60bb630d9b462d34fd453bfef730b6c76dc779c5f281181fa1636d4a6e7d45d2bdc363cca8bb9d6bcd7865a983b22e2478f0ef6d6c97e7dc1ff0a229b16f9d048aaa6d37b67c3e18d2fad47a73f1e428ff44734e82e0080e4f36ed1f5a25a1e95445d8a1d50e8d16ac8bca2526764c4e9b0943bc5a3c5b17a0df1dc4710a41c1d49a213879849c9d55bd21fdab131dc573f7fbcafea9a2d3fa88bf5d22c724bb2095458de2469359a5f67eb6cc70d00b6737a42b086cb058bd8fd276be0981e2fb16503615f7e8004020928e3cb872127f37ea9c26580c7654708c4d2be2b0033144c41ff4ed7603858b7bc32dcfa25c8e0f3931d57284a91ecbe013296700c53f481f7ceb78308c01eca7e29a4539be89096ab6a3633b16f6db00834a1ee869660871eaaca5878279e27df9626499386fac0c096baf15e2d3e48ff0c6fd5ed33968bb5484c47f700642577a844bdb9697a9dbc815212ce9c9b59bb3f62a48ba4d02d11e41d270b112d63e727c32812e49acfd498aa0c057f7be79ddc1fcc8bfc1a9050e6af98e8d214df77cabd2fd9df782ca1094010ca6401fdbf9a6cabdca45e8a335d6ab3110dc656c14c2b981c74fd9f5e75065cb85573b5a0156a3e1a09cf4a915f64ba9797c3dec93223d2e4bed385c105d786c2003d2cbe6e5dee47350703d7372e16ede7a18ee281daafcc227b2344241eeb76b141c593fbd771e42950d4944e96c60f0f51782171c91ba34132439eb568a25da084c27c7238c6f4ba62fbd210665f4c2aea3ff6ad8b5d409a12d28fd87aafa6c8bb73822d03edb0bf8f69c534f88eb846768c710e771547d5aaf11b9a5a5928c9741571759665c8debb3f6322143e797de22a183af2f7a1ffaeb4f04501541102237635bcc5a23cbcd5ca1560449196253626a7d56df629edad67cc23d04fa71ba8ac97994ef13f243d87a45c826b3902ee4ae8f1805d6cfbea1a289ebed17eff4771df9356cbb8e658def387e69e221a285960065fafa26f2e068e914d63e4f8550ffb9bb2ecafc04dcff9b0ca3c4001cd730f6148f1224be2cc849517f3515bdfafb5fce9cd0d25c5a257f4fe55a8b9572e6faad0768f23a35fcf1698af4de1f5f5f7e0f010f8b40fb05f14d1d05b46ccbaf0ffb86ed177db7a09d815465f1f96ad7368b5097715f5ede1a09d54b3ead541af6d860afd34dc5a4185a5fc6ec3e06fa9ee62e1dc71f0f77b8bc4373ff556b338eed34433335d9b2cc3a5c31c585b25edf5e6544db4c53c3cf3b44eeed698ebb15dc7178994cb05e8556e1d10a951964c9b5f9a7373845aa866c95d742133ab9f2dc9bcd3faa70eb4a3de048c75b00e5c23f66270f7c1e81d3097799a81bffc9b86a87c21caf5ba1b33b0375c28fd217d4d717ca2144c95d1756473e154ec210eccbcafe3dc6feb1142f70a6c80920f48821b492a5903cc9e77a860e14426e579f445ae9924cb7f00b2556c80c6d05361afda95d96cf2d097a5ff03e426d6b19bcd0f131af0c5c4deb8d6279d1a15ac57a524d1eb1aa9735de08ce4e97d01120c8a3965060c890c324b6e348237feab8304a2d7b917bf18a6958647198803b5fd8a2f07110b89ef5745c44e8bbeca216fb890fad7ffc9fcb34dd632b276105d657f6a02723ba020e24dab8b537f7e1c5eaee4ce92c25d9b9732eebb8af5c1e5829beb82f7cc0bdaaab11edeb636c99b89803e57e9b64e75bc8758b2ef41f302516df66c2efdc0b198bed6a4b48e3f2ac961f854b0c720fee38a82c41ab7a88b9c3e4610aa5297029355847ff54a42650ca5696b709099a73d78a16f6552e3978e6c82bf1d7036de9b18b0071c9c97fca1e377d761d277a412e494bbe420706e3c54a2df51cfa2b6604177e7ae845741b3ad7e128b011d17f42d87d005b8fcb98a3a88fcb8a137ff2d22ebf2bff2f5ed314759a4a99f8ab1c923426dbaf24a175ed302cf26aca5e6091af28bf2c3088ae9f135edcaa67bfdf14908744d3086e2b123133dff69197747a04a3d540814ef5a3a19096b52da902258dbda1a19eb8500ac8cbbb6217b12ce9630e43196452c50c325a49df6026c403b7e4db6cad039acc43bef818d661ebcb4b1f6428a9a0445be14c184c1a865c588a5840e503fe02362139fa765a3f2a109357e7e589301ef5e9c616a14a416b61ebcef99581233546d3df0cf602d9053a5904c409fd716043031a0b1b2ffbd38064daf905a87b6839c4d3bc8110ca58f68f522eaee389cc3e6272030feb7679e250af19444e4344dad7f88d2c0f007be5c382b87e9409e6d2eeb4f3e3706815d645dae2a7a03c587580a6bb46740b97036b01f2f035707b091752db1f0bb195dec27263eebd88c66686925077e7646fef97b8f5043c27ca6307c75cbbd7d30104119fddae6b1ca92ebef9c30f6a1533079ac73d0e906f1511f20766649a7dc0d38d93c77fd4ed591d07677497858b429d90979568d9bfbfb7c779aadc0f09988436ff160a53ccab82458561ad8111a08b2bd45d541a42022fb0fe9cb5c85e7f772372867ba65601877416d8fdd60c4c54b3cf0aea20b90de62b2e671fe073d1db1382e247cacf89e0490d235b4e2eaa415fe907634d0767127bd4732c1966d6da451a8fcb6f95a223684ad671393f2d4f67573eae4f9c07711f4a0ce332e42b0a061041d69de3bce50fdf20d7f4f2b95eb15c7d82c330640c0f191ffb26c01b204ae3649a0e7d2c3ea5227e06fd201c27f425f20f1c05b0fd4c3a2def3a08f20cca242f649049508970e2e0ae048a8ccc496c4ff73241ef6bbb6141b157f1b3efd3c8f4bca0f75253ee7d1e561db1bbab042217d399e2af56e8dfd834a02d39b806855d74ef691837626c17e12c564844a609f31c85af7994238abba55a3eaaee25d95eefe9bd42be0017c9163869c000d91996450e5dbeacbd4effc2af2c1d5e442256cf5d531f94c57874741dcc16681f313429cc98332065d3ee1f128bbd2dcee555c5607ce90890a90340749009ab0d68b2ba3375cb0f350bb78c2720bf09aed78cad40e68cf2f3482073515c5a64b576655744626512e1e57a53f44d2d42bbc2dbfb105898c883b40a9a104a04df5c26ad5d154f6c67e13027acd6879859dc8f20d0d1129a8af8d2e9891a3f76280cdbdd766a6400f67016d012672aa0a9b55f139075428bdfc729265f515f72b0ebe85443332e2b537b99aaf7ba7048b3599a4cbe4b90f084a3904d09fcae2cb7e36a6f3f59cd192439ba2e9d7320c64d85d41da2883e4ba0dfcbd8c02b1ac50d634d5862c986a1bf2edfdc62197e4dfff6c9832d3c6ca95b020cf1151f29780e9382fd8cf0e89026bc9fb19431b287b50efe4b1d8a46726a23e442f04a0073d339414873f0586d25c491cf0b9d3f4bee3998cbc2dea3536e5a41354ca80645067ae1ac2c62b7030d0b66d752c14ec68380d3c9e57d3632417537a603c069f1ae9f2e396144026288b2fd636404337772aa05946b85751e269afee8bf650427f8708be3ba39e220f661a52e522ca16d82aac710c6503363132024c32084e09bb32d1995718cc400cad19f36a41f686da47d0de99f704bd15e4e9305000e085fc165409fc605da6d4c10c3e07e9921b1838fe52da4c0e0dd4e0a520b6df8dffac2a17cafc597faf0fb34efb3a0bb574357862d1a75328e1024f8d63f50edb0effdf688e8bcd9f66c6f5493b22f18ed9169d8bebc8627634c494069833959575e37a84d3db6427afa249586556858958d83cde43f3a0ff149440cf8302d4cfff293a5765d45974fef903d3a779573a56881c74122cae569fd9516f95649a34a723382a4b446251081887c5b8039098cfc61f21e9e258bd0e9854dd3081aed96f87eaf306e89605e9b60e0c055da3fbd912ce4c4524b86c7b49b1a7750835807a394a1eaecc4d51e3011c2bf42967b7da64210afd2a3e100cb7bc11bc5a8311ad1072837113e9bf42c05a258115463d6252b922459126e187d0ae861fb4c31217e663609bac5337ea4a2dd7d68548e5f45ece47276b3e5f2b84ffad8451c648050ffcce973bb3f104391f57e9ced23a735d2897280007d6381add20f397b3a6a8734d713415a5f70526ab9eab9da44e5592e5828d330f536ee75da9bceb1edcc0129538be08b3ec92d7400c799669e29336556a27075c9b419b2841f12420fae18e70f6911a784599cec08203199474b9428c28d37d12607693dac88a9a909fe537c7ada0b292f8f9841afcb7c4cc0d10dbd00e08e41a5726635a7e502d4fee8dd0ba9940eb8d97ef789f05ea1ef7b17ba1fc80a6039ee175aecdc481c9da0a2559d0913cb2def9b83680d347e537b43a67c72344692f70e126b0d7b73d9d12f242b604c2e3a62edcd1f3ccf754beee6a23facd91289427184f3bc6035b1cb17ffaa471008f9dcd6cbafd39af511e7da3c361e50c081c02f5317ec9f3037ba0c8009073b042368c6897cefbbf623956f6ce1388bf3897e64a0c40b640f3f28a7d3e58466e309e8d3645e38972076f8a3837885a4b8999ac28691fa73341c31da008561cb912919142c8192d386d56a8cf6ca9a79028da9f21157ec4ae0c7661603a2c84d7f583cd1b95fd768d95a47345ec4779f1a4625bfc0b82ad10bb7a7874f11f08b02fd577b754fe4607ea847299b4b3b92e082df10548d82de7dc310035cc361ade8114db85bd77f4a33b7e214aac5e5adb1098f99296e43bdea6389ae7ce970df3a6fe306bb7ea82c510a62d84c56cf52847148f74e2891752d6af0252c5e698cdf96b70aa42c071a99d9daf865e04000dbe80718bd93e42d440be12129468c949529ed53fcaffc166c5dd210c6f63c4ffa08ae8dcd866029c523b9de5add81e5e861d38fb64516e4fd301872ddb49abba8b374757a1eb483884a6d542b7ee4839240cbcd217b77791c7f6599aa23ab728259b8947eada3642d4173086ecdf23908cb19f133007ec99e4ec6d2682f7c467ca3fed8c6530298ba8c3f5dc4cc8c7338939ca6f6f51931e65e5c11c60be6513f9121631300bd4c358b3f71ff26b322458cf4ebfd4be2591ee487a75d043fde64503775ae209aa381e2eaeb7e9b0123dc00753f122b993487a403e8adf3d24b71b473e6d3d5f2bdf671214e1d85c96284ec99dc941507746f565ca916e2bdcfe13e2f140c07525a2b7d8eab87e41c959e254ae91286952ee985778bf61731fb0dfbbb665d13db279799c9542b61591c2d35ad657fc8886faa4c853cf26eb3e270b7e29b5775d8d970378aebd044188260e58ecf565895aefc2fed82945d6263bcbda383352f0aeca29abcce70a5080a0f07ad3c8def7c672b4a3affe0838b60dec1fdd00441c109a9a608316e8e9da2114a8179abbb0a9ed326ef92fe7935d0c4ea00d1fc1befad22913183f4ca5033c6a8a38a2d440d28577b192fb9e882c001fb7802a0b2b569a36ef85dd4a482f8125a59278ff714b5d205362245a34c347be530509550ea4028376edd3c142efbb54338211c8dd7e5291f28702ca7e81fe82b98dd6bb7d135b9be86f4ebe0ca0f82c000e316710889477a4723da5a3bbf28ad94461b8a1c0af3227d18f947e97ce24556c1acae279c93d88128a7285c16cdc7bdc4b8349180b77facdfa921a23c5cdbb70c49e902ee648c2d5de962adb95c1b45bd58fb7f1e2bd6a5975edade73ac0871525343e1dddc64e754dc4a1b5bd8e3c6ed145f269ff9331280948c4e8750387c23f054a46976c854cab05004e90632e72afb4debf0eeb9c3772ee5a3188b55c07d83134ac2ff04a464de13c195d99082518ad0d830d4cf9311bf279e3339c98da1ee5eaa720e54a3b8a9afc14fe638473685f70ca3cdacf0ca642235927cc36f9c70da914a6ca815cb43f3ffd27f535ae442f04238f73bc17b7b10cd55bbf2b88ec03692f97a69691ac0dc4d6d29cdb48be0d444d65a1b154f6d8c3f76f026c3d926140bf25d14c0f6ef8680583f7f3a0b9f6ffec4bc5214f9cecf00fc55ce3cc627e5eb8212423fa875682ef4931321c3d57a4b6e1f9de0b54287c71f26ef83d51678d6e2e0174a5f09c672db982c13d35238a2ee5b6a026a5fdb014639fa9843cc32483689e66b19647cbed74f8ee18ed870d9a27f620e51300bad578123500211902597f97788eb72d499d590483c4242906bde42d58217ee25427013fa2124bdd2698421705591c7c6ba78ee1c35cf7398ee7537cb2f17723a5a2fdc2fc5c267f98f5ef0531fd7228eafb00573ca1e3229c187b4f0d3a715de927694a6af8a126c147edd26d0f97d8916ca17899e6c4fe99e840eb0eff3b7cb1cbd1496f55483525d04563c5d449d3ab8fb502b7ebd4dbe3475b6cf6b9800ebdef340060cae06a63e034ad1b37680fa17fb934cebfaebb82cc28806eec2c1340dad466299aefc698eed1f43bc196057996859046d91d080d7acb689e39c4df60f800274a53f6a2617f6268f41f9aaf7ecd6ccd8b659d2d94d33c38415475c5642f12ab72bba2de2d8b6166986c600eff362c708f3a997151c49809a74b04114b4c4f8b77ebc24b69e1dd0e2365014754c0e357f4c7a7abb6d6b39bf384794d369abf967efa05f6e1a35334bcd0c5de896ef0a5941cea46b4b624b32f6032f481aaed620008609e6aef07cbac9f5f4aaa53d57cae2c445163c6b84543412e56662346c8d8c9eef8a8531bad169b00337f7275ef0748d3c4f74963d08937891cb037f08df49dda42ddd90baf76a4c43c6b4a3b4f962ad5a6f05c05fc2195016d97ca65099f37f2cb7c408b91f07f2b39644986df89e21813bfb77b6e5362032adef9daabe5c5507617cb5951abb51a5a88d683bb7f331ae7cbfbf608dd172fbd7db475fe9d20742020162892c7607629d7b855e25cb3a861913f1b140bbd4bb34ac705cef62c2e1409f927b8efd5ebff3f6d9778d66e0acad1f52197d5a6bf25fd649392e2c6b4cb00117c7fd64c2d4a5b3e633441a88e59b2c76ba4d08718d3f8514b0ed7f105a6269421e2e991e201d5ed12bb69df30c610fd04f5c5be3cf9e7c4e0f350ea8d987d7ae8f690b4892e9ca95b620f002eb1acdd45200996a29118782f521fa836d298c20e9c04464dfa2924217608f2e4ed052403f98c58f3e5a1155baac810910b390449d8a5e4c16a0e6edeb4d84544b140a45d881567905a0e88e8c7d978b7f7ba1e3ffca4182d3bd76bebd7bbdfe5cf88b036625bafb7cc9ffa137bba9527a1b5d00b2cd94f108a2901c28eb08fbd03a0ab3ad29d9e8b6e19ee5294f8dc2c75df3b4b0e1f24fdf4d496a042ae3bd51db9666e4fb2e1384c47f34630740f932a545598deade651a6ae9df6f4a3c4e4cf7d261694bb9b0ba57cbe1acbe6fa3dfafcde16f24ef8f5320e3910996c264f845f1e7c550b5d229c63a70fab2338c8a3d7b5d2fa50d3b014d0a189b07b246ebd5fb1b4ad5c315ba179db2e29e6e71ac0292db8d4d08128886b0731259ada1075d8e2862e084ac63f2f35c139c49ec4ac4467ab882efaf3ba3fae3e152c6df3d034e819fd8cc1f0d42d037f365d2af8703a8ffbe839647e8e5a0e6a7954b34b49775cba789d8d0a9084bfa689b889eaeeed9b36ce7b7d008d13627efeb9ded531a36372e8bec5e53cf80c38ad7d2fbd3c3541d6934ffae30fe2bd21e0c15168436f4650a57c02a1a882635b53fc48339ec319dac0f2af4b45bc106bce708073774f1119e8c7e6993a49334c50bfd5f81798adae18425c740719370694ad5b001e10884b31a0c63062dccab5662d6cfcb93db53a7e3a643f8088b5953e433581ce7e17c3edc89667f42a3d3a606e1b786abd0c449dc14c77a15a0bc344dd41c408622b615cb0fa6a5b7850878540aaec55bea43c3136a7075f2f5ee355c17c78e148b7dd17f5923353bbac6de5205c7eae5b74d372be0233996320e92716def71c63f436b771095c3cefb87a3b662590964930979abba389c08cac2fb67e92df6a8f993e92396b71bafb4668fde9d30aafea89a532333f2a3aac1f9ab4c007fd96f296a598bfba3747d50cbbccffcf2d1e0012f8d47811d71adee95eba372bf513742ebede259875750b115a57acb63587ca5201edba003bc5793976a53b914a1c5a6b939fd1d8cb0a7f633ce407b45fde807933361ff5a7c87a702ad03312873542cb9639773c92929edd391c271da3bb27bb00e5d536c7f74cc3b3d618ac73ef88528db311cb21e93140fe5df17958945902bf52c6a2206f87c78e790576bc3a5fa236fd49a177e4e2a5bd016e4aa156d760f2d41cfb70ba8f12a7beb881707d6ab18c9f4206249d60ddac052fb2f7d5f0a282e578c9a2da7a7ad00d8cbd75eeeadcff5365d6c83f4d73ed07aa876468437b480fb812bf3d27f6f0339fc4561c6f1f7ce3124a6add3104d08ad4f496363ef8928f98702d179afdc5707f60099ebc2afd2f3fe0ef6a3b93c0cd1a950a84090e7b09fca98ef3f77eba3ab997d41a4b11b6a5a93dd68b503dbd4f3989ac31847742e5d48ae91089d9ca23530d11bb27aad9706d318d9f176d065696c4221daab7d4e7c2180fb1446dbc76322ec5f9913c4b5289716efd48a71e0727525b99395bafb2123566f0fefd03c93a57efa9b21dfb6645eb25a64408f6ce27eec5ac566a78a0338f60707d7deaca11512d36a4ae4925ca0d682f3e2884b0a459013c71da0ecd65bc89e794ebbdcb8ea62c614269e0b98a6c03d1950fef4c8d6375627c82c2b02a710da0bb507fc29a8572fb8d2c4a5770396f680f8cf4325d2c7b90fad972f9dbea9bb724afc0a877194f2c6042d423e505365494fd1bbe9df83afa90741c6338a2bce8368f586dc63588a3e062159a161e0561088222a5936beac04a7a23e518634f9a8452befec0ad0a88b2d0abd37681f5cf4b09a17c86f4b8b998c67fd15a4656327733d7704c08593c8c0a37745ea56c140358349880c768a29c5d7b00f2754a89849d5f63bfafcab29e6adf0cc7c7e1485917d60b3319170e2ee2b444fdd45356067d635063c929efd42c9fc823f4012e644c8f6ee8e56ec180c86151fe198ca74c3e034f2af57a443290af24d216cb1fc6fad4768e6cf790f55db0abd1da5f2208d806647a95f8c89326bf3a2d53ed09c6e0f5daa62a208e908cf587ce299fb2c4c45ccbfcc4d716c3c729ee1d993d582663ef3f3f030d2e4438a6f9a67b01f6222c109fd8ebc6a0c0d979bb8d85c5c5b9efed3b43565d4a05314256a3d6d8a6bf586b3347e3f8d6c1955e7b19cbeedf76c2151354e690b7d96de38f32ce0fd1665504602bac608626ce28e38c24eafde1e729ebf700251897481b8c606a4f68a755dd7b4bb6e058e58bb57bcfb66cd07cf7a9cbfc6456725d30efbcf907fba90a0fe128f75ea5ceb067583341491ac472313b54ea1532ef24354b50344d8cffb66978657567cdb6a4783cd7ec8dbbdf37b3fa8f7a199c2ae8419cc3ad6f5b4ae31a52ec97799756690d8bbc97800023aabae986b555f2a441dbdbbabb9319e7d6042799ab58eb7050aaf1301a98f9c0a47ecd098221d3e1f24792447cc17d42cb90cab893f3678072be8274901aa337fe3d263420fd3ed936aa75cff97b7c8ea36845bad8cc4535f23ceaf4bb4b7bc9f57705ed938fd7814e2a4d9f70da2d6fcdbc5a49612b4e4de4b230d01ad20bae7c4b23f4724360235874f6a72de14ef4e536c768e2156f2877c4604a953396d980473f1ce4deb28292e5984921934a11eb674c95e1f78a4cf76b31519bc1ae865f01448512b980fa2db58f79b0f719bc8a10f3451c1499ea1a9af5877e6c0b18318c9b1e492a078ceb288b6d580b29e9885193c069ac2582197195aac502bde1587d960091e3eb6e84bd7ec12fb41fc113099b711401567c0de587df2e31d8236e3dccbf13cc7fa997f31cbe10bf443060ccea314595d04e352c2d6573c8a509ef0a48880767826278275b8fa1cfe3b24d2adb72fc5a87f4dedd6bd80dbcf494f63e17c50f08574d3207a3f0cacfc2c8480d0af159206619874699b07a18148271832e9fa4a2cf5d1b49d9bf73ff7c19f0aa898ce0563b7fe175e8d94394a6e0604ab7b5b924e8110c05a9504995d70ccb974a86538c1a48d5b4e08ab87f2b3904832a2633da05f9600d5d9564030a60df6cb30b6b5d1681b66b58104ac82bce99ddc7e134dcc69bd99726060cf1e69f84a5cb16947622c7455ef6bd65713454ed3471de6984a7d796aa5992ecdc1c83edabe7ea987cb83c7f99dd06cb29fd2899041c0215b1e90cffb689637e40b56712d63bced9e89845bfb7801ed5a2bdd1df2fea0153c63972a9edced76f9fe2b038ce703fdea379f9e7c533a92f2245ed700daabe43c46b947613cfd6a55bb0daa6996881940f90f4192c5e93314323cb85be394983a6780bf629cf0ddd4736513497fadcdf2c811820674f0d76f8249d3349285181054f19832f92383b3349db24df417f453f751fb0c2d66d53b86af729236e8727ee7c65ca51f49561aed7d6f766a9fa2ff5e2e000d8a8c23acbf2c346aaae562d3dfce0241f90b13297bae91e3313cf44875ef41b6e26ef8c0f38086e1bb7d6cc257fd1f4aed805a789bbf4776816db2d0fdef4c70a3122b159fa82eb91799a70a824c023ff46b242636cdaffbd156962ccd0935d54c79f8d5529aba6c80ec785a6275f68ad9d91135ae974ed956c10aedd37f39dc19bb38c5e93563af0052a9f3f1f6993766d6adb91a0d73ee25cea92b528276abac4e96e3c5e970ffb7caf8884a5418ce8ef6b989fa542094045823f9899d586ac1b93fb007d71d0696e77ab656012ed287187931b5dd021c49b5233182dcf197a79e489bf1dbeb5371536ac8fd2fb605831b09bdaf3888379c104f19d59a6b9670542803de78ccff4959565812174829c1ba85ef339fdd958bcd9825343fcc6e6eeb648643dac8ef0bdbdf6de21e28db2a1e5f06438329a6405b8c5d6381027470f641ad2d51f108470d045d0b37947c24ac0215dbdb75d5be41c94591a7107d41d6e0ce06a1f9663b670399289b769afcbfd77c5627a7fdc8bbb5b7e600ce331488229b1db8156973eb32d12c838f3d661ebc80a54be1e18437707b6bf3681023e78f1a4b32e85ea4d24a5c4a2ea847fa5cdea43ea47278b8a51e5f2149d929aa21e6d61856bf9496b463a82d52d19c5e0d21016a3ee1a8f151c2303ea637136e754391af8bb07fca5481ae1c1ac63c99e63cd52ebe1329a041ec78e3b96c89349f446f220ba553d0a78f6bb905fb87549170792688e8bd7f1d454291084e6cf4f4fdf43680b0de17ab076d8a3fc0926f6dba75c45359f1178301a4633aefe5e39f6ba5e9f67dd459aabdeb2b0e6d325fa456c93e86866d19837beb4224cb9daed88c9fca6239ffd78a02c33cbfc528e159910269906226dd955683843f9a101d10374961542951a4dacae7775c0a38afa7e72c97d090f9f316c307f369bbe3f1e19a944803103a3863c135a5026ba596a1b93a1143de5000f800f4493d62ec51449321fb8f6d3bbbf31c421218eead0e3f71e61612a5752f1506d3a2aef021b6388db8f16b519c4910a02cb11b12982a04fe8f9d6873e505c6e839b689b21ba38a524122e135e1c8ed8c4c23fb67b78ced6228a4e475d2bec2633985cb4d308c23345ee033097ff2fcc69de4bb26d5fbd123f8f522201259fee3b76d3ae1d49295143d9f8a21225345c551ff788c5e2663d5a050cf756299fa0a0ca52a4120a84c04f9e0c185e9992b50f8c5deb4ed1976eae1d24a38a2a42e18981e2f7c118a26b82ddc060dbd08bddcad922513e4b58af3ed193f98921915f177820225f8094bb0bb50ddd9259038ef685701f32235924a926c25cd7dce6a66215bb7c442cdb7b0688601d8201e9c4ad81062df1db64af6711a7d133c85cd9cc0bfb618482c7e6188be4837484f05bd6ff790b61eee88cf67bd7b6da5771c54eeaf85dada4245833171a9d85281173ea3bf66545e02077d12bed218b4c516d5f51daff762bd25769ecfcda0f2f844e12544b3ff6b77f988d88d3f43bb195101e8356f628e7cdcd7d20ef049e6f2d7921384611d7a47cbebc0d11810d7e6241f8273fc9b519f5db9227da2b2b2f9afa655077446e0176121e2c93769ab49243f6363fcf5667bc2c42383a42ecd5bc301458529bafbe607f77cb1f374ab39636f865a97f9e6a3b0dbdcaf987b6243f335e8efaed1c7b31db89f7ae62e214866b2d5ca44484835a77243db600bdacbbf84d27158daf88fc33644936710cf71eab6aeec7d832e6fd80824afc9a62de88d12c8cdfa03c596a70e94c247f67e0eb508c5f315de501f9f7b246017380f96dee9bded2ea481beef08582b00c10608ddf88fecbfaf48832fb535a505a29007f6ef897626cbe78ecd27edad74624f5552aa3e06f6df34ff9ce4ec50b21818ca597ededc5a6bf302834ca3aa021916237a09fa9fbb90d184f73cd64663043fb397bdf078af7ed3a026d463f03ccc8f1ef995403f03341e6548f9265bc4e92f31ae7234d9fa7c3ba907ce3c45b9f1aea732c355189ea9a8eeb4bafb05d1155d4ca6298df50950383a1a5d0729f98e2d7d61fd145975e9fa2396617d0e8bbabbbf0a5fba51910bb52ede6e038275b59eba07100c9929f80478e09d21344a3e88dd307d09f2103d2f2cd85fb250065ce340e0de404a7e38576783a55f6737bb9fbb66cdab8d83c478e605deb2bd5c84aaa7205efbdd04971fdae27b64d1f62fc53eae9ab02c2edd9b35f029f4b4184889a8c3ed5e08d4692b7c0b6ac280ec19163d91906fae2f599c4ce283b0917aa267bb0ebea4cd085a3d68c5f0bed5862758b573426fb66c06b9129a069af1ae8c8f94ed2fa41d0e85c1c3f8d5746b6da79825c3eb572301c5c9d18e0660340142b99708fe3d2bc2709bba3ec1000166de4c889df40b56266d237dba7e04d63d941265f3d90390d548047602f3955f9668f7e33e03767bff4061167bd885c18c2cf48d082a0d2434ba2746ba559ee53adb09acea3c8aaa26fb10b5caa325111dd123fcb77792995b79d9726c11e3a0b407df6d4fec7a565ec284d1be0c592fc1e90d49167d5209ca06d8c12679d630b37b62150e69850ef090d831667b44bb463ea9fe983755d4b1b461d009ba09ee125aa8253e36bfab57b2340c09c89829f24df53ec5ed0224afe5bc28c947a06f79398d3f8e869c74a397a3f97a3485ab2afcf3a3932fa1393202d31a77bd0c536bd6140c4ec73a65e8457c797f2d85b4a3434420f758ee0e2f52db312f8ceb596d9d159d0753188923441f31cb8b5f47cb2293570d3aa161b3f65e05ee4264cac3914e4fea509d7b4a56e307f134ee0ea46e2d95ea4472cc91e725fea423fd08e34214a44cf73bced81a2dc728989b106ec489fd79f4d110b1c21763a60729691f4d6a0d591131c0351da8da7c90216c84f980537cc74cb1e3c8bed9b9fc9be58bca252ca824a2758d6ef5bbd9a628b090fa4de9a52bceafea30bad4f6282af8c426e4e72af1c4ad4faddc804b63289ca5c652667f9b6e7b2117592d6c6e4dcf6a75cd53749d0db3000b0e5bbe8cdda44928182f282627e6d3e01203bec0e39ec3075cae740de59edaa891224092f81209566452da5d48d23b65e45e3db3e49e5018735af8ce185bf1ab3f688143f18db5e7b16a8dbe123f0f01923f436c1d3b78208c7c2e30005c7c4052133b189067c496ea8ebf6cac387a63a6a7f951edaae1e26589e79ae69dd0a2e7af6c8e95ec58ab4c343eea777759518772ea858025f2e0df572508f081c4a6d87eb3efaa00bd5f9e6fe9e503842edc91f8c7f126a839a3edec8ee4bc2444e05121fe113fca4807adc0b4389e4289d2dad3e9ad7ee39ebc6ffcb00229032f8262729794dd708fce5cee274a2e4872ae4914d6677f6db5155b8537f93ca7c19d5751b2393afaa45789bab1bd0e8070c3b090ea502cdaf583f5a8b981214db94fa20a43ae731c984123664b61d1ecb1b6fb8fca9a70f9644fea6928e92eee065962077c2edc517a6ea6af39fcd9ef6060dd96f6246d3d8eaa1bc34a936fec7448d31a8aeff78ed3adb9b2c12feb93433e41160b403471149c4adb5f2f37fc403a2e41dfb9d0e193aedef325af648b48bf3d4d70088a91776e08e93864ea103ab7f17ab2a5ae65ea19d271924f0317e019697a63d699b777bc038804d5730d87d10ed14cba4c33723564a75349d7e641ad69d2e49f437c8892705646da532edb39547691916bfaf28b20a3a3ff30d45bb11055c54d826e651f440e22f93004328e4b45ce14008b0e396222aecfc0743c2b40e4793e2caf6e79eb00d30740e280306839bb09a6d0c325fbd1b9fa755011eb7749e6fb813251678c2a997a1c9a1a79e3110b54613fe7bace6b79930a2af5e89d8573ba4a30a567f3a79255f098080dfefea0a69f07bc6f405905793ac01d9306c1843c3d67986fd6d8db75e26ccabec7a02cbb8b235427052eed2dbe6c103ab7ca9424e3969490497f4a5560fb0872a326c908c7433e61594e59aadfaecb892e26fac8654f89f6c10086e575e42f410c4537ef2be2877f8b41dacc870d96c6a2332bc142d498b8256ff55f6ec1efd054e4e441868e72a8f89d9e4475121bba72a50c19794e1e453114766152382f56b60fb968d494c1fb5bc9f0d5458cda86f03c902a0a7489549abef2d799f57566de45a81b32079f7e6c530a2d34ea4a982632838e43c46e5b939b209d891fe60fe42bc80291999b91a20dedc2c41f610d477c034f3f91af2499f2e084f91e4e81059e9ac0ccedda885f92b475436b1ce5b1a2f20fd75813c5844107ce9e06dab4a7daebbe0b322f02f350fdaa9b6d0339774e4a6a5275ad9304c3086fdea221dbc42c14bc7f690b7ceb5c8effbad69375454f0e96014f5340ea9a1602218131d252851a0359df8e42cfe398bfb50fedbb923405fc8b20acf7ba19e08d6393ce5385e4882515ed41d773d3eb0d8ecf9606eb2a8d9457c131a02ee6d5e7dfdd4a3ebd0936597b8a16d0c1230708318b077c06cb58fa71cef61cb8109b7f401afa4fb29327db25a53939835ea406e1559bf0169fa6c19cc841e5082bc0e27a267359921db8240312f01280e5efc7875ce7c130dc2a6da02a781cae341f686a472a45b1ab10ada120bb8d5606649c9c1745a06155f6600f18413762979ac1a1025c7ab31649cb3ad4e770208d04fff95142fac38b187880068813a9e40709fa7db8533ec963757a69c723eed2a4a17192154eac9735f587f89d2b6a48ab811543704fa8613ad2f4f2ea94057cfcb53ca361d04d2c854fb260b6a875153ea8ab6a7a832c20bd5579ec94e2376231f78b4916de1dd964fa4741b7d0167940b9c72288652ef4f8dce3bc70bc3eede40c1ee3006375fb27af50cea27e74aee302385209a9665cd9a634ec2a15f9fc12eb148785bbd197ca4c7744ec32cbd4e592baa3e49f2ab2661ee6395cc0b5742d2b0dbf01f394fc4d85fd1bacbb8333abe0d3d1332e2d95e6a4c775f3383c652953b44d098ec81dc93dc9be4445f771b0090cf7afbdb67f9d2c5c9b5a23a7b81f06eb39efaa7165667d822e4aa4172669a7fc3eec7bc2012db267ef6db80b8fbb4ca83ec6ae5594bc5d7417443898b32b0359499f9a2d53988ea77428dbac37392957604044d7abbee99e74f4ee5d4380073e8cd9be1560016145e6a5c05ac49d59cd031715607cbc881895ac27d0a65d0f27e471d8fd63a31b63abdb98bc7ca39bfcde6490c866269f036c6e08b2c8a60d3cadbeaab966d1e4e0184ceac0725d5d874756c0bb49b329491ab0433a8b98cce9deee75314e0f1ee1a9ba7a38a249bf7e84d1cb5187f209b1191265d9402c5c2cf6d02609c90987f19f1d2c522cf67607015c1bea5bcbedfb828d632caf8a34636e3b026ce6e487eee70fe2db9498baafc01a9ec3fa675c5b52e820f4d3330d9ad20a7ef40b969543768028e862ec56fe61e5ffec0407db5764ede18f78b968423b845be11cf6bb42af1983e4231d6ceed416f5f8b807d209b3c84743b636479875ed77ec7ed5114f320eeace53da920c0b8eca0a0198213b11bd990b73a72df998ac15dd8f240b82628731bcba2f04dd9cfa5027f1b79e9f7e21945df89646f68c4075e6d4b2b2e177d0912fb4a1ed707c938a52baa3c722038205814030cd73e6781cc2ffa6a41c4bd39c56781c74127f849e3f3c1f2ab9b72978eba16a0c389c9c2b2bbdf3cab5077faa0b944bf769477fa4a592e89ec0dcc5b6f6911edc08297abb79686073c6de6e08d06c61c9278540a30cecd30d701e8724dfa6ccc2320a26f005fc9eee55f07ab44ebd6c9b2d1ed710bbc0f2633a54c402607b26cca0a2387590981312bb810ba4b7a6839fd289a1eb467ab5aafaddaf2bd4f78fcd6f50d6a8120c42337ba66a4594d43d9d42b3b9bc960ab6261ef5554ae3e22758f4b7f10b4febcff85c77d38492c0b842712f75345d5046e016e119869a90f9b77fef8e8f0cc968a159cadb8b0a9636fcd9b22e0ad88a66e7ccef5bfd48d9bcd83d881842bdf08244f4c6b36e468ceed775ebad9585c4867d2e774f714a60b92d2a73849e6b4c12f4af1f57c1f9194acfaad6e0d5f400bdd7126d9a7767b25544f2def0ae78e1a23ed5c45f46510f47b56b78f20c96fd1546f5c08b95eaab3a5d56c4f536dec6b7769c28f555c89a1c80d055b8b585af51bbcfa11ac5d53bcc41f8edf3b704c1d0022d73a11de66cbd0ee5381022256db198f6e1a06e3ac20e4b9fa473892d878874383bf05cc0089b7c57e16c2f889d072f5065966c4fcad240d41008ec7cb759b26db9f41c168501545af03c16fd0078a0c648a6a2a45e59cb7cf366bbf5b33154224649ff30559e01d23e6c0b8ccffee3d52d70982be07878086a6a93bbe45ee1076a9a450de7d412abc62d6af00030a33d5634d4b189e15336367d31820ef80bd30e41f7586dc09aa4d8e8bcd3dd5d47b3b8396f2301dd8c5700f40f01d1a8eced48fe78392220d11698a954573c2a583b7c438ad6290d7e2bceba555396b8a65974e0a82eb7556d86ab54ff4bb482980ad8cdea3e3d51e9f5b5b5740dc70981065294662f175d73499c2e2d858e085f5c1a0aff7c291c539db7d4bf6c1ec4d52a3ee0b0f43885787c8dc688ba713e794010658e524982ef1b848b3fbabfb40e19c6f714fa5299d01379d2e479e0e03f581ce20a173ba1dc6142f15aceb5c99c97ff26fae8edd377bec2524f6058fa2cb54b921b015e96ce048751512d1c4623c52be93251f2acb49be8ee78e08454225a14f28054c97d8301ab2d8e06e9f85c06ee1deb80c62f96f9f37229676b043efa3b5a10f44f3bbe5bca6d0654e14cead230ac3d7eae4689ec91382d1b69b6be317f3fdae1636213ecd23acdd476f06c0d4820658f3d69eb82e281a7fa204456c1b84aebc305416f23c915fd6641f059804fc8494cbc93880d49d53bed422d1d44e769acd31b87a7f251c3b82f8f2a6f99d51de237f825413e2c33e975f2031a41ef288f8843d06c89adf4a40091a3d2c6ed75a239b733120882e1dac79c17606ea73bcd1d4ed27c98fbb6dd866b177160a6de60764eec45b2145070249e6143ef8cee2981cd9210a035eba9c7b0d0e896a1d13ab02b4d5ac920db18982882468beb431f9b1e93ea67d43a20a4a0c3a1a1803f970238c086c11218ebe620e4c72f61f93acf33090b80e07b2f1fabc6f9303b4b2f4d1ee65a775ace7b4b19f0d5e64036320a0a33492a0f522cdbc436fd687e1661a67b270c51eacc2abd5b6de694ecd021a2e4088e147956dc73b8e14cd9b2dc74c4f6039f48dfb9456f7f4617e5f36c99fb8ee03f93ee086813f110b4064c13d50886faeb000b12ad879caddd8caa58f767350d878be4f32937c0279b44034124ecdb06665b7048c2ac73150cf85592f3a130cd00012b728b8ed5712725acf944bfa969d9b05c977960e6f57e24fd63bfdd498b4040172c1ffcbb92c92b8ba6eb413ae38ed348c4a194802b6d0db9560901ae2f24991e2a0a083d2e6d9d3e9a1e8aceb9804e64a93f96a3975df8e395eb63a8319cea9fbf2b3fea2a70f97d3e4516d75d7d661237170f0e0abf0c8452003be7623d1ab7a556e76d10fc47a873d675b4283437fb3efa268155ffb9c693dc81bd1fc12ce16012d22bd9beba8e96ae1ed671518931478a4aa7a31fc919099c7b3db96079fec9f0c80716a2f20b09ba84af1b2c396dfd777097ed3b0212889c67fda3f01d68435f4557c38a37c8af1e882e2fba385463e66b22ba3ec47304a5184836960eb1dd8672cc6d2baf0a4e4ac7960f55530f62d2420761eb5031972a5101b7eca54833882f164f092fb0e0e7a4730a7107700b405bdbe74c4b0924802dfbce65b98ebe1699da2fa4c7b47a0dd26b768a94c5600dc1e5443d60d6aa355cb05a7ce50dc6094ab698d484ab5f930f283b4925bd7c7fa6d26788e7d2cf375c7f412669b27bd484af9f255d9e84a5842d59b1cabee1e7639dc8653a16e75893bbd6c37d8da85fced37327ec6cf9a4de4fb064edbc1cf2a2d07362f944a258fa9f8cc05f020f00253737a37437ff3f0b67f5ea135634fed34ba1ffd39127e9740e4a91de3dc3d6d235649b55ba24a306a81c5b2afefcc0e12d09bf32127b30d7ef14c4b7bdd9f6fb1dc087cafb017d9f32589db05187f6a49e3fedb4d8dd73f38c124fd992c2ff4393097418d8cc8241d6349cb0dc2552798de24c44a98f8f638f80212f7a61f300ea2ba41904686d14e06b3dfb41af82a1839cbe316247457c2a871a887d7bb89da17f7085e9d1c69f9153167a277bcc6a7d9d632edb61fbc15416634b477ca9e4ed1345be434f708669bcd7b213c0ce32843d0b35799ae8055b6ca89a14c9caa401fa6adcc7aa544c292dc580495f782cac5832820d74e545a91b0bdf6a61fa2ffafbd44e26e101e5db6ff5b928aae25c5c52c8d96bceebc82101051a7981ec32862860577430c5589ce275f3c6ddaf28699adb54b65adea36fb53807006616925beff4bf1ef8449cdb447b06df6fa71d0fe6fb7ac3395681af379f4f97d998a579dff35fdd6e4470ee0e06ff0fc04bd50b1fe270386adb3b845542f90a2f7b7b32733167fb2c9f9dad092fb179554b1b28853c225251297665a3497e488a7af7f6e3732e8cbdf42bf5783415189451a6e0506a2cd5f147a5e06b006c0a83c1713245291cd631d8d60afe586ede61f58906c482745aaac1f99a9ff4427b97426856b7c71b4229bb96cf78c4ac2cba7e4cddc6211d389e9a08898d34a347149f5c4f4f99298bf298c0c92a741dda22329fe96e89d0896c325dd846bcc1f9f882998a66cb5b774a99413c0a90fcdb99fc0fa1819cc6dbc127ba7a551c82fee5ca59e6a3a657f8b90373965b5364fdac9fc1327779270c4c4aedfee3ddf31796cbe7de255442a21cc4e0b521e53578a2f02857bfa0520460871a059d5fe451fbb8840e70a064a8c650c428d79357b3902be7b308d7458d7cc8a8f7a381fa79b43863e936043a6d9f3665706c83b4c97b200e02ba4ab02f064f80f344f39d0ec582a058ce8cdfc90e4059dde74024ca5f36126c741de6effb578d08e2c2c186260691d0d3b395e587cfe2a8931c78b0fbe43345476033ccaf6f6623bf19d7e882e84b6441a39cd2416676c1be79e59ef307300837b2c05a9fa4fd7e164c9d2ead0049564697b0060e6e3dfd1998a30699d80235c75242de277a4df9476d5b9a0d5931a40b45a24d58f63aa7c548ea56c12d9e4fa16b15aeedcb1b302d63b0e20fdd3269680177a6d6c2d33c3b161b4f87775143a7efa9ba49cb2c7fcc56771e2d76900413da0961bc25a37f10da259b42d315672c06a5ef555630d0766afd2d9ef8daad7c3f1bb344337926bc08d3b758213043a69683aecea37829bcfa8f9a1c375ca8a439885273dc2436563c78148165a6e9582e9264baad667dc2be7e036f1430bb01059b7b6c05a10b2b306aff68759a91d82d7761532c4d3fe43af59b131f6c1f53f490eeb392c64a12c64c1461f0eac6aa8963dbff9339e8952b4cd6cb0006ab3d76160dbcede4d863ec73787666f7bca46c452af4fc9bd56c6fd8fc2f2eeded1bded5371c5382051ac7152825ebc9a34c67dcd724798bf511761cff6d28c2cb9801a7c91c451c02967b1dd281baa051271d849363623f969322f65d5fc5913646686e349e1235a6bd74b67c6f41129b32738abe0f3ef302231cbca1a8beabc0fef3441f6e01c44b995c60f78741c49d7efa4aca24e61ba2c02137539f0e3adc376582761484ca72d3ca2e99e7974ffae06e70ace94fe69ea356a27ac35d8d35f71d888cd309d2aa61056c91038c870311e958572d1c5655f37a13ad363b11a7c42c575f372d03273cb4aaa8b3c429c57f10508d9cafe5e729381be4853bee355dcf871142bdc34a6e1dc7998b38a64bd1c741ebe394e5c85b1888f8b81756354c1ba45eec208e7e34f1062225cf7d62802697e091160616f0410517863904ee6287915180e8377fbac3be7d4958442e4953bf2a758d9b044d03ab733212aa3929b4c3c9a2be19f25460b59a6d04774e175b96254f1186daac477cc458b49dac1e316e8c7c5c1defeafa8054eb2bc70a79e291eb14c6a8c36f05c0bb04f84e900990d7d3ac2742596dc77459a72f6090f2d4ca17b823de42bf417ad48007e11bc53892d7715f306c02f6665dc7cf9fe927285622cb5cbf1039cdf18da3e0a821df4783e056b641e6e1aa98167f46634e97f9139eac3141c7901728251c7fa80d4779778e8396bb797f0c7af75d6e78f044af3438b247f2f64f0cb0fbb1eec9b0999407ee5596a76499dc9e02c9b4a51653cd18f048add24619b70f95eb9d2f96b669cda289669816d219902c9434221c8525cbaf97767a366ba04e6740cf18f37de9981b4ae9c6f48ebf54e2498ff589defa9696831f10e8bfc6e5924ddd2f5553ec16170ac57c4a75bd02113676efff62366e3560889b8a3198660e33d72b393a4335dd0653d454367ccadab7d69679afcb2a71a8d362187cb693da3d7af26308fd9a989b350b0c3bac13e01a0a867b47914f0f0fcf8ba56625c828ec58595b1a9c201a0b7d23199dae7fd5af4837e515031780758d8b28cdee0c6860cdc406794e16f387acb327e376c3d7592a87827e2423448f4d583afb08451457c6412b45d7456568fc6e8d2de5d0f265c736072f4459e232669c475a7c3fd6092ee98c101a3a6a2107f18cacdb21a27ca2d64e46ad6b78feea960820842bb4f957067a14a1dfc3425cc4f50d399375387ae10c37ee5864ea77087272ec3647e2e45c4a298e20b68e1a287e49094728981610aba8f64aac99aa50086f986a2f1ba4f0c1c2685443b665a9ce3c9a71ffc468141bedc20cdbd87c6d55b0e69d27ffc0adfba0700666db8e6ae9dcba59b4138b0bdd75d04fdc3156aaa7232803db528ec6372de5f99558862f6aaf8a3606e526979fdb65add17a9a9e8529b716a088c2bdc33523586a9542729809810f768033a748388db560fbee9f07f4f448644ff61a94927f330874e449ebc69bde2de75dba51f9c66ee4087ac784ea37ed374fa691ae7ae7b4896cadc6285e33ed0a9ea0d77da54b9839491381121f899a1a0f89470046fd6bae0aaf176801cbc0ad9e8b84467f06ba861ecc5ec9600c362301af41ba2359358ebe35a1b531cb5228c398890150b9a0697b592e6e7bd1e2e3336e4a7017497aa6795f0aa2a076852db7bfab88c98608d5b50f875fa675dbf4e3342c1d80d84990e35c7d8e24917ec23d170c4cc07d5f27b27f939e004fe9adb5deee9aab427534726e7bd38c8a3064d7a562aa96895d94575ef1553ab2147aee145a2a4543020c4971dae6c57e61f199a3435633a76a5cb77cda7d2042a928e26abb306bbebf4907250d8dbc3b9d5e0d831c6c0128b7bb0beaa33c93a70d16e3449dab235fd3ea842f31f6422f9b216ba560721d78e325149b3116cddb28fceb6c353a11eded0654094f4709c1aea1c9080f3ba8a689bb35f3371ae08a030624b089d5adb7249977a102142879c929ab685ed03bdf49c2aa75d56317c67c7aaae30d6c11954ba5dbfa7015318b9a252a2d2ff47c7230ec4dde68720675fe886357e7af0a8cbe96daa9e111995ca32339003a21bcd377886ef4cbf7e4e052227e732eb045f1dc67ef075e5e2291ee935c129dab5ab9e5d0c9da4618ba5f73b6d57008bdd760f3097a1d88311c27fd2985b14a15d93195a708a930691bccc453448a016231d685e1c8b179710bc5201e54112aeefd9e9675d7ae9a3dcbc923565ceec542a07117b7b7b422c36d280ebe5961b72fbe9592e48731b2db128bfd467ff9fee915e19af6b71c3e657496b91608e03c179efc4e7888de143453a4483039464fbcc6475c9838277f1c4cd3023cccd5c3a16043a8febc763fbecd36ed300e9baf127c8812ffceacfa286f24d7274077b8f2d6c461664b9d463ad53726f01da43aa442dbc0a35968d6c65b2c572d9cc06d38e40d0ee3df9394a16e3dd55664b34f6c61bfc95bfced817d632cbf35015ea8c554cbd9e4c352bfed9d72117881bd8f89d2c9c4a88bb4fd081ec611a7226bad7eb0472adfdcb423d0ff62314599982bb4fcd7212d51ff6b1fb2ccdd8cfa3303019adf55b30240b05eda7a34b584089d6965fea504ed9128a3abc4b8d49feb5293db89d7c14ea4f35feae5c9e2510a9b8f1d7ca713d75edf90e581d1e2151ea16f1830ed931c5fb1d8320d993ade6ec377ace36b0e51642d273cdd2bc61ff090926648d6e9d789711119c059623a6cf9c460f6704d585e87c6209ac791b6a03fe715d9c22049df4ac0734c26a6de94ccf3980a5f28e9c198da45dac05455c6fcc6a6a2d05af897bde8c813023d10f0478d665424fa36834401cdb1a78069673a2a0d95e2baedc141c497a285ff21bc37f5b74c049fb9ff9060c7b9d4e22417ff29a03b593282c2257964e7d37a83dd365f3c7c8e2a18ed0dc83432f2f16e140409513939723a5f1d4b04a51f6d37a89c1327e3107fc855cf7f58fb54fe585c35d050ee61b688034137f6181c003780105b83998eaf35a1a98be86103e6b554ad289b11adc6db46bd00de415605006d014628617956c30411152f7929bf1b3d2deb2fe56d220533dc82c738594c8b477cf79028a8026841c06ac8e6a1d85604c1c41cb982ef21b385734eefa2209106ccf1e28551986739d348970b73160b126ce140455d6351dcab96140bef7393816bdb949ae16d498198f7dc87a5687fc5b42dd960419e3d6d5c6fca76c369f33b081cfc87cea582ba47bad917d92cd9c9adece3ed2941bd57c083d814d7bf84a00a47fdd278f6ab5c02a3ba6da01e1763e57aa50c667d2d277a8a425a92964b1406d8d2eb44b9cb8c23e5d3cad984c814d4d826c9143a7d6b20498b89f0e2fcd88f6d0251eabb1de60a0967d13a9536ce9669500cca55f57de31726b8b29c1229a5221507a68887eb70101245f8ec84df3e587ab5cfdb11c088f07a8c398c06a6326dfaaa1b10e4d6c9a9a4a662917ff05fa58b5f3a4f97c29ef1e40e1ce366985a5ef966defd8343c2bd2673379652fd447ab1e8a709e12440aa55dcf8cad89740211bc3b29d94713755b948635607758226a5e002bf9da3146f194863621f88542839ea15c403457a8 总结你的进步吧！"}]