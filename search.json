[{"title":"对网络的理解","path":"/2025/07/03/对网络的理解/","content":"方面一：垂直分层模型 (The “How” - 数据如何传输) TCPIP 五层模型（或更理论化的 OSI 七层模型）是理解网络的基石。 核心思想： **分而治之 (Divide and Conquer)**。它将一个极其复杂的网络通信过程，切分成了一系列定义清晰、功能独立的层次。每一层都只关心自己的任务，并使用下一层提供的服务，同时向上一层提供服务。 它回答的问题是：“数据包是如何从一台电脑上的应用程序，通过物理介质，最终到达另一台电脑上的应用程序的？” 具体分工： 应用层 (Application Layer): 定义应用程序如何交互。例如，HTTP 协议定义了浏览器如何向 Web 服务器请求页面。 传输层 (Transport Layer): 提供端到端(End-to-End)的通信。例如，TCP 协议确保数据可靠、有序地送达；UDP 协议则提供更快速但不可靠的数据报服务。端口号是这一层的关键。 网络层 (Network Layer): 负责数据包在整个网络中的路径规划和转发。IP 地址是这一层的核心，路由器工作在这一层。 数据链路层 (Data Link Layer): 负责在相邻的两个网络节点之间（例如，您的电脑和家里的路由器之间）传输数据帧。MAC 地址是这一层的关键，交换机工作在这一层。 物理层 (Physical Layer): 负责传输原始的比特流（0和1）。它定义了网线、光纤、无线电波等的物理特性。 这个模型是自底向上构建的，描述了通信的实现机制。 方面二：水平通信架构 (The “Who” - 谁在和谁通信)客户端、服务端、（服务器）等架构，正是这个方面。它描述了网络中各个参与者的角色和关系。 核心思想： **定义角色与交互模式 (Define Roles and Interaction Patterns)**。它不关心数据包如何穿越网络，只关心谁发起请求，谁提供服务，以及它们之间的逻辑关系。 它回答的问题是：“参与通信的各个端点，它们扮演着什么样的角色？” 主要模式： 客户端-服务端架构 (Client-Server, CS): 这是最常见的架构。 服务端 (Server): 被动地等待请求，拥有资源或提供计算能力。通常拥有固定的 IP 地址，并且 7x24 小时在线。 客户端 (Client): 主动地发起请求，消费资源或服务。 特点： 角色分工明确，易于管理和扩展。我们之前讨论的 Web 服务就是典型例子。 对等网络架构 (Peer-to-Peer, P2P): 对等端 (Peer): 网络中没有中心服务器，每个节点既是客户端也是服务器。它们可以直接相互通信，共享资源和服务。 特点： 去中心化，扩展性好，不易产生单点故障。我们讨论的 WebRTC 在建立连接后，其音视频流传输就是 P2P 模式。 这个模型是端到端的，描述了应用的逻辑结构。 两者如何关联？您的理解之所以深刻，是因为您看到了这两个独立但又密不可分的方面。它们的关联在于： 无论采用哪种水平通信架构（CS 或 P2P），其底层的数据传输都必须遵循垂直分层模型（TCPIP）。 一个客户端向服务器发送 HTTP 请求时，这个请求数据会从应用层开始，依次经过传输层、网络层……打包后发送出去。 一个 Peer 向另一个 Peer 发送 WebRTC 的音视频流时，这些数据流（通常封装在 UDP 包里）同样会经过这个垂直分层模型进行传输。 通信的动态过程**通信模式 (Communication Paradigms)**。它描述了数据交换随时间展开的方式。 请求-响应 (Request-Response): 客户端发起请求，然后等待服务器的响应。一次交互就结束了。这是 HTTP 的经典模式。 发布-订阅 (Publish-Subscribe): 一个发布者（Publisher）发布消息，多个订阅者（Subscriber）可以接收到这个消息，而发布者无需知道订阅者是谁。常用于消息队列（如 Kafka, RabbitMQ）。 流式传输 (Streaming): 一旦建立连接，数据会像水流一样持续不断地从一端传输到另一端。例如视频直播、WebSocket 的数据流。 总结 视角 核心问题 关注点 例子 1. 垂直分层模型 数据如何传输？ 协议、封装、路由、物理介质 TCPIP, OSI, HTTP, TCP, IP 2. 水平通信架构 谁在通信？ 角色、关系、逻辑拓扑 客户端-服务器(CS), 对等网络(P2P) 3. 通信模式 数据交换怎样进行？ 交互的动态过程、时间性 请求-响应, 发布-订阅, 流式传输 当分析一个系统（比如 WebRTC）时： 它使用了什么架构？（初始是 CS 获取网页和信令，最终是 P2P 传输媒体） 它的底层遵循什么协议栈？（HTTP, WebSocket, STUN, SRTP 等都运行在 TCPIP 之上） 它的通信模式是什么？（信令是请求-响应或流式，媒体是流式）","tags":["计算机网络","分层模型","通信架构","通信模式"],"categories":["technology","编程基础"]},{"title":"RTCP协议详解","path":"/2025/06/27/RTCP协议详解/","content":"RTCP与RTP一样都是属于应用层的协议，其是RTP的控制协议。包括丢包控制；发送或者接受报告，其中包括上次报告到本次报告中间丢包率，延时等信息。 报文分类 SR和RR报文，分别用于发送和接收报文 SDES,用于描述音视频媒体源。 BYE报文用于说明哪些媒体源已经不可用，应该删除 APP报文，自定义报文 RTPFB,PSFB报文，未搞清楚什么作用。 需要注意这里的报文概念，与SDP，json、xml这类消息概念易混。 其中很重要的一个区别就是RTCP报文是二进制的。 RTCP协议头 重点是count字节，对于不同的报文类型，其含义是不同的。length字节表示整个的RTCP大小。 PT即payload Type","tags":["C++","WebRtc","RTCP"],"categories":["technology","音视频"]},{"title":"RTP协议详解","path":"/2025/06/27/RTP协议详解/","content":"首先要明确一点，RTP属于应用层协议，是架构在UDP之上的。在TCP协议中由于严格的重传机制，以及可靠协议特性，使其难以成为一个实时音视频领域协议。而UDP是一个不可靠协议，它并不严格要求包到达的顺序以及可靠到达，因此实时性最好。但是如何处理网络抖动以及丢包就成了难题，本片文章重点在于RTP是如何解决这些问题的。 UDP 数据报的结构 一个UDP数据报非常简单，它由两部分组成： **UDP头 (UDP Header)**：8个字节，包含源端口、目标端口、长度和校验和。 **UDP数据区 (UDP PayloadData)**：用来存放需要传输的数据。 [ UDP头 | UDP数据区 (用来放东西的地方) ] RTP 如何使用 UDP RTP协议首先构建好自己的数据包： **RTP头 (RTP Header)**：12字节或更多，包含序列号、时间戳等。 **RTP载荷 (RTP Payload)**：实际的音视频数据，比如一小段H.264编码的视频帧。 [ RTP头 | RTP载荷 (音视频数据) ] -- 这整个是一个完整的RTP包 然后，RTP把整个RTP包（RTP头 + RTP载荷）不加改变地，“塞”进了上面提到的 UDP数据区。 最终形成的数据包结构 所以，当数据包在网络中传输时，它的嵌套结构是这样的： +-------------------------------------------------------------------+| IP头 (网络层) || +---------------------------------------------------------------+ || | UDP头 (传输层) | || | +-----------------------------------------------------------+ | || | | 这整个部分是 UDP 的“数据区” / “Payload” | | || | | +----------------------+--------------------------------+ | | || | | | RTP头 (应用层) | RTP载荷 (真正的音视频数据) | | | || | | +----------------------+--------------------------------+ | | || | +-----------------------------------------------------------+ | || +---------------------------------------------------------------+ |+-------------------------------------------------------------------+ 丢包问题在RTP头中会对每个数据包进行编号，因此接收端很容易就可以判断哪些包丢失了，这个字段是sequence number 端口数据类型区分在实际设置中很有可能音频和视频在同一个端口进行输入。因此如何区分两种类型也是一个问题。PayloadType字段，通过该字段的设置可以将不同类型数据区分 exampleP8nbsp–nbsp96 Opus–11 另外，同一端口不仅可以传输不同类型的流，还可以传输哦同一类型，但是不同源的流，这就是上一篇提到的SSRC字段 RTP扩展头通过设置RTP头中的X字段为1可开启扩展头 其中profile是为了区分不同的配置，{0x10，0x0X}和{0xBE,0xDE}分别代表two-byte-header或者one-byte-header节来解析数据。length表示有几个header_extension。 在header-extension中，one-byte-header表示在he中的数据由一个字节的header和N字节的Body组成。而header中有4位的ID和4位的len。 RTP中的填充数据通过设置RTP头的P位可开启填充数据 当RTP中包含填充数据时数据包最后一个字节记录包中填充数据字节个数（包括自己），解包的时候从后往前去掉即可。","tags":["C++","WebRtc","RTP"],"categories":["technology","音视频"]},{"title":"WebRTC中的拥塞控制","path":"/2025/06/27/拥塞控制/","content":"在WebRTC中有多种控制算法，包括GCC,BBR,PCC。GCC又可以根据基于发送端或接收端，分为Transport-CC，Goog-REMB。 Goog-REMB 图中左侧为发送端，控制码流的发送；右侧为接收端，用于拥塞的评估和码流的计算 RemoteBitrate Estimator是接收端延迟拥塞控制算法的管理模块，从网络收发磨矿获取RTP包的传输信息用于拥塞评估。或者将内部评估出的下一时刻的发送码流大小，输出给网络收发模块，从而进行流控。另一方面，它要组织内部的Inter Arrival、OverUser Estimator等模块，根据当前观测到的延时差，和之前的评估指推断出下一时刻的网络拥塞情况 Inter Arrival首先将数据包按照帧分组，然后对相邻的两组数据包进行单项梯度计算。计算内容包括 每组数据包的发送时长 每组数据包的接收时长 两组数据包的大小差 OverUser Estimator利用IA计算出的结果，通过卡尔曼滤波估算出下一时刻发送队列的增长趋势。网络带宽是不断变化的，卡尔曼滤波器能够根据间接测量值，估算出真实结果。因此选用卡尔曼根据数据包时延来对带宽进行估计。 OverUse Detector用于检测当前网路中的拥塞情况，利用OE计算出的队列梯度延时以及自适应阈值进行比较。决定发包量的策略。 AIMD Rate Controller用于计算发送码流的大小，通过OD模块检测出当前网络状态，从而变更自己的状态，并计算出发送码流的大小 原理很简单，我们假设发送码流越大，状态越好。当OD检测出网络质量相比于现在呈上升，趋势，那么状态也上升。反之亦然 Transport CC在这个算法中，将拥塞算法从接收端移到了发送端，将卡尔曼换成了TrendLine GooCcNetworkController同样是对各个模块的控制。会调用子模块评估出下一时刻的网络拥塞状态和码流大小。并将评估出的码流交由Pacer和编码器模块进行码流控制 SendSideBandwidthEstimation比较基于接收端延时与发送端延时评估出的码流值，以及基于丢包，从中选择最小的码流值作为最终 DelayBaseBwe由多个模块构成，用于延时拥塞评估 trendline最小二乘法滤波器，拟合曲线。通过某一时刻线的斜率来判断此时线路是否拥塞，评估下一时刻码流大小 基于丢包的拥塞评估前面已经有两种方法用于拥塞评估，分别是卡尔曼和TrendLine，都是基于延时的。 还有一种基于丢包的，实际上就是通过设置丢包门限来评定此时的网络传输质量。 2%,网络质量很好，可以加大码率 2%x10%,说明网络与发送速率匹配 10%,需要降低码率至（1-0.5丢包率）当前码率 拥塞控制算法","tags":["C++","WebRtc","拥塞控制"],"categories":["technology","音视频"]},{"title":"WebRTC中的SDP规范","path":"/2025/06/26/WebRTC中的SDP规范/","content":"SDP结构1 v=0 2 o=- 3409821183230872764 2 IN IP4 127.0.0.1 3 … 4 m=audio 9 UDP/TLS/RTP/SAVPF 111 103 104 … 5 … 6 a=rtpmap :111 opus /48000/2 7 a=rtpmap :103 ISAC /16000 8 a=rtpmap :104 ISAC /32000 标准SDP规范的规定较为简单，前三行为会话描述，对整个SDP有约束作用；第四行为媒体描述，各个媒体描述之间互不影响。在整个SDP中只能有一个会话描述，但是可以有多个媒体描述。 SDP的描述格式同样较为简单type=valueSDP中的信息webrtc为了实现实时的通信，对标准的SDP做了较大的调整。这里仅展示wR中的SDP内容 会话部分v:协议版本o:会话创建者s:会话名t:会话时长 (下面部分选自李超老师书籍WebRTC音视频技术) 媒体描述 媒体信息在SDP中最重要的内容就是媒体信息。我们看一下 SDP中媒体信息的具体格式，如下所示：m＝＜media＞＜port＞／＜numbers＞＜transport＞＜fmt＞．．． 其中，＜media＞表示媒体类型，可以是audio、video等。 ＜port＞／＜numbers＞表示该媒体使用的端口号。对于WebRTC而言，由于它不使用SDP中描述的网络信息，所以该端口号对它没任何意义。＜transport＞表示使用的传输协议，可以是UDP、TCP等。 ＜fmt＞表示媒体数据类型，一般为PayloadType列表，其具体含义需要使用＂a＝rtpmap：＂属性做进一步阐述。 我们来看一个具体的例子，如代码7．2所示。从代码中可以看到， media的值为audio，表示该媒体的类型为音频；port为9，可以直接忽略，因为WebRTC不使用标准SDP中的网络信息，所以这里的端口也就失去了意义；transport为UDP／TLS／RTP／SAVFP，表示底层使用了哪些传输协议；fmtlist的值为一串从111到126的数字，每个数字代表一个PayloadType，不同的PayloadType表示媒体数据使用了不同的编解码器或编解码器参数。 上面提到的UDP／TLS／RTP／SAVFP，其含义为：传输时底层使用 UDP；在UDP之上使用了DTLS协议来交换证书；证书交换好后，媒体数据由RTP进行传输（RTP运行在UDP之上），保证传输的可靠性；媒体数据（音视频数据）的安全性是由SRTP负责的，即对RTP包中的Body部分进行加密。此外，传输时还使用RTCP的feekback机制对传输信息进行实时反馈（SAVPF），以便进行拥塞控制。代码7．2 媒体信息 1 ...2 m=audio 9 UDP/TLS/RTP/SAVPF 111 103 104 9 0 8 106 105 13110 112 113 1263 ... 通过上面的介绍，我们已经清楚了SDP中的媒体信息是用来做什么的。不过媒体信息不只有上面的这些内容，它还有很多＂$a$＂的属性用来对前面的信息做进一步解释，如每个PayloadType的详细参数就是由它们说明的。音频媒体的描述前面已经介绍过了，但还有很多细节没有介绍。这些细节是无法通过一条＂ $\\mathrm{m}$＂行就能够描述清楚的，必须通过 ＂$ar t p m a p$＂对其做进一步解释才行。如代码7．3所示，在这段代码中，使用大量的＂ $\\mathrm{a}\\mathrm{rtpmap”}$ 属性对＂ $\\mathrm{m}$＂行做进一步阐释。 代码7．3 音频媒体示例 m = audio 9 UDP/TLS/RTP/SAVPF 111 103 104 9 ......a=rtpmap :111 opus /48000/2a=rtcp -fb:111 transport -cca=fmtp :111 minptime =10; useinbandfec =1a=rtpmap :103 ISAC /16000a=rtpmap :104 ISAC /32000a=rtpmap :9 G722 /8000... 这段代码中的第 1 行代码是对音频媒体的描述；第 $3 、 6 、 7 、 8$ 行代码使用＂a＝rtpmap＂解释了PayloadType使用的编解码器及其参数是什么；第 5 行代码＂$af m t p$＂属性指定了PayloadType的数据格式，即音频帧最小 10 ms —帧，使用带内FEC。 在WebRTC的SDP中，＂a＝rtpmap＂＂a＝fmtp＂属性随处可见。无论是音频媒体中，还是视频媒体中，都使用它们对媒体做进一步的解释。 (1) ＂a＝rtpmap＂属性 rtpmap（rtp map），通过字面含义可以知道它是一张 PayloadType与编码器的映射表，每个PayloadType都对应一个编码器。其格式定义在RFC4566中，如下所示：a＝rtpmap：＜payload type＞＜encoding name＞／＜clock rate＞［／＜encodingparameters＞］ 通过上面rtpmap的格式，可以很容易理解代码7．3中第3行代码的含义：Payload Type值为 111 的编码器是Opus，其时钟频率（采样率）为48000，音频通道数为2。同理，PayloadType值为103的编码器是ISAC，采样率为 16000 ；PayloadType值为 104 的编码器也是 ISAC，只不过其采样率变成了 32000 ；PayloadType值为 9 的编码器是G722，采样率是 $8000 . . . . .$. （2）＂ $\\mathrm{a}\\mathrm{fmtp}$＂属性fmtp（format parameters）用于指定媒体数据格式。 ＂$af m t p$＂属性的格式与rtpmap一样也是定义在RFC4566的第6节中，如下所示：a＝fmtp：＜format＞＜format specific parameters＞ 现在再来看一下代码7．3中的第5行代码，它描述了PayloadType值为 111 的数据（Opus数据）：以 10 ms 长的音频数据为一帧，并且数据是经FEC编码的。其中，＂usein bandfec $1$＂是WebRTC针对 Opus增加的fmtp值。如果你想了解这些细节，可以看一下相关的草案。 与音频媒体信息相比，视频媒体信息要复杂一些，在SDP中视频相关的描述如代码7．4所示。 代码7．4 视频媒体 m=video 9 UDP/TLS/RTP/SAVPF 96 ... 102 121 124 ...a=mid:1a=rtpmap :96 VP8 /90000...a=rtpmap :97 rtx /90000a=fmtp :97 apt =96...a=rtpmap :102 H264 /90000...a=fmtp :102 level -asymmetry -allowed =1; packetization -mode =1; profile -level -id =42001f13 a=rtpmap :121 rtx /9000014 a=fmtp :121 apt =10215 ...16 a=rtpmap :124 red /9000017 a=rtpmap :119 rtx /9000018 a=fmtp :119 apt =12419 ... 其中，第 1 行代码为视频的＂ $\\mathrm{m}$＂行，其与音频的＂ $\\mathrm{m}$＂行类似，区别在于两者的媒体类型不同：一个是＂video＂，另一个则是 ＂audio＂。此外，第1行中的PayloadType列表也发生了变化，这个很好理解，视频媒体使用的编码器本就与音频媒体使用的不同。第3行代码表明视频媒体的ID编号为1，而音频媒体的ID编号为0。如果有更多的媒体，编号会一直累加。第 $5 \\sim 18$ 行代码是对不同 PayloadType的解释，下面看一下它们是如何解释PayloadType的吧。 第 5 行代码，PT（PayloadType）值为 96 表示媒体数据使用的编码器是VP8，其时钟频率为 90000 。又因为其排在＂ $\\mathrm{m}$＂行PT列表的第一位，所以它还是视频的默认编码器。同理，代码第 10 行，PT值为102表示媒体数据使用的是H264编码器，时钟频率也是 90000 。 第 7 行代码，PT值为 97 表示的含义与之前 PT值为 96 的情况有所不同，rtx表示的不再是编码器，而是丢包重传。要想弄明白第 7 行代码的含义，必须与第 8 行代码结合着一起看。在第 8 行代码中， apt（associated payload type）的值为 96 ，说明 96 与 97 是关联在一起的，PT＝97是PT＝96的补充。因此第7行代码的含义是：当 WebRTC使用的媒体数据类型（PayloadType）为96时，如果出现丢包需要重传，重传数据包的PayloadType为97。同理，第13～14行代码指明121是PT＝102重传包的PayloadType。 第16～18行代码较为特殊，要想了解这三行代码的含义，你还需要了解一些额外知识：一是red，它是一种在WebRTC中使用的FEC算法，用于防止丢包；二是red编码流程，默认情况下WebRTC会将 VP8／H264等编码器编码后的数据再交由red模块编码，生成带一些冗余信息的数据包，这样当传输中某个包丢了，就可以通过其他包将其恢复回来，而不用重传丢失的包。了解了上面这些内容后，第 $20 \\sim 22$行代码的含义应该就清楚了，即PT值为 124 表示需要使用red对之前编码好的数据再进行 red 处理， 119 是 PT $124$ 重传数据包的 PayloadType。如果用Wireshark等抓包工具抓取WebRTC媒体数据包时会发现它们都是red包，而在red包里装的是VP8／H264编码的数据。 再看一下与 H 264 相关的 fmtp 内 容。第 12 行代码，level－ asymmetry－allowed $1$ 指明通信双方使用的 H264Level是否要保持一致：0，必须一致；1，可以不一致。packetization mode指明经 H264编码后的视频数据如何打包，其打包模式有三种：0，单包；1，非交错包；2，交错包。三种打包模式中，模式0和模式1用在低延时的实时通信领域。其中模式 0 的含义是每个包就是一帧视频数据；模式1的含义是可以将视频帧拆成多个顺序的RTP包发送，接收端收到数据包后，再按顺序将其还原。profile－level－id由三部分组成，即 profile＿idc、profile＿iop以及level＿idc，每个组成部分占8位，因此可以推测出profile＿idc $42$ 、profile＿iop $00$ 、level＿idc $1$ f。关于这几个值的具体含义，如果读者感兴趣，可以自行查看H264规范手册。 以上分析将SDP中视频媒体信息相关的内容及其含义讲解清楚了。音视频媒体信息是SDP中最为重要的内容，读者一定要牢牢掌握。 另外一个媒体描述是SSRC，它是媒体源的唯一标识。需要注意的是，虽然原则上要求每一路媒体流都只有一个唯一的SSRC来标识它。但是我们可以使用 a = ssrc -grou:FID XXXXX MMMMM 不同的ssrc标识符来区分真正的视频流，以及重传的视频流。 SDP的版本标准SDP-PlanB-UnifiedPlan PlanB和Unified的最大的区别是，前者只有两个媒体描述，而如果要穿上多路的音视频流，那么这个时候要使用SSRC来进行区分，而在后这中可以有多个媒体描述，因此对于多路视频的情况只需要拆分成多个媒体描述（“m ”）即可 RTP扩展头通过使用“aexemap”扩展头，在原有的UDP基础上完完成扩展，进行SDP传输 服务质量“artcp-fb”,需要注意的是，这个字段即可以表示RTCP中专门反馈消息的一类消息。二是设置终端支持哪些feedback消息，通过设置编码器，拥塞算法等参数，影响服务质量。","tags":["C++","WebRtc","音视频服务质量"],"categories":["technology","音视频"]},{"title":"提高实时通信中音视频服务质量的方法","path":"/2025/06/23/webrtc中的实时通信增强方法/","content":"实时通信与带宽大小网络质量息息相关，根据香农定理和奈奎斯特定理其实很容易知道，码率、延迟和服务质量本身就是相悖的。而再加上信号传输本身的带宽有限（排除WebRtc中使用的架构），更加难以达到一个均衡。 那么为了提高音视频服务质量又该如何下手呢。有以下五个方面，这篇文章主要记录每个方面的一些重要算法。 增加带宽 减少数据量 适当增加时延 提高网络质量 快速准确评估带宽 增加带宽首先应该提到的肯定不是WebRtc中的一些算法，而是譬如5G网络，星链，新型传输材料，波分复用，时分复用，频分复用，等等通信方向的知识。但这并不在笔者将要探讨的WebRtc框架体系之内。 在WR内，客户端方面主要使用了一种极妙的选路方案来提高整体通信的带宽，即TURN-STUN结构。 STUN-TURN架构减少数据量 压缩算法，通过更好的压缩算法可以实现更高的码率 SVC技术，将视频按照时间、空间、质量分成多层编码、，然后将他们装在同一路发送给服务端，服务端收到后再根据每个用户的带宽情况不同来选择不同的层下发。 simulcast，将视频编码分成多个不同分辨率的多路码流，然后上传至服务端，服务端在根据客户的不同情况来进行下发。 动态码率 甩帧，减少业务， 增加时延实际上增加时延是增加一个缓冲区，先把到来的数据方法队列中缓冲一下，这样的话就可以减少网络抖动造成的卡断、快播、吞音等现象。一般而言对于实时音视频延迟应该控制在500ms以内。 提高网络质量对于网络质量主要有三个影响因素 丢包，优质网络丢包率应该小于2%，对于WR丢包率应该限制在2%-10% 延迟，拥塞 抖动，抖动较小的情况下，可以通过循环队列将其消除，抖动过大就会将乱序包作为丢包处理。在WR中抖动时长不能超过10ms，超过10ms会被视为丢包 解决上面问题的方法： NACKRTX NACK是RTCP的一种消息类型，向接收端报告一段时间内有哪些包丢失了，RTX是指向发送端重新发送丢失包 前向纠错，使用异或方式进行发送，以便在丢包时可以通过这种机制恢复丢失的包 JitterBufer 用于防抖动， 可以将少量乱序包恢复成有序 NetEQ 用于音频的防抖动","tags":["C++","WebRtc","音视频服务质量"],"categories":["technology","音视频"]},{"title":"SIMPLEST_FFMPEG_PLAYER源码阅读","path":"/2025/06/10/SIMPLEST_FFMPEG_PLAYER源码阅读/","content":"对于FFmpeg的使用中，理解各个结构体的作用至关重要。 解协议（http,rtsp,rtmp,mms） AVIOContext，URLProtocol，URLContext主要存储视音频使用的协议的类型以及状态。URLProtocol存储输入视音频使用的封装格式。每种协议都对应一个URLProtocol结构。（注意：FFMPEG中文件也被当做一种协议“file”） AVIOContext是FFmpeg中用于执行输入输出操作的抽象层，提供协议层之上的抽象接口，它负责处理数据流的读写和定位，而不需要知道底层数据的来源，因此可以处理本地，网络，内存缓冲区多个流来源。这个结构体包含了读写缓冲区的指针，缓冲区的大小，当前读写位置，和读写位置的指针（这些具体的指针指向集体的协议实现）等 在古早版本的FFmpeg中UP用于定义和注册不同的底层协议（如file\\http\\rtp\\tcp\\udp等），每个这样的结构体中都包含了针对该协议的一组回调函数（如url_open\\url_read\\url_read\\url_write\\url_seek\\url_close等）。但是在现代的FFmpeg中这个东嗯那个已经更多的整合和抽象进入AC中了。 同样的在古早版本中，UC是UP的一个具体实例，用于存贮某个已经打开协议连接的上下文信息。但是在新版的FFmpeg中这个结构也已经被整合到了AC中 解封装（flv,avi,rmvb,mp4） AVFormatContext主要存储视音频封装格式中包含的信息；AVInputFormat存储输入视音频使用的封装格式。每种视音频封装格式都对应一个AVInputFormat 结构。 在阅读雷博士写的播放器的时候能够轻易地发现这个结构体是一个很重要的结构体，它不仅是用于解封装到解码中间，在其他地方也是可以看到的。但是在这个结构体中实际上并没有什么很复杂的信息。只有类似音视频流的个数，音视频流，时长，比特率之类的东西。以及显示音视频流（文件）的源信息 解码（h264,mpeg2,aac,mp3） 每个AVStream存储一个视频音频流的相关数据；每个AVStream对应一个AVCodecContext，存储该视频音频流使用解码方式的相关数据；每个AVCodecContext中对应一个AVCodec，包含该视频音频对应的解码器。每种解码器都对应一个AVCodec结构。AVStream1. 这个结构体可以理解成为媒体文件中的轨道信息。AVCodecContex1. 这个结构体在编码和解码中都有应用，用于存储编解码器的上下文实例2. 解码过程，用于存储和接收编码器配置，打开一个媒体文件时候FFmpeg会从文件头部解析出视频流的编码参数，包括像视频宽度高度，像素格式，时间基准，音视频采样率等。另外配置编码器选项，跳帧策略，线程数，错误隐藏策略，是否允许多线程解码。传递压缩数据和接收原始数据： 会把压缩后的 AVPacket （例如一个H.264 NALU）传递给 AVCodecContext 对应的解码器（通过 avcodec_send_packet）。解码器处理后，会从 AVCodecContext 对应的解码器中读取解码后的 AVFrame （例如YUV像素数据或PCM采样数据，通过 avcodec_receive_frame）。3. 编码过程。首先还是设置编码参数，包括输入原始视频的尺寸和格式，编码器的时间基准，B帧最大数量等。配置编码选项，例如一些预设和调优，编码速度，编码模式等。传递原始数据和接收压缩数据： 你会把原始的 AVFrame （例如YUV像素数据或PCM采样数据）传递给 AVCodecContext 对应的编码器（通过 avcodec_send_frame）。编码器处理后，你会从 AVCodecContext 对应的编码器中读取压缩后的 AVPacket （例如H.264 NALU或AAC帧，通过 avcodec_receive_packet）。4. 这个接口一般是应用程序和底层编解码算法之间的桥梁，FFmpeg由此提供了统一的接口来配置不同的编解码器。有关于其他参数的解析还是看一下雷博士的博客。AVCodec1. AVCodec代表了一个具体的已经注册的编码器算法，它是一个只读的结构体，包含着这个编码器本身的静态通用信息，和能力。以及只想内部实现函数的指针。一般通过avcodec_find_decoder或者avcodec_find_encoder来获取这样一个指针。可以理解这是一个解码算法所提供的指针。2. 要注意AC的存储是以一个全局的注册列表形式（可能是一个链表或是其他的数据结构）实现的。由于FFmpeg时支持多种音视频编解码的这些编解码器在编译时可以被静态链接，作为共享库进行动态加载，允许 FFmpeg 在运行时动态地查找和选择合适的编解码器。3. AVCodec 定义了编解码器的抽象接口（例如 decode, encode, init, close 等函数指针）。具体的编解码器实现（例如 libx264、libvpx、libfdk_aac 等第三方库或 FFmpeg 内部实现）则通过 AVCodec 结构体将自己注册到 FFmpeg 中。这种设计使得 FFmpeg 核心库无需知道所有编解码器的具体实现细节，只需通过统一的 AVCodec 接口来调用它们。 存数据 视频的话，每个结构一般是存一帧；音频可能有好几帧 解码前数据：AVPacket1. 这个结构体比较简单，都是一些时间戳，大小之类的数据，解码后数据：AVFrame 1. AF中包含了多个码流参数，其中又以data数组为核心，主要是存储原始数据。在data数组中对于packed和planar数据的存储格式是不一样的。 2. 在AVPictureType结构体中IBP较为常见，但是要注意S\\SI\\BI\\BP帧类型，S 帧是一种特殊的编码帧，它本身是帧间预测的（像 P 帧），但它的预测信息（运动矢量、残差）可以被后续的 I 帧或 P 帧作为参考。SI 帧是一种特殊的 I 帧。它所有的宏块都是帧内编码的（像 I 帧一样），所以它是一个独立的帧，不依赖其他帧进行预测。 它的主要作用也是提供随机访问点，但它通常是为了更快速、更鲁棒的切换而设计。与普通的 I 帧相比，SI 帧可能在编码方式或解码端处理上有一些特定优化，以确保在它这里可以立即开始一个新的解码序列。BI 帧是一种非常特殊的帧，它包含的宏块全部是帧内编码的（就像 I 帧），但它却像 B 帧一样，既可以被向前参考，也可以被向后参考。SP 帧是一种特殊的 P 帧。它的大部分宏块都是帧间预测的（像 P 帧），但它的预测信息（运动矢量、残差）可以被后续的 I 帧或 P 帧作为参考。 3. qscale_table，网上绝大部分关于这个结构体的论述都是搬得雷博士的，需要注意宏块在视频帧指的是一个矩形块，而QP值其实是QP_step的一个索引，规定了宏块的采样步数，这个索引表是可以被查到的。 4. 另外以及像运动矢量和运动估计参考帧都比较容易理解接下来是以雷博士做的SIMPLEST_FFMPEG_PLAYER为例（注意是第一版），在上面添加注释，详细分析每个语句的作用，以及视频播放器的工作流程。 /** **核心流程：****FFmpeg 部分：*** 初始化 FFmpeg 库。* 打开视频文件并查找视频流。* 查找并打开视频解码器。* 分配用于存储解码帧和转换后YUV帧的内存。* 初始化 SWS_Scaler (用于图像格式转换)。**SDL 部分：*** 初始化 SDL 库。* 创建 SDL 窗口、渲染器和纹理。**主循环：*** 从视频文件中读取数据包 (`AVPacket`)。* 将数据包发送给解码器 (`avcodec_decode_video2`)。* 如果解码器成功解码出图像 (`got_picture` 为真)，则：* 使用 SWS_Scaler 将解码后的帧转换为 YUV420P 格式。* （可选）将 YUV420P 数据写入文件。* 使用 SDL 更新纹理、清空渲染器、复制纹理到渲染器并呈现，从而显示视频帧。* 延时一小段时间以控制播放速度。* 刷新解码器（处理剩余的帧）。* 释放所有分配的资源并退出。**//** * 最简单的FFmpeg播放器 2 * Simplest FFmpeg Player 2 * * 作者：雷霄骅 Lei Xiaohua.注释作者：yahei * 版本2：使用SDL 2.0取代了版本1中的SDL 1.2。 * Version 2 use SDL 2.0 instead of SDL 1.2 in version 1. * * 本程序实现了一个视频文件的解码和显示（支持HEVC, H.264, MPEG2等）。 * 这是一个最简单的FFmpeg视频解码方法。 * 通过学习这个示例可以初步了解FFmpeg的解码流程。 * This software is a simplest video player based on FFmpeg. * Suitable for beginner of FFmpeg. * */#include cstddef#include stdio.h// 宏定义，确保stdint.h中的常量宏可用，例如UINT64_C#define __STDC_CONSTANT_MACROS// 根据操作系统类型包含不同的头文件路径#ifdef _WIN32// Windows 平台extern C // 声明为C风格链接，因为FFmpeg和SDL库是C语言编写的#include include/libavcodec/avcodec.h // 包含FFmpeg编解码器库头文件#include include/libavformat/avformat.h // 包含FFmpeg封装格式库头文件#include include/libswscale/swscale.h // 包含FFmpeg图像缩放/格式转换库头文件#include SDL2/SDL.h // 包含SDL2库头文件;#else// Linux 或其他类Unix平台#ifdef __cplusplus // 如果是C++编译器，使用extern Cextern C#endif#include libavcodec/avcodec.h#include libavformat/avformat.h#include libswscale/swscale.h#include SDL2/SDL.h#ifdef __cplusplus;#endif#endif// 宏定义：是否将YUV420P数据输出到文件// 如果定义为1，则会将解码并转换后的YUV420P数据写入output.yuv文件// 如果定义为0，则不写入文件#define OUTPUT_YUV420P 0int main(int argc, char* argv[]) // FFmpeg 相关的结构体指针 AVFormatContext *pFormatCtx; // 封装格式上下文，包含了文件的整体信息（如流的数量、时长等） int i, videoindex; // i用于循环，videoindex用于存储视频流的索引 AVCodecContext *pCodecCtx; // 编解码器上下文，包含了编解码器操作所需的所有参数（如宽度、高度、像素格式等） AVCodec *pCodec; // 编解码器，代表一个具体的编解码器（如H.264解码器） AVFrame *pFrame, *pFrameYUV; // pFrame用于存储解码前的数据包（原始数据），pFrameYUV用于存储解码后并转换为YUV420P格式的帧 uint8_t *out_buffer; // 用于存储转换后YUV420P数据的缓冲区 AVPacket *packet; // 数据包，存储从文件中读取的压缩数据（如H.265或H.264帧） int y_size; // Y分量的大小，用于计算YUV数据的总大小和写入YUV文件 int ret, got_picture; // ret用于接收函数返回值，got_picture指示是否解码出一张完整的图片 // SWS_Scaler 上下文，用于图像格式转换（例如从解码器的原生像素格式转换为YUV420P） struct SwsContext *img_convert_ctx; // 输入文件路径 char filepath[] = bigbuckbunny_480x272.h265; // 要播放的视频文件路径 // SDL 相关变量 int screen_w = 0, screen_h = 0; // 屏幕（窗口）的宽度和高度 SDL_Window *screen; // SDL 窗口对象 SDL_Renderer* sdlRenderer; // SDL 渲染器，用于在窗口上绘图 SDL_Texture* sdlTexture; // SDL 纹理，用于存储YUV数据并渲染到屏幕 SDL_Rect sdlRect; // SDL 矩形，定义纹理在窗口上的显示区域 FILE *fp_yuv; // 用于输出YUV文件时的文件指针 // FFmpeg 初始化 av_register_all(); // 注册所有可用的编解码器、复用器/解复用器等组件 avformat_network_init(); // 初始化网络模块，如果需要处理网络流（例如HTTP, RTSP等） pFormatCtx = avformat_alloc_context(); // 分配一个AVFormatContext结构体 // 打开输入流（文件或网络流） // avformat_open_input 负责打开媒体文件并读取其头部信息 if (avformat_open_input(pFormatCtx, filepath, NULL, NULL) != 0) printf(Couldnt open input stream. ); // 如果文件无法打开，打印错误信息 return -1; // 查找输入流信息 // avformat_find_stream_info 负责读取媒体文件的一部分，填充pFormatCtx中的流信息（nb_streams, streams等） if (avformat_find_stream_info(pFormatCtx, NULL) 0) printf(Couldnt find stream information. ); // 如果无法找到流信息，打印错误信息 return -1; // 找到视频流的索引 videoindex = -1; // 视频流索引初始化为-1（未找到） for (i = 0; i pFormatCtx-nb_streams; i++) // 遍历所有流 // 检查当前流的类型是否为视频流 if (pFormatCtx-streams[i]-codec-codec_type == AVMEDIA_TYPE_VIDEO) videoindex = i; // 找到视频流，记录其索引 break; // 退出循环 if (videoindex == -1) printf(Didnt find a video stream. ); // 如果没有找到视频流，打印错误信息 return -1; // 获取视频流的编解码器上下文 pCodecCtx = pFormatCtx-streams[videoindex]-codec; // 从视频流中获取其对应的AVCodecContext // 找到视频解码器 // avcodec_find_decoder 根据编解码器ID（pCodecCtx-codec_id）找到对应的解码器 pCodec = avcodec_find_decoder(pCodecCtx-codec_id); if (pCodec == NULL) printf(Codec not found. ); // 如果没有找到解码器，打印错误信息 return -1; // 打开解码器 // avcodec_open2 负责打开解码器，并为它分配必要的资源 if (avcodec_open2(pCodecCtx, pCodec, NULL) 0) printf(Could not open codec. ); // 如果无法打开解码器，打印错误信息 return -1; // FFmpeg 内存分配 pFrame = av_frame_alloc(); // 分配一个AVFrame结构体，用于存储解码后的原始帧数据 pFrameYUV = av_frame_alloc(); // 分配一个AVFrame结构体，用于存储转换为YUV420P格式后的帧数据 // 计算YUV420P格式的图像数据所需的大小，并分配缓冲区 out_buffer = (uint8_t *)av_malloc(avpicture_get_size(PIX_FMT_YUV420P, pCodecCtx-width, pCodecCtx-height)); // 将分配的缓冲区与pFrameYUV关联起来，avpicture_fill会设置pFrameYUV-data和pFrameYUV-linesize // 注意：在FFmpeg 4.0+版本中，PIX_FMT_YUV420P 已被 AV_PIX_FMT_YUV420P 取代 avpicture_fill((AVPicture *)pFrameYUV, out_buffer, PIX_FMT_YUV420P, pCodecCtx-width, pCodecCtx-height); packet = (AVPacket *)av_malloc(sizeof(AVPacket)); // 分配一个AVPacket结构体，用于存储从文件中读取的压缩数据包 // 输出文件信息 printf(--------------- File Information ---------------- ); av_dump_format(pFormatCtx, 0, filepath, 0); // 打印媒体文件的详细信息到控制台 printf(------------------------------------------------- ); // 初始化SWS_Scaler上下文，用于图像格式转换 // 从解码器输出的原始像素格式（pCodecCtx-pix_fmt）转换为YUV420P格式 // SWS_BICUBIC 是一个常用的缩放算法 img_convert_ctx = sws_getContext(pCodecCtx-width, pCodecCtx-height, pCodecCtx-pix_fmt, pCodecCtx-width, pCodecCtx-height, AV_PIX_FMT_YUV420P, SWS_BICUBIC, NULL, NULL, NULL);// 如果定义了OUTPUT_YUV420P宏，则打开YUV文件#if OUTPUT_YUV420P fp_yuv = fopen(output.yuv, wb+); // 以二进制写模式打开output.yuv文件#endif // SDL 初始化 // 初始化SDL视频、音频和定时器子系统 if (SDL_Init(SDL_INIT_VIDEO | SDL_INIT_AUDIO | SDL_INIT_TIMER)) printf(Could not initialize SDL - %s , SDL_GetError()); // 初始化失败，打印错误信息 return -1; screen_w = pCodecCtx-width; // 设置窗口宽度为视频宽度 screen_h = pCodecCtx-height; // 设置窗口高度为视频高度 // 创建SDL窗口 // SDL_WINDOWPOS_UNDEFINED 表示窗口位置由系统决定 // SDL_WINDOW_OPENGL 提示使用OpenGL渲染 screen = SDL_CreateWindow(Simplest ffmpeg players Window, SDL_WINDOWPOS_UNDEFINED, SDL_WINDOWPOS_UNDEFINED, screen_w, screen_h, SDL_WINDOW_OPENGL); if (!screen) printf(SDL: could not create window - exiting:%s , SDL_GetError()); // 窗口创建失败，打印错误信息 return -1; // 创建SDL渲染器 sdlRenderer = SDL_CreateRenderer(screen, -1, 0); // 创建SDL纹理 // SDL_PIXELFORMAT_IYUV 指定纹理的像素格式为IYUV (即YUV420P) // SDL_TEXTUREACCESS_STREAMING 表示纹理数据会频繁更新 sdlTexture = SDL_CreateTexture(sdlRenderer, SDL_PIXELFORMAT_IYUV, SDL_TEXTUREACCESS_STREAMING, pCodecCtx-width, pCodecCtx-height); // 设置SDL矩形，定义纹理在窗口上的显示区域 sdlRect.x = 0; sdlRect.y = 0; sdlRect.w = screen_w; sdlRect.h = screen_h; // SDL 初始化结束---------------------- // 主循环：读取、解码和显示视频帧 // av_read_frame 从输入流中读取一个AVPacket while (av_read_frame(pFormatCtx, packet) = 0) // 检查当前数据包是否属于视频流 if (packet-stream_index == videoindex) // 解码视频包 // avcodec_decode_video2 将压缩的AVPacket解码为AVFrame（原始帧） // got_picture 会在成功解码出完整图像时设置为非0 ret = avcodec_decode_video2(pCodecCtx, pFrame, got_picture, packet); if (ret 0) printf(Decode Error. ); // 解码错误 return -1; if (got_picture) // 如果成功解码出了一张完整的图片 // 图像格式转换 // sws_scale 将pFrame中的图像数据转换为YUV420P格式，并存储到pFrameYUV中 // pFrame-data 和 pFrame-linesize 包含原始帧的像素数据和行步长 // 0 表示从图像的第0行开始转换 // pCodecCtx-height 是图像的高度 // pFrameYUV-data 和 pFrameYUV-linesize 接收转换后的YUV数据和行步长 sws_scale(img_convert_ctx, (const uint8_t* const*)pFrame-data, pFrame-linesize, 0, pCodecCtx-height, pFrameYUV-data, pFrameYUV-linesize); // 如果定义了OUTPUT_YUV420P宏，则将YUV数据写入文件 #if OUTPUT_YUV420P y_size = pCodecCtx-width * pCodecCtx-height; // Y分量大小 fwrite(pFrameYUV-data[0], 1, y_size, fp_yuv); // 写入Y分量数据 fwrite(pFrameYUV-data[1], 1, y_size / 4, fp_yuv); // 写入U分量数据 (YUV420P中U/V是Y的1/4大小) fwrite(pFrameYUV-data[2], 1, y_size / 4, fp_yuv); // 写入V分量数据 #endif // SDL 渲染部分--------------------------- #if 0 // 这是一个旧的SDL_UpdateTexture用法，通常用于YUV数据的更新 SDL_UpdateTexture( sdlTexture, NULL, pFrameYUV-data[0], pFrameYUV-linesize[0] ); #else // 使用SDL_UpdateYUVTexture更新YUV纹理，更适合YUV420P三平面格式 SDL_UpdateYUVTexture(sdlTexture, sdlRect, pFrameYUV-data[0], pFrameYUV-linesize[0], // Y分量数据和行步长 pFrameYUV-data[1], pFrameYUV-linesize[1], // U分量数据和行步长 pFrameYUV-data[2], pFrameYUV-linesize[2]); // V分量数据和行步长 #endif SDL_RenderClear( sdlRenderer ); // 清空渲染器 // 将纹理复制到渲染器，NULL表示复制整个纹理到整个sdlRect定义的区域 SDL_RenderCopy( sdlRenderer, sdlTexture, NULL, sdlRect); SDL_RenderPresent( sdlRenderer ); // 更新屏幕显示 // SDL 渲染部分结束----------------------- // 延时以控制播放速度，这里简单固定延时40ms，约每秒25帧（1000ms / 40ms = 25帧） SDL_Delay(40); av_free_packet(packet); // 释放当前AVPacket的内存，准备读取下一个 // 刷新解码器（处理解码器中剩余的帧） // 在文件末尾，解码器内部可能还缓存了一些帧，需要通过不断调用解码函数直到没有更多帧输出 // 此时packet参数可以设置为NULL或一个空packet while (1) ret = avcodec_decode_video2(pCodecCtx, pFrame, got_picture, NULL); // 注意这里 packet 为 NULL if (ret 0) // 解码错误或没有更多数据 break; if (!got_picture) // 没有解码出新的图像 break; // 对剩余的帧进行格式转换和显示 sws_scale(img_convert_ctx, (const uint8_t* const*)pFrame-data, pFrame-linesize, 0, pCodecCtx-height, pFrameYUV-data, pFrameYUV-linesize); #if OUTPUT_YUV420P int y_size=pCodecCtx-width*pCodecCtx-height; // 重新计算y_size，虽然这里应该和之前一样 fwrite(pFrameYUV-data[0],1,y_size,fp_yuv); // Y fwrite(pFrameYUV-data[1],1,y_size/4,fp_yuv); // U fwrite(pFrameYUV-data[2],1,y_size/4,fp_yuv); // V #endif // SDL 显示剩余帧 SDL_UpdateTexture( sdlTexture, sdlRect, pFrameYUV-data[0], pFrameYUV-linesize[0] ); // 修正，这里应该用 SDL_UpdateYUVTexture SDL_RenderClear( sdlRenderer ); SDL_RenderCopy( sdlRenderer, sdlTexture, NULL, sdlRect); SDL_RenderPresent( sdlRenderer ); SDL_Delay(40); // 释放资源 sws_freeContext(img_convert_ctx); // 释放SWS_Scaler上下文#if OUTPUT_YUV420P fclose(fp_yuv); // 关闭YUV输出文件#endif SDL_Quit(); // 退出SDL子系统 av_frame_free(pFrameYUV); // 释放YUV帧的内存 av_frame_free(pFrame); // 释放原始帧的内存 avcodec_close(pCodecCtx); // 关闭编解码器上下文 avformat_close_input(pFormatCtx); // 关闭输入流上下文 return 0; // 程序成功退出","tags":["C++","FFmpeg"],"categories":["technology","音视频"]},{"title":"CMakeLists中的常见字段","path":"/2025/06/07/CMakeLists常见字段/","content":"CMakeLists.txt 中的核心是一系列的命令（commands）和变量（variables）。通过这些命令，我们向 CMake 声明项目的各种特性和构建规则。 以下是一些 CMakeLists.txt 中最常见和重要的“字段”（或者说，命令和变量）： 核心项目配置命令 cmake_minimum_required(VERSION major.minor [FATAL_ERROR]) 作用： 指定项目所需的最低 CMake 版本。这是每个 CMakeLists.txt 文件的第一行。它确保你的项目不会在旧版本的 CMake 上编译，旧版本可能不支持你使用的某些命令或特性。 示例： cmake_minimum_required(VERSION 3.10) project(PROJECT_NAME [LANGUAGES language...] [VERSION major[.minor[.patch[.tweak]]]]) 作用： 定义项目的名称。这是顶级 CMakeLists.txt 中仅次于 cmake_minimum_required 的第二条命令。它也可能指定项目支持的语言（如 CXX, C, Fortran）和版本。 示例： project(simplest_ffmpeg_player CXX VERSION 1.0) 源文件、目标和依赖管理 add_executable(target_name [source1] [source2] ...) 作用： 定义一个可执行目标。这是最常见的命令之一，它告诉 CMake 将指定的源文件编译并链接成一个可执行程序。 示例： add_executable(my_app main.cpp helper.cpp) add_library(target_name [STATIC | SHARED | MODULE] [source1] [source2] ...) 作用： 定义一个库目标。你可以指定它是静态库 (STATIC)、动态库 (SHARED) 还是模块库 (MODULE)。 示例： add_library(my_static_lib STATIC static_func.cpp) add_library(my_shared_lib SHARED shared_func.cpp) target_sources(target [PRIVATE|PUBLIC|INTERFACE] source1 [source2] ...) 作用： 向一个已存在的 target 添加源文件。当源文件很多或需要根据条件添加时，这个命令比直接在 add_executableadd_library 中列出更灵活。 示例： target_sources(my_app PRIVATE main.cpp) target_include_directories(target [PRIVATE|PUBLIC|INTERFACE] [dir1] [dir2] ...) 作用： 指定某个目标（可执行文件或库）的头文件搜索路径。 PRIVATE：只影响当前目标本身的编译。 PUBLIC：影响当前目标本身的编译，也影响链接到此目标的任何其他目标。 INTERFACE：只影响链接到此目标的任何其他目标。 示例： target_include_directories(my_app PUBLIC $CMAKE_SOURCE_DIR/include) target_link_libraries(target [PRIVATE|PUBLIC|INTERFACE] [item1] [item2] ...) 作用： 指定某个目标需要链接的库。这可以是其他 CMake 目标，也可以是外部库。链接顺序在某些情况下很重要。 示例： target_link_libraries(my_app PRIVATE my_shared_lib Qt5::Widgets) add_subdirectory(source_dir [binary_dir] [EXCLUDE_FROM_ALL]) 作用： 包含另一个子目录中的 CMakeLists.txt 文件。这对于组织大型项目结构非常有用。 示例： add_subdirectory(src) 变量和属性设置 set(variable value [CACHE type docstring [FORCE]]) 作用： 设置 CMake 变量的值。变量在 CMake 脚本内部使用，可以存储路径、选项等。CACHE 选项用于创建用户可以在 CMake GUI 或命令行中配置的缓存变量。 示例： set(SOURCE_FILES main.cpp) set(CMAKE_CXX_STANDARD 17) (设置C++标准，这是一个重要的内置变量) set(BUILD_SHARED_LIBS ON CACHE BOOL Build shared libraries FORCE) option(variable Help string [initial value]) 作用： 创建一个布尔选项，用户可以在 CMake 配置时启用或禁用。 示例： option(BUILD_TESTS Build unit tests ON) 查找包和依赖 find_package(PackageName [version] [REQUIRED] [COMPONENTS comp1 comp2...] [OPTIONAL_COMPONENTS comp3...] [NO_MODULE] [NO_CONFIG]) 作用： 查找并加载外部依赖包（如 Boost, OpenCV, Qt 等）。如果找到，它会设置一些变量（如 PackageName_FOUND，PackageName_INCLUDE_DIRS，PackageName_LIBRARIES）或导入目标（如 Qt5::Widgets）。 示例： find_package(SDL2 REQUIRED) 条件和循环控制流 if (...) ... elseif (...) ... else (...) ... endif() 作用： 条件语句，根据条件执行不同的命令。 示例： if(WIN32) message(Building on Windows)elseif(UNIX) message(Building on Unix-like system)endif() foreach(loop_var item1 [item2 ...] ) ... endforeach() 作用： 循环遍历列表。 示例： set(MY_SOURCES a.cpp b.cpp c.cpp)foreach(src_file $MY_SOURCES) message(Processing $src_file)endforeach() 其他常用命令 message([STATUS|WARNING|AUTHOR_WARNING|FATAL_ERROR|CHECK_START|CHECK_DONE|CHECK_FAIL] message to display) 作用： 在 CMake 配置过程中输出信息到控制台。对于调试和用户提示非常有用。 示例： message(STATUS Configuring $PROJECT_NAME project...) file(GLOB variable [LIST_DIRECTORIES true|false] [RELATIVE path] [pattern1] [pattern2] ...) 作用： 查找匹配给定模式的文件，并将结果存储到变量中。常用于收集源文件。 示例： file(GLOB SOURCE_FILES src/*.cpp src/*.c) 注意： 虽然方便，但 file(GLOB) 在某些情况下可能不是最佳实践，因为它不处理文件删除的情况（需要重新运行 CMake）。更推荐显式列出源文件或使用 target_sources。 install(...) 作用： 定义项目的安装规则，例如将可执行文件、库、头文件安装到系统目录或指定目录。 示例： install(TARGETS my_app DESTINATION bin)install(DIRECTORY include/ DESTINATION include)","tags":["C++","编程基础","CMake"],"categories":["technology","编程基础"]},{"title":"音视频传输","path":"/2025/06/01/音视频/","content":"刚刚开始学习音视频相关的知识，在搜索学习资料的时候发现这个方向做的最多开源的是一位博士生雷霄骅。但是雷博士已经去世，这里表达敬意。文章记录从雷神的博客中自己理解的知识，其中有摘抄的博客内容 视频播放器原理视频播放器拓扑结构 解协议的作用，就是将流媒体协议的数据，解析为标准的相应的封装格式数据。视音频在网络上传播的时候，常常采用各种流媒体协议，例如HTTP，RTMP，或是MMS等等。这些协议在传输视音频数据的同时，也会传输一些信令数据。这些信令数据包括对播放的控制（播放，暂停，停止），或者对网络状态的描述等。解协议的过程中会去除掉信令数据而只保留视音频数据。例如，采用RTMP协议传输的数据，经过解协议操作后，输出FLV格式的数据。解封装的作用，就是将输入的封装格式的数据，分离成为音频流压缩编码数据和视频流压缩编码数据。封装格式种类很多，例如MP4，MKV，RMVB，TS，FLV，AVI等等，它的作用就是将已经压缩编码的视频数据和音频数据按照一定的格式放到一起。例如，FLV格式的数据，经过解封装操作后，输出H.264编码的视频码流和AAC编码的音频码流。解码的作用，就是将视频/音频压缩编码数据，解码成为非压缩的视频/音频原始数据。音频的压缩编码标准包含AAC，MP3，AC-3等等，视频的压缩编码标准则包含H.264，MPEG2，VC-1等等。解码是整个系统中最重要也是最复杂的一个环节。通过解码，压缩编码的视频数据输出成为非压缩的颜色数据，例如YUV420P，RGB等等；压缩编码的音频数据输出成为非压缩的音频抽样数据，例如PCM数据。视音频同步的作用，就是根据解封装模块处理过程中获取到的参数信息，同步解码出来的视频和音频数据，并将视频音频数据送至系统的显卡和声卡播放出来。 流媒体协议 封装格式 视频编码 音频编码 名称 推出机构 推出时间 目前使用领域 LDAC Sony Corporation 2015 高分辨率无线音频传输，主要应用于索尼耳机播放器与安卓设备之间（需要设备支持） 关于LDAC的补充说明： 高分辨率音频传输： LDAC是索尼开发的一种音频编码技术，旨在通过蓝牙连接传输高分辨率（Hi-Res Audio）音频。它能够传输比传统蓝牙编解码器（如SBC）更高码率的数据，从而在无线传输中保留更多的音频细节。 码率： LDAC支持多种传输码率，最高可达990 kbps（在最佳连接条件下），这远高于SBC（最高约328 kbps）和aptX HD（576 kbps）。 应用场景： 主要用于索尼自家的音频产品（如WH-1000XM系列耳机、Walkman播放器）以及支持LDAC的安卓智能手机。它是安卓8.0（Oreo）及更高版本系统中的一个标准蓝牙音频编解码器。 局限性： 尽管LDAC能够传输高码率音频，但其传输质量受限于蓝牙连接的稳定性。在复杂的无线环境下，码率可能会自适应下降以维持连接。此外，其使用范围主要集中在索尼和安卓生态系统内，苹果iOS设备目前不支持LDAC。 与传统编码器的区别： 与你表格中列出的AAC、MP3、AC-3、WMA等主要用于音频文件存储和流媒体分发的编码器不同，LDAC更侧重于无线传输过程中的高质量编码，尤其是在蓝牙这个带宽有限的载体上。AAC、MP3等通常是音频文件的格式，而LDAC是传输协议的一部分，用于将这些格式的音频数据通过蓝牙高效传输。 什么是RTSP（流媒体协议）RTSP的组成RTSP是一个实时的传输协议，是一个应用层的协议，包RTSP协议，RTP协议，RTCP协议。 RTSP协议主要是负责建立服务器和客户端之间的请求和相应，建立通信链路。 RTP协议是负责在服务器和客户端进行传输数据， RTCP协议四负责提供RTP传输质量的反馈，确保RTP传输的质量。 三者的关系：RTSP不会发送媒体数据，知识完成服务器和客户端之间的信令交互，RTP协议负责媒体数据传输，RTCP负责RTP数据包的监视和反馈，RTP和RTCP并没有规定传输层的类型，可以选择UDP或者是TCP，RTSP则要求是基于TCP。总体来说，RTSP是建立在RTP和RTCP之上的。 RTSP的过程一次基本的RTSP操作过程是，首先，客户端线连接到流媒体服务器，并发送i个（DESCRIBE）。流服务器通过一个SDP描述来进行反馈，反馈信息包括流数量，媒体类型等信息，客户端在分析描述符后 ,并为每个流发送SETUP命令，这个命令来告诉服务器，客户端用于接收媒体数据的端口，流媒体连接建立完成后，客户端发送i个播放命令PLAY服务器就可以在UDP上传送媒体流，RTP包到客户端，在播放过程中客户端还可进行快进，快退，等操作。 RTSP与HTTP的关系 RTSP引入了几种新的方法，比如DESCRIBE、PLAY、SETUP 等，并且有不同的协议标识符，RTSP为rtsp 1.0,HTTP为http 1.1； HTTP是无状态的协议，而RTSP为每个会话保持状态； RTSP协议的客户端和服务器端都可以发送Request请求，而在HTTPF协议中，只有客户端能发送Request请求。 在RTSP协议中，载荷数据一般是通过带外方式来传送的(除了交织的情况)，及通过RTP协议在不同的通道中来传送载荷数据。而HTTP协议的载荷数据都是通过带内方式传送的，比如请求的网页数据是在回应的消息体中携带的。 使用ISO10646(UTF-8) 而不是ISO 8859-1，以配合当前HTML的国际化； RTSP使用URI请求时包含绝对URI。而由于历史原因造成的向后兼容性问题，HTTP1.1只在请求中包含绝对路径，把主机名放入单独的标题域中； RTSP协议格式文章 在client和server的连接中，还需要使用SDP描述符，连接中有关于SDP的协议说明。 TS封装或者FLV封装编码视频帧内编码视频编码词用压缩技术来减少码率，而压缩的理论依据主要来源于： 数据冗余，通过关联图像中的各像素，来实现无损压缩 视觉冗余，在人眼的可分辨范围外通过引入客观失真来实现有损压缩。 变换编码：首先将源图像切割，然后对切割后的小块进行DCT变换，这个小块叫做宏块，在对图像块经过DCT变换后的系数进行量化，在传送过程中只传递一部分数据。实现有损压缩。实现有损压缩。 视频帧间编码采用运动估计和运动补偿的方法来实现，第一步还是实现图像分割，然后在前一图像或者后抑恶图像某个搜索窗口的范围内未每一一个图像块寻找最为相似的图像块，通过计算这两个图像块的变换关系得到运动矢量。将两个图像块相减得到残差图像。前一个过程叫做运动估计，后一个过程叫做运动补偿。 编码器算法视频编码器能够自主的比较帧内预测和帧间预测的结果，选择出最佳结果，即模式选择。并且编码器应该对每个宏块能做出如下处理： 后向预测（使用未来的帧） 前向预测（使用过去的帧） 无帧间预测，仅帧内预测 完全跳过（帧内或帧间预测） 同时为了提高视频压缩质量，引入I帧、P帧、B帧。 I帧只使用本帧内数据编码，不需要考虑消除时间序列相关性。P帧使用前面的I帧或P帧来做运动估计和补偿。B帧使用前面的一个I帧或P帧，或后面一个I帧或P帧；来进行预测。使用B帧可以实现高压缩比。但是如果P帧和参考B帧遭到破坏，其他所有依赖于它们的帧就不能完整解码，这会直接导致视频故障。视频通常无法从此类问题中恢复。然而，当被破坏的视频流到达I帧，因为I帧被独立地编码解码，所以视频问题可以从I帧恢复。 在H264中图像以序列为单位进行组织，一个序列是一段图像编码后的数据流。 一个序列的第一个图像叫做IDR 图像（立即刷新图像），IDR 图像都是 I 帧图像。H.264 引入 IDR 图像是为了解码的重同步，当解码器解码到 IDR 图像时，立即将参考帧队列清空，将已解码的数据全部输出或抛弃，重新查找参数集，开始一个新的序列。这样，如果前一个序列出现重大错误，在这里可以获得重新同步的机会。IDR图像之后的图像永远不会使用IDR之前的图像的数据来解码。 一个序列就是一段内容差异不太大的图像编码后生成的一串数据流。当运动变化比较少时，一个序列可以很长，因为运动变化少就代表图像画面的内容变动很小，所以就可以编一个I帧，然后一直P帧、B帧了。当运动变化多时，可能一个序列就比较短了，比如就包含一个I帧和3、4个P帧。 在视频编码序列中，GOP即Group of picture（图像组），指两个I帧之间的距离，Reference（参考周期）指两个P帧之间的距离。两个I帧之间形成一组图片，就是GOP。 下面重点解释一下B帧预测的逻辑。 我们用一个简化的模型来描述 B 帧的预测过程。假设我们有一个 GOP 结构，例如：I B B P B B I。 当编码器处理某个 B 帧时，例如，在 P1 和 P2 之间的 B1 帧：P1 --- B1 --- P2 B帧的预测通常涉及以下步骤： 确定参考帧列表 (Reference Picture Lists)： 每个 B 帧在编码时会维护两个参考帧列表： List 0 (L0)： 包含在其显示时间戳之前的参考帧（通常是 I 或 P 帧）。 List 1 (L1)： 包含在其显示时间戳之后的参考帧（通常是 I 或 P 帧）。 这些参考帧可以是比当前 B 帧更早或更晚解码的 IP 帧。例如，对于 B1，P1 位于 L0，P2 位于 L1。 宏块或子块级别预测：B帧的预测是以宏块（Macroblock，16x16 像素）或更小的子块为单位进行的。对于当前 B 帧中的一个宏块： a. 向前预测 (Forward Prediction)： 编码器在 List 0 中的参考帧（例如 P1）中搜索与当前宏块最相似的区域。 找到最相似的区域后，计算出**运动矢量 (Motion Vector, MV)**，这个 MV 指示了从参考帧中的哪个位置到当前宏块位置的位移。 记录下这个运动矢量和对应的预测残差（当前宏块与向前预测结果的差异）。 b. 向后预测 (Backward Prediction)： 编码器在 List 1 中的参考帧（例如 P2）中搜索与当前宏块最相似的区域。 计算出另一个运动矢量 (MV’)。 记录下这个运动矢量和对应的预测残差。 c. 双向预测 (Bi-directional Prediction)： 这是 B 帧特有的强大功能。编码器会尝试结合 向前预测的结果 和 向后预测的结果 来生成一个更准确的预测。 加权平均： 最常见的方法是对向前预测和向后预测的结果进行加权平均。例如，如果 B1 刚好位于 P1 和 P2 的中间，可能会对两个预测结果各取 50% 进行叠加。 选择更好的预测模式： 编码器会比较三种预测模式（向前、向后、双向）产生的预测残差大小，选择残差最小的模式。残差越小，说明预测越准确，需要编码的数据量就越少。 编码残差和运动信息： 无论选择哪种预测模式，B 帧最终编码的都是预测残差（当前宏块的实际像素值与预测结果之间的差异）以及用于预测的运动矢量和参考帧索引。 由于预测残差通常包含的能量非常小（因为预测得很准确），所以经过变换、量化和熵编码后，数据量会非常小。 举例说明 假设我们有三帧画面，编码顺序和显示顺序可能如下： 显示顺序： F1 (I) - F2 (B) - F3 (P) - F4 (B) - F5 (P) 解码顺序（为了先解码参考帧）： F1 (I) - F3 (P) - F2 (B) - F5 (P) - F4 (B) 我们聚焦在 F2 (B帧) 如何编码： 解码 F1 (I帧)： F1 是一个完整的独立帧，不依赖其他帧。 解码 F3 (P帧)： F3 依赖 F1 进行预测。编码器从 F1 中找到 F3 各个宏块的相似区域，记录下运动矢量和残差。 解码 F2 (B帧)： F2 知道它在显示顺序上介于 F1 和 F3 之间。 对于 F2 中的一个宏块： 向前预测： 编码器在 F1 中找一个最像的块，记录 MV。 向后预测： 编码器在 F3 中找一个最像的块，记录 MV’。 双向预测： 将 F1 的预测块和 F3 的预测块进行平均或加权平均，形成一个双向预测块。 编码器会比较这三种方式的预测残差大小。例如，如果 F2 上的一个物体是从 F1 运动到 F3 过程中的中间位置，那么双向预测往往能得到最小的残差。如果 F2 上的一个静止背景在 F1 和 F3 中都有，那么向前或向后预测就足够了。 最终，F2 编码并存储：哪个预测模式、哪个参考帧（L0或L1）、运动矢量、以及实际的预测残差。 音频编码同样在音频方向也包括有损压缩和无损压缩。有损即去掉弱音信号或者去掉人耳听觉范围外的频率（20Hz||20KHz）. 关于音频的采样量化等方法以传统的PCM为例。 常见的无损方法： FLAC (Free Lossless Audio Codec): 目前最流行的无损音频编码格式，开源、免费。 APE (Monkey’s Audio): 另一种流行的无损格式，但解码复杂度较高。 ALAC (Apple Lossless Audio Codec): 苹果开发的无损格式，用于其生态系统。 WavPack (WV): 灵活的混合模式无损格式。 DSDDSFDFF: 用于高解析度音频的特殊无损格式，不完全是 PCM 编码。 有损方法较多，后面再详细学习，这里只聊一下AAC。 AAC编码文件格式文件有两种： ADIF：Audio Data Interchange Format 音频数据交换格式。这种格式的特征是可以确定的找到这个音频数据的开始，不需进行在音频数据流中间开始的解码，即它的解码必须在明确定义的开始处进行。故这种格式常用在磁盘文件中。 ADTS：Audio Data Transport Stream 音频数据传输流。这种格式的特征是它是一个有同步字的比特流，解码可以在这个流中任何位置开始。它的特征类似于mp3数据流格式。这种格式可以用于广播电视。 简言之。ADIF只有一个文件头，ADTS每个包前面有一个文件头。","tags":["音视频传输","RTSP","音视频编解码"],"categories":["technology","音视频"]},{"title":"MCP中的细节问题","path":"/2025/05/23/MCP/","content":"MCP协议以及其中的客户端和服务器 首先附上up画的对我启发极大的一张图片。这张图片中讲了各大部件之间的关系。 从MCP协议为起点，MCP（Model Context Protocol），即模型上下文协议，正是这样一个旨在解决大型语言模型（LLM）与外部世界交互问题的开放标准。 MCP采用客户端-服务器（Client-Server）架构模式： Host（主机）LLM 应用： 代表大型语言模型应用程序，例如Claude Desktop、Cursor等，它们是发起连接的一方。 Client（客户端）： 在Host应用程序内部负责与MCP服务器建立连接，其实可以理解成Agent与MCP协议的集合。 MCP Server（MCP服务器）： 这是MCP系统中最关键的环节。它是一个程序，提供工具和数据访问能力供LLM使用。MCP服务器可以作为本地应用运行在用户设备上，也可以部署到远程服务器。每个MCP服务器都提供一组特定的工具（Tools）、资源（Resources）和提示（Prompts）： 1. 工具（Tools）： 供AI模型调用的函数或操作，例如查询数据库、发送邮件、执行代码等。在面对一些没有提供程序接口的软件的时候，可以考虑写一些Py脚本或者命令行工具来实现我们的需求，例如打开项目文件，修改模型参数，运行仿真，提取仿真结果等。另外一种方式，时可以选择一些自动化的GUI库，这样的话就需要很多OCR的token了2. 资源（Resources）： 供用户或AI模型使用的上下文和数据，例如API回复、文件内容等。3. 提示（Prompts）： 用于完成特定任务的预定义提示模板。当LLM需要获取信息或执行操作时，它会通过MCP客户端向MCP服务器发送请求。MCP服务器会与相应的外部数据源或工具进行交互，获取数据并按照MCP协议规范进行格式化，最后将格式化后的数据返回给LLM。 回到上图，由于这个协议是用来规范Agent和各种tools之间的通信，调用格式规范的，由此可以将客户端的开发与服务器的开发分离开。因此开发可以分成三个大部分， 大模型部分的工作与RAG架构第一个部分是大模型部分，包括微调、如何设计一个专用模型，如何减少幻觉、目前的RAG架构如何进行优化等等工作。 简单介绍一下RAG架构 想象一下，LLM就像一个博览群书但只活在“过去”的人（因为它的知识截止于训练数据）。RAG给它配了一个“实时图书馆管理员”和一套“搜索工具”。 RAG核心思路：当用户提出一个问题时，RAG不是直接让LLM回答，而是分两步走： 检索 (Retrieval)： 从一个外部知识库（你的“实时图书馆”）中找出与用户问题最相关的几段信息。 增强生成 (Augmented Generation)： 将这些检索到的信息和用户的问题一起喂给LLM，让LLM基于这些“上下文”来生成答案。 RAG架构详解与举例：假设你正在研究一个新的相控阵天线设计，并且你有一个内部的技术文档库，里面包含了最新的天线设计规范、材料特性和仿真结果。 用户问题： “最新的MIMO相控阵天线设计中，氮化镓（GaN）材料的关键优势是什么？” 第一步：知识库准备 (提前进行)这是RAG的基础，你需要把你的“实时图书馆”整理好。 文档收集： 收集所有相关的技术文档、研究论文、设计规范等。 Chunking (分块)： 概念： 大文档被分割成更小的、有意义的文本片段，称为“Chunk”（块）。 目的： LLM的输入有长度限制（上下文窗口），而且太大的块会稀释关键信息。把文档切成小块，可以更精准地检索。 举例： 你的一篇关于GaN材料特性的长论文，会被切分成多个Chunk，例如： Chunk 1: “GaN在射频（RF）应用中的基本特性和历史…” Chunk 2: “GaN在MIMO相控阵天线中的功率密度和效率优势…” Chunk 3: “GaN与其他半导体材料（如GaAs）的对比…” Chunk 4: “GaN器件的散热挑战和解决方案…” 切分策略： 可以按句子、段落、固定长度（带重叠）等方式切分。对于技术文档，考虑语义完整性很重要。 Embedding (嵌入)： 概念： 将每个文本Chunk转换成一个高维的数字向量（一串数字），这个向量能够捕捉Chunk的语义信息。语义相似的Chunk，它们的Embedding向量在向量空间中也会靠得很近。 技术： 使用专门的Embedding模型（例如OpenAI的text-embedding-ada-002，或者开源的BERT、Sentence-BERT等模型）来完成。 举例： Chunk 1的Embedding向量：$[0.1, -0.5, 0.3, …, 0.8]$ Chunk 2的Embedding向量：$[0.15, -0.48, 0.32, …, 0.79]$ (与Chunk 1在向量空间中距离较近，因为都与GaN相关) Chunk 3的Embedding向量：$[0.6, 0.2, -0.1, …, 0.9]$ (与前两个距离较远，主题不同) 存储： 这些Embedding向量会被存储在一个向量数据库（Vector Database，如Pinecone, Weaviate, Milvus, ChromaDB等）中，以便快速检索。 第二步：实时查询 (当用户提问时) 用户问题Embedding： 当用户提出问题 “最新的MIMO相控阵天线设计中，氮化镓（GaN）材料的关键优势是什么？” 时，首先会使用与Chunk Embedding相同的Embedding模型将这个问题也转换成一个Embedding向量。 举例： 问题的Embedding向量：$[0.12, -0.51, 0.31, …, 0.81]$ 向量相似度搜索 (Retrieval)： 将用户问题的Embedding向量与向量数据库中所有Chunk的Embedding向量进行比较。 寻找语义上最相似的Chunk（即向量距离最近的Chunk）。 举例： 向量数据库会找出 Chunk 2 (“GaN在MIMO相控阵天线中的功率密度和效率优势…”) 和其他几个与GaN或MIMO相关的Chunk，因为它们的向量与问题向量距离最近。通常会检索Top-K个（比如Top-3或Top-5）最相关的Chunk。 增强生成 (Augmented Generation)： 将检索到的相关Chunk的原文内容（不是Embedding向量）和用户的问题一起打包成一个Prompt，发送给LLM。 Prompt结构示例： 请根据以下提供的信息，回答用户的问题：---信息1：[Chunk 2 的原文内容] GaN在MIMO相控阵天线中的功率密度和效率优势使其成为关键材料。其高击穿电压和电子迁移率，使得GaN器件能够工作在更高的频率和功率水平，从而实现更紧凑、更高性能的天线模块...信息2：[Chunk 5 的原文内容] 此外，GaN在高温下的稳定性也优于其他半导体材料，这对于MIMO天线在高功率运行时的散热设计至关重要...---用户问题：最新的MIMO相控阵天线设计中，氮化镓（GaN）材料的关键优势是什么？ LLM接收到这个“增强”后的Prompt，它现在不仅有自己原有的知识，还有了来自外部知识库的最新、最具体的信息。 LLM结合这些信息进行理解、推理和生成，给出更准确、更专业的答案。 LLM的最终回答： “在最新的MIMO相控阵天线设计中，氮化镓（GaN）材料的关键优势体现在其高功率密度、高效率以及在高温下的卓越稳定性。GaN的高击穿电压和电子迁移率使其能在更高频率和功率水平下运行，从而实现更紧凑、高性能的天线模块。此外，其优异的热稳定性对高功率MIMO天线的散热设计至关重要。” 但是就像我之前读过的一个知乎大佬所写的文章所说的，能不自己部署模型，就不自己部署。 自己部署的硬件成本和维护成本，对于小团队来说，很可能是压垮骆驼的一座大山。 Agent开发第二个是Agent的开发部分，也就是客户端部分，关于这部分已经写过一些内容了。 这里还应该注意的是，由于MCP协议，其实不需要关注agent输入与输出的设计，只需要根据不同的业务场景选择，Agent的输出究竟选择JSON格式还是选择使用Prompt格式即可，如何设计Prompt也就成了重点。 服务器部分第三个是服务器部分，未来会在这个方向做一些探索。 这里包含很多的部分，像Tools的设计，也就是如何根据业务场景写一个函数的库来供Agent进行调用。另外在写库函数时要格外注意docstr的书写，函数变量的命名，这里其实和Prompt设计有异曲同工之妙了。 最后，一些思考。关于整套架构，其中的工具设计是比较容易做到的（除了大模型部分的算法部分），但是如何为MCP的落地提供应用场景就成了难事，巨大的token耗费成本极大的限制了应用场景，如何落地呢？","tags":["MCP","AI"],"categories":["technology","AI"]},{"title":"C++中的STL标准库","path":"/2025/05/05/STL_r1_output/","content":"C++ STL标准库源码解析与设计思想 最近在学习侯捷老师关于STL源码的解析（以GNU 2.9实现为例），本文记录核心知识点与设计哲学 一、STL六大组件全景图 STL主要分成了六个部分，其中包括容器，迭代器，分配器，算法，仿函数以及一些适配器。在学习STL之前应该首先对泛型编程以及对象编程有清晰的认识，对象编程倾向于设计一个Class类，实现一个具备自身数据和自身功能的一个整体，并提供复用的接口。泛型编程广泛的应用了模板的相关知识，通过模板参数T或者Foo来分别设计函数和数据的具体实现。对于不同版本的库文件，各家的编写方式也不尽相同，例如VC库文件和GNU库文件。同时由于标准规范存在，代码能够有较好的可移植性 STL（Standard Template Library）由以下六大核心组件构成： 容器（Containers）：管理数据的集合（如vector、list、map） 迭代器（Iterators）：泛化的指针，提供容器元素的访问接口 分配器（Allocators）：内存管理的底层实现（如std::alloc） 算法（Algorithms）：通用算法（如sort、find） 仿函数（Functors）：行为类似函数的对象（如lessT） 适配器（Adapters）：组件接口转换器（如stack、queue） 容器主要分成关联式和序列式容器，对于序列是容器能够支持一些排序等操作。而关联式容器支持快速的查找工作在学习容器部分的时候应该格外关注他们的底层实现，这关乎于不同算法的实现效率，另外以及内存占用情况，以及容器内部定义的可以调用的一些基本函数。注意容器内部定义的一些函数和全局定义的函数的区别，例如find、sort等函数。 对于vector是使用三个指针进行控制，头部指针，内容尾部指针，以及内存尾部指针。vecotr的迭代器，不必设计成一个类。 deque是使用分段连续实现前后端均可以扩充对于deque的迭代器，使用四个属性进行控制。cur.first.last,node,deque的底层索引表也是通过vector来写的，进行二倍增长 stack 和queue的底层都是采用qeque来实现的。两者都不允许进行遍历，那么就是不提供迭代器 不同的容器其本身由于包括了多个迭代器，其指针等其本身就占用多个字节，例如deque占用40个字节，其内容要根据动态分配分配内存。需要注意的是，deque查找等动作，都需要首先检查指针是否已经在边界，进行索引表的步进，然后进行具体查找。 红黑树和散列表是关联式容器实现的关键。红黑树是一种平衡的二元搜寻树。不应该使用迭代器改变红黑树的元素值。因为红黑树内部有一定的排序规则。红黑树有多个参数，其中包括key，value，KeyOfValue,compare,alloc。红黑树内部有两种插入方式，包括insert_equal和insert_unique 二、容器实现深度解析2.1 序列式容器 容器 底层结构 关键特性 vector 动态数组 三指针控制：start, finish, end_of_storage deque 分段连续+索引表 迭代器含cur, first, last, node指针 list 双向链表 节点含prev, next, data指针 vector内存增长示例： vectorint v;v.push_back(1); // 容量1v.push_back(2); // 容量2（翻倍）v.push_back(3); // 容量4（再次翻倍） 2.2 关联式容器graph TD A[关联式容器] -- B[红黑树实现] A -- C[哈希表实现] B -- set/multiset B -- map/multimap C -- unordered_set C -- unordered_map 红黑树关键特性： 每个节点非红即黑 根节点必须为黑 红色节点的子节点必须为黑 任意节点到叶子的路径包含相同数量黑节点 三、迭代器设计哲学3.1 迭代器核心接口templateclass Tstruct iterator typedef T value_type; typedef ptrdiff_t difference_type; typedef T* pointer; typedef T reference; typedef random_access_iterator_tag iterator_category;; 迭代器是一种泛化的指针。要注意迭代器内部操作符重载的写法，例如++操作符、*、等重载的具体实现。另外以及iterator中的设计原则，iterator必须提供五种Type。这些参数在 iterator 头文件中通过 iterator 结构体定义，并在自定义迭代器时需要用到。这五个参数按顺序分别是： value_type: 迭代器所指向的元素的类型。通过迭代器，我们可以访问到容器中存储的元素，而 value_type 就定义了这些元素的类型。例如，对于 std::vectorint::iterator，其 value_type 就是 int。 difference_type: 用于表示迭代器之间距离的类型。通常情况下，这个类型是带符号的整型，例如 std::ptrdiff_t。它可以用来计算两个迭代器之间的元素个数。例如，如果你有两个指向 std::vectorint 中不同元素的迭代器 it1 和 it2，那么 it2 - it1 的结果类型就是 difference_type。 pointer: 指向 value_type 的指针类型。通常情况下，它是 value_type*。这个类型在某些迭代器（例如原始指针迭代器）中直接使用。 reference: 指向 value_type 的引用类型。通常情况下，它是 value_type。当我们通过解引用迭代器（使用 * 运算符）访问元素时，得到的就是一个 reference 类型的对象。 iterator_category: 描述迭代器所支持的操作的标签类型。STL 定义了五种主要的迭代器类别，它们之间存在着功能上的包含关系： std::input_iterator_tag: 只支持单向读取操作，即只能使用 *it 读取元素，并使用 ++it 使迭代器前进。输入迭代器通常用于单次遍历的输入流。 std::output_iterator_tag: 只支持单向写入操作，即只能使用 *it = value 写入元素，并使用 ++it 使迭代器前进。输出迭代器通常用于单次遍历的输出流。 std::forward_iterator_tag: 支持输入迭代器的所有操作，并且可以多次遍历容器中的元素。这意味着你可以保存一个前向迭代器的副本，并在之后再次使用它从相同的位置开始遍历。 std::bidirectional_iterator_tag: 支持前向迭代器的所有操作，并且可以双向移动，即可以使用 --it 使迭代器后退。std::list、std::set 和 std::map 等容器的迭代器通常是双向迭代器。 std::random_access_iterator_tag: 支持双向迭代器的所有操作，并且提供随机访问的能力。这意味着你可以像操作数组指针一样，使用 it + n、it - n、it[n] 以及比较运算符（、、=、=）在常数时间内访问任意位置的元素。std::vector、std::deque 和数组的迭代器都是随机访问迭代器。 3.2 迭代器分类与能力 迭代器类型 支持操作 典型容器 随机访问迭代器 ++, --, +n, -n, [] vector, deque 双向迭代器 ++, -- list, setmap 前向迭代器 ++ forward_list 输入输出迭代器 单次遍历 istream, ostream 对于STL的容器等部件实际上是一个类模板，而算法实际上是一个函数的模板。另外函数一般会有多个重载方式，通过参数类型、数量等来区分。算法只会接收迭代器，看不到容器，所以它所需要的所有信息必须从迭代器中获得，而迭代器必须能够回答算法的所有问题。 四、算法与仿函数协作机制4.1 算法模板示例template class InputIterator, class TInputIterator find(InputIterator first, InputIterator last, const T value) while (first != last *first != value) ++first; return first; 仿函数（functors），仿函数是通过设计一种类通过重载小括号来近似实现函数的功能，是为算法进行服务的，分别有算术类，逻辑运算类，以及相对关系类。例如针对自定义的一种类，来定义一种独特的排序方式。 再STL中规定了每个Adaptor都应该挑选一个适配者继承，因为在函数应用到仿函数的时候很有可能会询问仿函数一些基础参数问题，因此需要像迭代器那样，给它一个继承的身份。 4.2 仿函数与适配器算术仿函数示例： template class Tstruct plus : binary_functionT, T, T T operator()(const T x, const T y) const return x + y; ; 适配器应用场景： // 将普通函数转换为仿函数ptr_fun(my_function); // 绑定参数bind2nd(lessint(), 40); 五、内存管理：分配器实现5.1 GNU 2.9 allocator设计class __malloc_alloc_template // 一级分配器 static void* allocate(size_t n) /* 直接调用malloc */ ;class __default_alloc_template // 二级分配器 enum __ALIGN = 8 ; static size_t ROUND_UP(size_t bytes) return (((bytes) + __ALIGN-1) ~(__ALIGN - 1)); ; 5.2 内存池工作流程 维护16个自由链表（$8-128$字节） 内存不足时向系统申请大块内存 碎片回收通过自由链表管理 六、STL设计精髓总结 泛型编程思想：通过模板实现算法与数据类型的解耦 低耦合高内聚：容器、迭代器、算法通过标准接口协作 效率优先：通过内存池、红黑树等结构优化性能 可扩展性：允许用户自定义分配器、仿函数等组件","tags":["C++","STL"],"categories":["technology","编程基础"]},{"title":"MiniAgi源码阅读笔记","path":"/2025/05/03/MiniAgi 源码阅读/","content":"spinner.py在这个文件中定义了一个光标效果 def spinner_task(self): while self.busy: sys.stdout.write(next(self.spinner_generator)) sys.stdout.flush() #强制立即刷新 time.sleep(self.delay) # 定义帧率 sys.stdout.write(\\b) # 光标回退， 实现覆盖字符 sys.stdout.flush() def __enter__(self): # 启动动画线程 self.busy = True threading.Thread(target=self.spinner_task).start()def __exit__(self, exception, value, tb): #停止动画 self.busy = False time.sleep(self.delay) if exception is not None: return False return True exceptions.py这个文件主要是用来捕获模型输出中的异常，例如格式不对，缺字段，非json等。然后将这个异常抛回给上层进行处理。继承了python内置的Exception类 class InvalidLLMResponseError(Exception): Exception raised when the LLM response cant be parsed. Attributes: None commond.py在这个文件中规定了不同命令的思考链 库文件说明 import subprocess 作用：用于创建子进程，执行外部命令或脚本，并获取其输入输出结果。 典型用途： 调用系统命令（如 ls, ping, gcc, python 等）； 执行外部程序或脚本（如 shell 脚本、批处理）； 控制输入输出重定向。 from io import StringIO 作用：提供一个类 StringIO，它创建一个内存中的字符串缓冲区，可像文件一样读写。 典型用途： 在不涉及实际文件的情况下模拟文件操作； 用于测试代码中涉及文件读写的部分； 捕捉输出文本（通常与 redirect_stdout 配合使用）。 from contextlib import redirect_stdout 作用：上下文管理器，用于临时将标准输出重定向到指定对象（比如 StringIO）。 典型用途： 捕捉 print() 语句的输出； 在测试或调试中查看函数内部输出； 搭配 StringIO 捕获控制台输出为字符串处理。 from duckduckgo_search import DDGS 作用：导入 DuckDuckGo Search 的 Python 接口 DDGS 类，用于调用 DuckDuckGo 的搜索功能。 典型用途： 用代码直接进行 DuckDuckGo 搜索并获取结果； 抓取网页搜索摘要、链接、图像等； 用于构建搜索引擎接口或信息爬取工具。 class类说明在execute_commond中首先将命令进行分发 if command == memorize_thoughts: 调用 Commands.memorize_thoughts(arg)elif command == execute_python: 调用 Commands.execute_python(arg)...else: 返回 Unknown commandcommond如果过程中出现异常，返回异常信息 然后分别定义各个函数内容 miniagi.pyprompt设计关于prompt的具体设计原则，会写另外一篇博客进行说明在MiniAgi项目中prompt的设计是这样的设计中融入了思维链、少样本提示，并且强调了自我一致性。同时，在prompt的设计中加入了自我批评CRITIC_PROMPT，以及记忆重整HISTORY_SUMMARY_HINT等。具体如下 角色设定（Role Conditioning）fYou are an autonomous agent running on operating_system. 明确模型的“身份”：你是运行在某操作系统上的自主代理智能体；通过设定操作系统，有利于后续与 Shell 命令、文件路径等交互时保持一致（如 Linux vs Windows）。 目标导向任务（Objective Conditioning） OBJECTIVE: objective (e.g. Find a recipe for chocolate chip cookies) 为当前任务设定一个清晰目标，使模型行为聚焦； 模仿人类代理行为，把目标当成“长期任务”，以实现规划式思维。 历史上下文注入（Context）Previous steps: context 引入以往已执行的动作观察结果，作为“记忆”或状态追踪； 支持多步推理和上下文保持，是链式思维（Chain-of-Thought）的关键。 明确命令集（命令语言接口设计） 定义一个有限状态机风格的 API 接口，明确智能体能执行的动作范围； 强制每一步只能执行一个命令，避免无控制的自然语言混乱； 命令覆盖典型任务：记忆、推理、代码执行、数据处理、与用户对话、终止。 明确格式约束（动作语法模板） r[YOUR_REASONING]/rc[COMMAND]/c[ARGUMENT] r：模型的推理或动机说明； c：结构化命令名称（对应预定义命令集）； [ARGUMENT]：命令参数； 该格式是构化动作标注，利于解析、监督、记录、回放等； 防止输出中出现自然语言噪声或模糊行为。 行为限制与安全提示 不要重复命令 不要链式多个命令 Python 要以 print 输出结尾 process_data ingest_data 只能处理单文件 不搜索 GPT 已知知识 保证行为唯一性、可解释性、可控性； 限制模型可能的幻觉或冗余行为； 强化对命令执行前提条件的检查（如输出格式约束）。 示例示范（Few-shot Prompting） rThink about skills and interests.../rcmemorize_thoughts/crSearch for websites.../rcweb_search/c 提供多个风格统一、结构良好的行为范例； 用作 few-shot learning 的提示模板，让模型模仿人类代理行为； 示例覆盖了多种命令使用方式、输入格式、常见应用。 MiniAgi类class MiniAGI: 表示一个自主智能体（Agent）类。 属性（Attributes）定义了 agent 的各种组件和运行状态。 def __init__( # 参数初始化列表 self, agent_model: str, summarizer_model: str, objective: str, max_context_size: int, max_memory_item_size: int, debug: bool = False ): 构造函数：创建 MiniAGI 实例，初始化内部模型和参数。 # 初始化用于生成行为的主模型 self.agent = ThinkGPT( model_name=agent_model, request_timeout=600, verbose=False ) # 初始化用于生成摘要的模型 self.summarizer = ThinkGPT( model_name=summarizer_model, request_timeout=600, verbose=False ) # 保存目标、内存限制、是否调试等配置参数 self.objective = objective self.max_context_size = max_context_size self.max_memory_item_size = max_memory_item_size self.debug = debug # 以下是状态相关的字符串属性，初始设为空 self.summarized_history = self.criticism = self.thought = self.proposed_command = self.proposed_arg = # 使用 tiktoken 获取模型的 tokenizer 编码器 self.encoding = tiktoken.encoding_for_model(self.agent.model_name) def __update_memory(self, action: str, observation: str, update_summary: bool = True): 内部方法：根据行动和观察结果更新记忆。 如果 observation 太长，会先进行摘要处理。 # 如果 observation 超过允许大小，进行摘要 if len(self.encoding.encode(observation)) self.max_memory_item_size: observation = self.summarizer.chunked_summarize( observation, self.max_memory_item_size, instruction_hint=OBSERVATION_SUMMARY_HINT ) # 构造新记忆格式 if memorize_thoughts in action: new_memory = fACTION: memorize_thoughts THOUGHTS: observation else: new_memory = fACTION: action RESULT: observation # 如果需要更新摘要，调用 summarizer 的 summarize 方法 if update_summary: self.summarized_history = self.summarizer.summarize( fCurrent summary: self.summarized_history Add to summary: new_memory, self.max_memory_item_size, instruction_hint=HISTORY_SUMMARY_HINT ) # 将新记忆交由 agent 存储 self.agent.memorize(new_memory) def __get_context(self) - str: 内部方法：构造 agent 当前的上下文字符串。 上下文包括摘要、最近的行为和批评。 summary_len = len(self.encoding.encode(self.summarized_history)) criticism_len = len(self.encoding.encode(self.criticism)) if self.criticism else 0 # 从 agent 中获取最多能容纳的最近记忆片段 action_buffer = .join( self.agent.remember( limit=32, sort_by_order=True, max_tokens=self.max_context_size - summary_len - criticism_len ) ) # 构建最终上下文字符串 return fSUMMARY self.summarized_history PREV ACTIONS: action_buffer self.criticism def criticize(self) - str: 调用模型对 agent 最近的行为进行批评。 context = self.__get_context() self.criticism = self.agent.predict( prompt=CRITIC_PROMPT.format(context=context, objective=self.objective) ) return self.criticism def think(self): 调用模型进行推理，生成下一步操作计划。 context = self.__get_context() if self.debug: print(context) # 基于 prompt 和上下文生成原始响应 response_text = self.agent.predict( prompt=PROMPT.format(context=context, objective=self.objective) ) if self.debug: print(fRAW RESPONSE: response_text) # 使用正则表达式提取 r思考/rc命令/carg PATTERN = r^r(.*?)/rc(.*?)/c *(.*)$ try: match = re.search(PATTERN, response_text, flags=re.DOTALL | re.MULTILINE) _thought = match[1] _command = match[2] _arg = match[3] except Exception as exc: raise InvalidLLMResponseError from exc _arg = _arg.replace(```, ) # 去除可能的 markdown 格式符号 # 保存模型推理结果 self.thought = _thought self.proposed_command = _command self.proposed_arg = _arg def read_mind(self) - tuple: 获取 agent 最近的思考、命令和参数。 _arg = self.proposed_arg.replace( , \\ ) if len(self.proposed_arg) 64\\ else fself.proposed_arg[:64]....replace( , \\ ) return (self.thought, self.proposed_command, _arg) @staticmethod def __get_url_or_file(_arg: str) - str: 根据参数读取 URL 或本地文件内容。 if _arg.startswith(http://) or _arg.startswith(https://): with urlopen(_arg) as response: html = response.read() data = BeautifulSoup(html, features=lxml).get_text() else: with open(_arg, r) as file: data = file.read() return data def __process_data(self, _arg: str) - str: 对 URL 或文件进行处理，格式为：prompt|url或文件路径 args = _arg.split(|) if len(args) == 1: return Invalid command. The correct format is: prompt|file or url if len(args) 2: return Cannot process multiple input files or URLs. Process one at a time. prompt, __arg = args try: input_data = self.__get_url_or_file(__arg) except urllib.error.URLError as e: return fError: str(e) except OSError as e: return fError: str(e) if len(self.encoding.encode(input_data)) self.max_context_size: input_data = self.summarizer.chunked_summarize( input_data, self.max_context_size, instruction_hint=OBSERVATION_SUMMARY_HINT ) return self.agent.predict( prompt=fRETRIEVAL_PROMPT prompt INPUT DATA: input_data ) def __ingest_data(self, _arg: str) - str: 只读取 URL 或文件内容（不进行指令解析），返回文本或摘要。 try: data = self.__get_url_or_file(_arg) except urllib.error.URLError as e: return fError: str(e) except OSError as e: return fError: str(e) if len(self.encoding.encode(data)) self.max_memory_item_size: data = self.summarizer.chunked_summarize( data","tags":["MCP","AI","MiniAGI"],"categories":["technology","AI"]},{"title":"Prompt设计（2）","path":"/2025/05/02/prompt设计(2)/","content":"零样本提示提示 将文本分类成中性、负面或正面文本：我认为这次假期还可以情感： 输出 中性 指令调整已被证明可以改善零样本学习Wei等人（2022）。指令调整本质上是在通过指令描述的数据集上微调模型的概念。此外，RLHF（来自人类反馈的强化学习）已被采用以扩展指令调整，其中模型被调整以更好地适应人类偏好。这一最新发展推动了像ChatGPT这样的模型。我们将在接下来的章节中讨论所有这些方法和方法。 少样本提示即在prompt中给出一个实例，来帮助模型进行理解 这太棒了！// Negative这太糟糕了！// Positive哇，那部电影太棒了！// Positive多么可怕的节目！// Negative COT 关于零样本COT：即在后面加入”让我们逐步思考” 自动思维链（Auto-Cot），即利用 LLMs “让我们一步一步地思考” 提示来生成一个接一个的推理链。这种自动过程仍然可能在生成的链中出现错误。为了减轻错误的影响，演示的多样性很重要。 一般首先要先将任务分解成为不同的、连续的步骤 使用XML来构建清晰的交接 对每个任务要求构建清晰的目标 要根据模型的表现进行Prompt的迭代 自我一致性自我一致性旨在“替换链式思维提示中使用的天真贪婪解码方法”。其想法是通过少样本 CoT 采样多个不同的推理路径，并使用生成结果选择最一致的答案。这有助于提高 CoT 提示在涉及算术和常识推理的任务中的性能。其实本质上是设计相同范式的问题与解答，帮助模型建立一致性 Q：林中有15棵树。林业工人今天将在林中种树。完成后，将有21棵树。林业工人今天种了多少棵树？ A：我们从15棵树开始。后来我们有21棵树。差异必须是他们种树的数量。因此，他们必须种了21-15 6棵树。答案是6。 Q：停车场有3辆汽车，又来了2辆汽车，停车场有多少辆汽车？ A：停车场已经有3辆汽车。又来了2辆。现在有3 + 2 5辆汽车。答案是5。 …. 当我6岁时，我的妹妹是我的一半年龄。现在我70岁了，我的妹妹多大？ TOTTOT本质上是将思考过程建模成一个多步，分支的思考树。每个节点都是一个思考过程。可以通过合理设计Prompt来实现TOT的结构。目前较为流行的TOT结构包括基于深度搜索、广度搜索等策略的。另一种基于强化学习训练出的TOT训练器。假设三位不同的专家来回答这个问题。所有专家都写下他们思考这个问题的第一个步骤，然后与大家分享。然后，所有专家都写下他们思考的下一个步骤并分享。以此类推，直到所有专家写完他们思考的所有步骤。只要大家发现有专家的步骤出错了，就让这位专家离开。请问...如何将TOT应用于模型的建构中是下一步要了解的方向自动推理并使用工具（ART）是在2023年提出的一个新的框架，这个框架使用冻结的LLM来自动生成包含中间推理步骤的程序 在接到新的任务的时候，从任务库中选择多部推理和使用工具的示范 在测试中，调用外部工具，先暂停生成，将工具整合后继续生成 就目前所了解到的，基本的Prompt设计主要还是基于普通的设计，或加入一些思维链提示链等。另外还有一部分为了提高泛化性能，使用了LLM来生成prompt进而生成答案，","tags":["AI","Prompt"],"categories":["technology","AI"]},{"title":"Prompt设计（1）","path":"/2025/05/01/prompt设计/","content":"prompt是用户输入给LLM的文本信息，是用来明确告知模型想要解决的问题，或者完成的任务。市面上已经有了一些关于prompt扩写、完善的工具，例如百炼。另外对prompt的设计实际上是一个迭代过程，可以通过openai等平台的playground进行大量的试验。在prompt中避免说不要做什么，而是应该要做什么。要非常具体地说明你希望模型执行的指令和任务。提示越具描述性和详细，结果越好。特别是当你对生成的结果或风格有要求时，这一点尤为重要。不存在什么特定的词元（tokens）或关键词（tokens）能确定带来更好的结果。更重要的是要有一个具有良好格式和描述性的提示词。事实上，在提示中提供示例对于获得特定格式的期望输出非常有效。 在设计提示时，还应注意提示的长度，因为提示的长度是有限制的。想一想你需要多么的具体和详细。包含太多不必要的细节不一定是好的方法。这些细节应该是相关的，并有助于完成手头的任务。这是你需要进行大量实验的事情。我们鼓励大量实验和迭代，以优化适用于你应用的提示。 基础结构较为通用的prompt结构如下： 输出：应该明确指出模型的输出内容的具体形式，确保LLM的输出能够满足后续的需求。 受众：需要明确指出面向的读者群体。以及适用的平台，在输出代码时可以有好的兼容性。 优化prompt 在prompt中提供期望的输出样例，可以让LLM模仿我们所要求的规范、格式、概念等要求进行输出。同时也能够使输出更加的统一。从而稳定模型表现。背景你很擅长编写小红书种草笔记，喜欢增加丰富的emoji元素。目的请生成一篇小红书种草笔记，推广强森吹风机。吹风机的优点是：体积小、高颜值、风力大、干得快、智能控温不伤发。受众喜欢追求时尚的年轻人，尤其是年轻女性输出小红书文章格式，充满emoji元素，简洁但内容充实语气与风格（提供了几种示例）我亲测过+n种好物+谁适合谁受益 这个秘诀让你的话语超有信服力！ 比如：亲自尝试了很多美白神器，终于挖到宝！仅俩月，肌肤变得嫩滑透亮，自我感觉飘飘欲仙~ 此法特为想大晒体验的小伙伴们量身定制，还能精准安利，助人避坑！难题出没+揭秘原因+终极解药 这公式助你条理清晰地分享，内容价值爆棚！ 案例：渴望秀发如丝？揭秘时刻来啦！原来我一直遗漏关键一步，直到遇见它！换用这款洗发水，秀发显著改善，光泽get！ 此法逻辑严密，不仅分享秘籍，还引导读者找到问题破解之道。独到见解+深度剖析+巧妙推荐 这公式帮你自然流露心声，还能温馨种草！ 示例：我觉得每个女孩都该有份挚爱，生活因此而精彩。手帐成了我的小确幸，每当提笔，幸福指数飙升！ 它助你畅所欲言，同时不经意间传递心头好，双赢策略！亲身经历+成果展示 这公式让你的情感表达鲜活又感人！ 场景：回想起夏夜海边的蚊灾，满身红包的绝望，直到遇见救星！现在，光滑肌肤让我裙摆飞扬，自信回归！ 它让你的故事活灵活现，分享喜悦与感恩之情，触动人心！ 而对于复杂任务，为LLM设定一个任务完成的步骤是十分重要的。（但如何设计一个泛化能力更强的任务步骤） 使用不常见的分隔符号来区分内容区域的界限标识。在构建复杂的 Prompt 时，采用特定的分隔符来界定不同内容单元是极为关键的，这一做法显著增强了 LLM 对 Prompt 正确解析的能力。随着任务复杂度的增加，合理利用分隔符越能提升 LLM 的表现。分隔符的选择应着眼于那些在自然语言文本中罕见的、独特的字符组合，例如：###、===、等。这些特殊符号序列并无固定规则，关键在于其辨识度高，确保模型能够明确区分这些符号是作为内容区域的界限标识，而非文本中的普通标点或语法组成部分。 思维链和提示链我们可以通过要求输出整个的推理过程进行思维链，另外还有思维树，Boosting of thought等。 另：文生图prompt指南提示词 主体（主体描述）+ 场景（场景描述）+ 风格（定义风格）+ 镜头语言 + 氛围词 + 细节修饰 主体描述：确定主体清晰地描述图像中的主体，包括其特征、动作等。例如，“一个可爱的10岁中国小女孩，穿着红色衣服”。场景描述：场景描述是对主体所处环境特征细节的描述，可通过形容词或短句列举。定义风格：定义风格是明确地描述图像所应具有的特定艺术风格、表现手法或视觉特征。例如，“水彩风格”、“漫画风格”常见风格化详见下方提示词词典。镜头语言：镜头语言包含景别、视角等，常见镜头语言详见提示词词典。氛围词：氛围词是对预期画面氛围的描述，例如“梦幻”、“孤独”、“宏伟”，常见氛围词详见提示词词典。细节修饰：细节修饰是对画面进一步的精细化和优化，以增强图像的细节表现力、丰富度和美感。例如“光源的位置”、“道具搭配”、“环境细节”，“高分辨率”等。 另：文生视频prompt提示词 主体 + 场景 + 运动 主体：主体是视频内容的主要表现对象，可以是人、动物、植物、物品或非物理真实存在的想象物体。场景：场景是主体所处的环境，包含背景、前景，可以是物理存在的真实空间或想象出来的虚构场景。运动：运动包含主体的具体运动和非主体的运动状态，可以是静止、小幅度运动、大幅度运动、局部运动或整体动势。运镜描述： 运镜描述 + 主体（主体描述）+ 场景（场景描述）+ 运动（运动描述）+ 镜头语言 + 氛围词 + 风格化","tags":["AI","Prompt"],"categories":["technology","AI"]},{"title":"agent学习","path":"/2025/04/28/agent/","content":"Agent工作逻辑以AutoGPT为例子，记录一下Agent的工作逻辑 1. 什么是像 AutoGPT 这样的 Agent 框架？它们是高级自动化系统，基本逻辑是： 不是简单「单轮提问-回答」 而是根据任务自己制定计划，分步行动，多轮决策，直到任务完成。普通的大模型是通过一轮轮的问答来实现最终的任务的但是创建一个合适的Agent可以实现自己想目标，自己想策略，自己执行，自己检查。 2. AutoGPT类 Agent 的运行框架核心步骤 它们基本遵循下面这个 循环逻辑： (1) 接收目标用户给一个高层目标，比如：- 写一份关于人工智能历史的详细报告，并生成成 Word 文档。 (2) 自主规划Agent自己思考出**计划 (Plan)**，比如：- 查询人工智能历史资料- 按时间线整理事件- 写成条理清晰的段落- 格式化成Word文档 (3) 行动(Action)Agent根据计划，开始一步步执行：- 调用搜索引擎 API- 分析网页内容- 写文档- 保存文件每一步都是自己调用工具、处理结果！(4) 观察(Observation)每次行动后，会自己**检查行动结果**：- 成功了？继续下一步- 失败了？重新想方法- 信息不够？再去找资料(5) 决策(Thinking)根据观察结果，决定：- 修改计划- 补充信息- 结束任务**这就是所谓的：自主决策、自主行动循环。** 3. 它们内部通常包括哪些模块？ 模块 功能 Memory（记忆） 记录任务过程，避免忘记之前做过什么 Planning（规划） 自动分解任务成小步骤 Tools（工具链） 能用的外部接口（如Web搜索、文件系统、数据库等） Reasoning（推理） 分析当前状况，决定下一步怎么做 Critic（自我评估） 检查结果，判断是否需要修正 4. 模型的参数设置 Temparature简单来说，temperature 的参数值越小，模型就会返回越确定的一个结果。如果调高该参数值，大语言模型可能会返回更随机的结果，也就是说这可能会带来更多样化或更具创造性的产出。（调小temperature）实质上，你是在增加其他可能的 token 的权重。在实际应用方面，对于质量保障（QA）等任务，我们可以设置更低的 temperature 值，以促使模型基于事实返回更真实和简洁的结果。 对于诗歌生成或其他创造性任务，适度地调高 temperature 参数值可能会更好。 top_p 同样，使用 top_p（与 temperature 一起称为核采样（nucleus sampling）的技术），可以用来控制模型返回结果的确定性。如果你需要准确和事实的答案，就把参数值调低。如果你在寻找更多样化的响应，可以将其值调高点。 使用Top P意味着只有词元集合（tokens）中包含top_p概率质量的才会被考虑用于响应，因此较低的top_p值会选择最有信心的响应。这意味着较高的top_p值将使模型考虑更多可能的词语，包括不太可能的词语，从而导致更多样化的输出。 一般建议是改变 Temperature 和 Top P 其中一个参数就行，不用两个都调整。 MAX Length您可以通过调整 max length 来控制大模型生成的 token 数。指定 Max Length 有助于防止大模型生成冗长或不相关的响应并控制成本。 stop sequence这同样是一种控制模型响应长度和结构的另外一种方法 Frequency Penalty是对下一个生成的token进行惩罚，控制重复数量。 Presence Penaltypresence penalty 也是对重复的 token 施加惩罚，但与 frequency penalty 不同的是，惩罚对于所有重复 token 都是相同的。出现两次的 token 和出现 10 次的 token 会受到相同的惩罚。 此设置可防止模型在响应中过于频繁地生成重复的词。 如果您希望模型生成多样化或创造性的文本，您可以设置更高的 presence penalty，如果您希望模型生成更专注的内容，您可以设置更低的 presence penalty。 5. 具体以 AutoGPT 举例（运行时流程）1. 用户输入：我要了解马斯克的一生2. AutoGPT: - 想一想：需要做哪些事？ - 计划出步骤： ① 搜索马斯克的生平资料 ② 按时间整理重要事件 ③ 生成简要介绍文档3. AutoGPT: - 开始第1步：调用搜索API - 得到网页结果4. AutoGPT: - 第2步：分析网页 - 挑出马斯克生平重要事件5. AutoGPT: - 第3步：组织成文档 - 保存成文本文件6. AutoGPT: - 任务完成，提示用户 这一整套都是 Agent 自己思考-执行的！ 一些典型Agent框架 项目 特点 地址 AutoGPT 早期爆火，超全面，但偏重实验 https://github.com/Torantulino/Auto-GPT BabyAGI 极简Agent，只要几百行代码，便于学习 https://github.com/yoheinakajima/babyagi CrewAI 多Agent协作系统（模拟一个小团队） https://github.com/joaomdmoura/crewAI LangChain Agent LangChain框架内置的Agent模块，商业项目多用 https://docs.langchain.com/docs/modules/","tags":["AI","agent"],"categories":["technology","AI"]},{"title":"先验概率与后验概率","path":"/2025/03/28/先验概率与后验概率/","content":"贝叶斯公式P(A|B) P(AB)P(B) {P(AB)P(A)}*P(A)P(B) 先验概率与后验概率的概念理解在区分先验概率和后验概率的时候，首先的任务是确定结果与因素。确定之后就像概率论所学，由因推果为先验概率，由果推因为后验概率。在上面的公式中，假设B为结果A为因素，那么我们在上式就完成了先验概率到后验概率的转换。 与粒子滤波的联系在粒子滤波中我们将位姿的估计转换为了求解一个联合后验概率，为了求解这个联合后验概率，通过使用CK方程将它拆解成了各个时刻的状态乘积，并求解了在已知控制输入与传感器观测值的状态先验概率，即为预测。接下来利用下一个时刻得到的传感器输入融合这个时刻的位姿和环境特征来修正先验概率，即为更新。","tags":["SLAM","概率"],"categories":["technology","SLAM"]},{"title":"视觉问题中的手眼标定算法","path":"/2025/03/20/标定/","content":"手眼标定分为两种情况，眼在手外与眼在手上手眼标定的目标是获得相机坐标系到机器人的基坐标系变换矩阵 对于基矩阵到摄像头矩阵，首先选取标定板的三个基向量拼接成为R矩阵。然后以标定板原点的坐标为t。最后为了防止标定板的xy向量不正交，最好在xz方向重新叉乘得到新的y向量，以此提升精度在选取标定板基向量时选取较远的起点与中点较为准确 将标定板放置在机械臂的末端法兰上，而这个矩阵是较为难以估计的，想办法消除左乘基坐标到摄像头矩阵的逆，左乘法兰到基坐标的矩阵的逆多次照相并联立方程","tags":["SLAM","标定"],"categories":["technology","SLAM"]},{"title":"一篇菜谱速记","path":"/2024/07/06/台球训练/","content":"入位我之前常用的入位方式是找到那根瞄准线，然后用杆延申向后拉，同时把身体趴下去。同时要注意双脚的平行。 现在采用的方式是先用右脚踩在那根瞄准线上，然后俯身，注意无所谓两只脚是否平行。俯身时夹紧大臂，小拇指完全放松，虎口靠住台球杆。 运杆 首先选中白球击球点，确定走位方式。我现在击打球时居然会偏右{% emoji blobcat 0_0 。这实在是令人难以接受，打了这么多年台球居然现在打点不纯，不过今天晚上的训练自认为已经纠正过来了。 在瞄准白球击球点的时候应该向左偏移一些。 %} 击打这个地方没什么太大改变，只需要注意运杆和击打的时候幅度不要变化太大，避免身体的剧烈起伏。同时，要注意在末尾的时候要提高杆速，这样才能够打出效果，另外，我现在的杆打杆非常硬的，杆的支撑性很强，皮头也偏硬，击打反馈也很明显，这都是要求我在击打中缓慢去感知的。 击打后不要急着起身。其实根本在于动作的连贯性，如果动作很连贯，那么应该是有惯性存在的，想快速起身也做不到。 总的来说现在的标准流程应该是 踩中那根瞄准线 注意后手的稳定性 调整白球击打点 运杆，击打","tags":["台球"],"categories":["life","运动"]},{"title":"C++阅读笔记","path":"/2024/04/05/c++/","content":"左值引用 左值引用是一种绑定，在使用时必须进行初始化 引用并非一种对象，而只是为一个已经存在的变量所起的另一种名字（我们把具有存储空间的叫做对象）。因此引用无法再绑定到其他对象。 引用类型的初始值必须是一个对象。不应该是一个值。除了常量引用。 指针 指针本身也是一个对象。与引用类似，也实现了对其他对象的间接访问。 指针一定要初始化 指针类型需要和它所指向的对象严格匹配。但有两种例外：指向常量的指针允许指向一个非常量对象。 指针的值应该为以下四种状态之一 指向一个对象 指向紧邻对象的下一个位置 空指针，即没有指向任何对象 无效指针，即除上述情况的其他值。访问无效指针将发生错误。 某些符号具有多重含义 int i = 42; int r = i; //紧随类型名出现，因此是声明的一部分r是一个引用int *p; //紧随类型名出现，因此是声明的一部分，p是一个指针p = i; //出现在表达式中，是一个取址*p = i; //*出现在表达式中，是一个解引用int r2 = *p; //是声明的一部分，*是解引用 生成空指针的方法 int p1 = nullptr;//int*p1 = 0;可以转换成任意其它类型的指针 int *p2 = 0; int *p3 = NULL; void* 指针是一种特殊的指针类型，可以存放任意对象的地址。 如何检查指针是否指向了一个合法的对象呢？ 检查是否为NULLif (p != NULL) // p 可能是一个有效指针（但不保证） 确保指针指向的是已分配的内存p = malloc(sizeof(int));p = new int;if (p) // new 在分配失败时通常会抛出异常，除非使用 `nothrow` 检查指针是否为悬空指针int *p = (int*)malloc(sizeof(int));free(p); // p 现在是悬空指针if (p) printf(p 不是 NULL，但仍然是无效的！ );//处理方法free(p);p = NULL;//智能指针std::unique_ptrint p = std::make_uniqueint(10); // 自动管理内存 const int i = 42;\tauto j = i;\tconst auto k = i;\tauto *p = i;\tconst auto j2 = i,k2 = i;\tcoutj k *p j2 k2; //42 42 42 42 42 auto与decltype指示符 auto是自动配置声明变量的类型 auto一般会忽略掉顶层const，而底层const会被保留 string 注意在字符串相加时，必须确保“+”两侧至少有一个string类型。，不能直接使用字面值相加。 string中包含了相当多的库函数，使用时可以问问gpt 迭代器 容器的访问有两种方式//下标访问，这里有一行比较巧妙地代码vectorunsigned scores(10,0);unsigned grade;while (cingrade) if(grade=100) ++scores[grade/10]; 但是需要注意的是，我们无法通过下标来实现添加元素。，应该实验push_back; 另外值得注意的是，通过下标访问容器中不存在地元素会导致严重的错误，即缓冲区溢出。 另外一种访问方式是迭代器方法 string s(my name); auto it = s.begin(); *it = toupper(*it); 在这种方式下要注意迭代器与指针的相似性与差异性 数组 数组是一种类似vector的数据结构，但是数组的大小不变，不能够随时向数组内添加元素。 在数组初始化的时候要注意字符数组的特殊，字符串字面值的结尾处还有一个空白字符。 对于复杂数组的理解（类型修饰符从右向左依次绑定）int *ptrs[10];//10个整型变量数组指针int (*Parray)[10] = arr;//指向十个整型变量的数组的指针int (arrRef)[10] = arr;//引用十个整型变量数组int *(arry)[10] = ptrs;//arry是数组的引用，该数组含有10个指针 在使用数组时编译器一般会自动将其替换成为一个指向数组收地址的指针。 运算符 重载运算符不能改变运算对象的个数，运算符的优先级，结合律 当一个对象被用作右值时，用的时对象的值（内容）。当一的对象被用作左值时，用的是对象的身份（在内存中的位置）。 对于逻辑与和逻辑或而言，都是先求左侧对象的值再求右侧对象的值，当且仅当左侧对象无法确定表达式的结果的时候才会继续计算右侧对象int i = 0, j = 0;j = i++; //j = 0,i = 1j = ++i; //j = 2;i = 2cout*p++endl;//输出当前值并指针后移一个单位 static_cast(name); 类型强转 const_cast(name); 常用于去掉变量的const属性 但是强制类型转化干扰了正常的类型检查，所以应该减少使用。 C++11版本的for循环语句for(declaration:expression)//expression所表达的必须是一个序列。例如一个花括号括起来的初始值列表、数组、容器//declaretion需要是一个能转换成该变量的类型。最好使用auto来声明。 statement; 泛型算法 标准库定义了一组泛型算法实现了一些经典算法的公共接口，如排序和搜索，他们可以用于不同类型的元素和多种容器类型。 注意泛型算法并不会改变容器本身的大小，并不能执行容器操作。 常见函数 find（） accumulate() sort() unique()函数可以将重复元素放在末端，并返回一个指向最后一个不重复元素之后的位置。再通过erase函数实现元素的删除。 lamda表达式又称为匿名函数，一般的表达形式为 [capture list](parameter list) -return type {function body} 其中capture list是一个局部变量列表 我们可以忽略列表和返回类型，但是必须永远包含捕获列表和函数体。 迭代器的类型也有很多，包括输出迭代器，输入迭代器，前向迭代器，双向迭代器，随机访问迭代器。 关联容器 关联容器并不支持顺序容器位置相关的操作，也不接受构造函数或者插入操作。 map容器可以用于键值-值的算法。set容器可以用于查找算法。 对于multimap，同样一个键值可以对应不同的值，对于multiset，容器内可以存放重复的值 pair标准库类型，可以用于生成一个键值对，并可以为这个键值对命名 动态内存（堆） 全局对象再程序启动时分配，程序结束时销毁；局部对象第一次使用前分配，函数结束时销毁，static程序启动时在静态存储区分配内存，程序结束时释放内存，析构函数会在程序退出时调用（如果有）。const如果是基础类型（如int、float），且编译器能够确定值，则通常优化为编译期常量，直接替换为字面值，不分配实际内存。如果编译器无法确定值（如引用外部变量），会分配在栈上。如果分配在栈上，则函数调用结束时销毁如果被优化为字面值，不存在分配和销毁的过程。 而对于动态变量我们可以指定他的生存周期，也即我们需要显式的销毁这个对象。 新标准库提供了两种新的智能指针，并且都在memory头文件中。 shared_ptr 允许多个指针指向同一个对象 unique_ptr 单独指针指向对象 weak_ptr 弱引用，指向shared_ptr的对象 最安全的分配使用动态内存的方式时调用make_shared函数shared_ptrint p3= make_sharedint 42; 当指向这个对象的最后一个shared_ptr被销毁的时候，sahred_ptr类会自动销毁这个对象 传递给delete的指针必须要指向动态分布的内厝或者一个空指针，要注意，编译器无法分辨指针指向的是静态还是动态分配的一个对象。 const指针指向的对象同样可以被释放 当我们delete一个指针后指针变为无效了，但是可能指针仍保存着已经被释放了的动态内存的地址，这儿时候我们应该将其赋值为NULL 智能指针需要遵守的规范 不使用相同的内置指针初始化多个智能指针 不delete get（）返回的指针 不使用get（）初始化或者reset（）另一个智能指针 如果使用了get返回的指针，那么最后一个智能指针销毁的时候，对应的指针会无效 使用的指针管理的资源不是new分配的内存，那么应该传递给他一个delete weak_ptr是一种不控制所指向对象生存期的智能指针。他指向一个shared_ptr管理的对象，并且将一个weak_ptr绑定到shared_ptr不会改变shared_ptr的引用次数 要注意动态数组在新版本下的性能往往不如一个容器。并且我们所创建的动态数组往往是数组元素类型的一个指针 面向对象程序设计 面向对象程序设计基于三个基本概念：数据抽象，继承，动态绑定。数据抽象即设计一个类来实现同类数据的存储，可以帮我我们将类的接口与实现相分离；继承可以帮助我们定义一个相似但是并不完全相同的新类；动态绑定是与继承相适应的一个函数形态，是一种多态的函数，通过传入不同的形参来实现绑定不同的派生类。","tags":["C++","编程基础"],"categories":["technology","编程基础"]},{"title":"一篇菜谱速记","path":"/2024/02/18/菜谱速记/","content":"虎皮鸡爪所需材料：鸡爪，香料1.首先处理鸡爪的指甲，然后把鸡爪劈半2.油温烧至五成热(150度左右，油略微翻涌)；倒入鸡爪（记住要盖锅盖）。刚下的时候不要翻动成型后分开炸大概5-6分钟，有小泡即可出锅。3.凉水浸泡待鸡爪表面出现大泡，调酱汁：耗油一勺；生抽两勺；老抽一勺；五香粉少许；糖醋黄酒适量4.起锅烧油，倒入葱姜桂皮八角香叶（葱姜后下）。炒出香味后导入鸡爪，酱汁翻炒上色5.倒热水炖至软烂 小炒黄牛肉所需材料：牛肉，香料1.切牛肉（横切牛羊竖切猪）。加入：烧烤料，生抽两勺，老抽一勺，一勺小苏打，适量食用油，适量耗油花椒油2.整个过程中不要加盐，先拌匀香料再油封。腌制一天。3.拍蒜末（多一些），下锅翻炒，不要超过两分钟！出锅。 红烧鸡块所需材料：鸡肉，土豆，粉丝（配菜在加盐时放入）1.备料：干辣椒，蒜，姜。鸡块焯水（冷水），倒黄酒，打浮沫。2.下入一勺豆瓣酱炒出红油，下姜葱，下蒜干辣椒3.炒至香味混合均匀，下鸡块炒至变色。再沿锅边烹生抽老抽，炒至变色。加入八角大料，适量冰糖，热水。4.炖半小时后加适量盐（汤微咸为宜）。再炖半小时出锅。5.出锅后汤汁勾芡，烹少量香油 肉末香菇所需材料：香菇，肉末1.酱汁：两勺生抽，一勺老抽，一勺耗油，适量糖，勾碗芡。香菇焯水，加黄酒，打浮沫。2.加小米辣，葱蒜翻炒，后加肉末，后加香菇。翻炒出汁后加芡汁再翻炒。出锅烹香油 地三鲜所需材料：茄子，土豆，青椒1.茄子土豆切滚刀块，青椒手掰。茄子表面拍粉（可以用塑料袋把茄子和粉装起来然后摇晃塑料袋）2.过油：茄子（三分钟，最好复炸）土豆（五分钟，至表面酥脆）青椒（过油即可）3.酱汁：生抽三勺，耗油两勺，老抽一勺，糖一勺，老抽半勺，勾碗芡。4.加蒜爆香，翻炒出锅。 地三鲜所需材料：茄子，土豆，青椒1.茄子土豆切滚刀块，青椒手掰。茄子表面拍粉（可以用塑料袋把茄子和粉装起来然后摇晃塑料袋）2.过油：茄子（三分钟，最好复炸）土豆（五分钟，至表面酥脆）青椒（过油即可）3.酱汁：生抽三勺，耗油两勺，老抽一勺，糖一勺，老抽半勺，勾碗芡。4.加蒜爆香，翻炒出锅。 五香毛豆所需材料：毛豆，香料1.先用清水和盐搓洗两遍毛豆，减去两头2.冷水下毛豆，加小苏打，盐（不要盖盖烧开5分钟）3.煮好后放入冰水，4.卤水配比：桂皮5克，香叶五片，八角三个，花椒五克，草果三个，干辣椒适量，小茴香五克，葱姜适量。加入盐30克，白糖十克，黄酒一勺，鸡精适量。5.烧开小火十分钟，加毛豆，密封冷藏。 炒蚬子所需材料：花岘1.先用清水，香油，盐，让蚬子吐沙（3小时以上）。凉水下锅焯水，加黄酒，打浮沫。2.豆瓣酱，干辣椒，蒜末翻炒（可放鸡精）3.出锅烹香油 葱爆羊肉所需材料：羊肉，葱1.备料：姜米，蒜末，蒜片，葱（滚刀块，多一些）2.起锅烧油，先放姜爆锅。下羊肉，翻炒至变色，烹陈醋，下黄豆酱油。3.待羊肉出汤后，放蒜末。收汁。放葱，再放蒜片，再烹醋。4.翻炒均匀，出国烹香油 红烧鲤鱼所需材料：鲤鱼，五花肉，香菇等配菜1.处理鱼：去背鳍，喉牙，血线；打花刀（可截两段）。2.起锅烧油，先放葱姜蒜大料桂皮，五花肉。料炸香3.鱼肉拍粉下锅煎（油温七成，即冒青烟）。全程大火4.另起锅加油，煸香菇等配料。5.将24的料放入，加热水，倒入黄酒，酱油，炖至软烂出锅。出锅加盐味定味。6.出锅勾芡少量多次。 咸蛋黄茄子所需材料：咸蛋黄，茄子1.取咸蛋黄磨碎（现用现取！）。茄子去皮切条，拍粉2.油温六成，茄子过油3.放入蒜，干辣椒，翻炒。再加咸蛋黄翻炒（用小火，会立刻起泡），加茄子，加味精4.翻炒出锅，加葱花","tags":["菜谱"],"categories":["life","菜谱"]},{"title":"周记","path":"/diary/index.html","content":"cbbe6a3acccd59c99d38aeb80053a158d9f251172eea86fbc56d73b32e1ca55d3fdd5cdef5437bf8230db9392b2cca0fb234c340bffc78e6e2367fbd2b99b0a6a4ca232a364c40a28f219e9fbb9c21c77e2a70d6d5110614989c51168d201d5dffb901fd64359fc227a5f2c34941779769fab6e4a93455fde9214a521b7b6b0e95f18d741187ef13a138f1b6ec63c4f585652a9bd938a6c0746e746f9d503ff049b27ce0f73e227513e2ad9e343307edaae6968c707f556486203723f429bdc8ec2ef503c8117c88f23a67c5db2b8e01624761181c9135fe73c2808a42c6045569bebaf4d76a70de7b0c64b7f4e578dece7f88ba9e51288d25bcd5edc60d94083503ecefc1faa4c388013c5d448cf39e371063fd318c2fb28b245fe72cbd8e74033fd7ae61b88457722060a6ef3b06cc9b0ddf2be65a804512b04d12188933a70d112bf4b2505dbef3de57a2cfcb5271ef31655eb9a7569085a8e5d6b2bedaefa03e39dccd34c5aa4ff5a174181587025cf5cb8c015170de42b5529fa82b3ae1125d06eb9d9c66634efda7cedeefcb0467bf36b7a65abe74d659a61b98366062defa04969a9aba23061c02d52bac5f7280eda285697926c2bc94af813cc7c1b1406f7a9ce9f7924650c9d1782fc79291eb7784b0beff01aec649537f8dac65dbc9d5aa739cc1db79f98ae9f340595906bbec213c5cae90e56bde98d009c1839a04128c5497f4fef4909128859d1c7e26808645ca781b2697895fa28d72f0b94c21046d2a7443fbdaabe2f138bf93f8584054e239a0e82e59b247fc9280f28f7f9b2cf55c71564187fba0be5ae47fe0c24f410c2ee331e3c38c3f8169ffa099f7321b821deef4af053105036a3aec2885ccdb7048d536b48f85259e91750fa04c8c51c91fd9c831a810698fbbeae6d1ab6c1793195c510217eb9e7124f0a64899dd2837bf211fa5d237521a3f4aedb391936c6f1e9c21e49297881982b20ad2228b302507fddc52c8c9e4bbc77f1e3808b923324e57f5e9a7fb8871e6d5810d1910628a5e2b9a150afb43739a6c3d251dc9ef3fdb93662a2af0aafe1e9140e59a4f6f63da166f9f95dbebafdf613640f35a88a869b3e493d01b0249bce0e4069624a2771c4c79b76ef7c32e8d95356cd51ee7685706c88e1dd6370d577481a3514fdeb38801d0e2aa3a3c5085373264bde507afef831f4a63b5180360d9ed1818dffc6538f51090899b094c5faa39b5547e71de37678f874ec6dc3df466cca7a01698c29275ba752d5ed6a290892af4e4978df48a70d5068cd5f442553eb1e1ccf20567d3e266c6a9b79d450fa08bccf80f99219eb718f1adc9bd28d24cba02a5836d0e4b89d195c14926cd3a6b430ce066171ecbba5d687fc58ee725bcffac02850385d389c6ed1ee5a377f150fdfcfc46f60d80f9e602a34a1bc0ef789efd7d778592a4ef6040f391fd5ac2cb47246f2bd0193d5b48031f7496897804e063606b087efd229fc901b581e4992e4c544d2752e6cf711083605c105f468a5e057bcf70c8919651084fc006b02829deb2ef72ade274a3ea230c7f11c8847696d0200e2098d936c55b8f152dfbe8b8363747780c1734892385b39f6b19a49c4f587bd09c1691867cd0cbde8dfd2cf2948bce0407e7fcfe03f3087b9240479ae8b6653bdfc45e5a03603693f91d665cdbf360e29630149756a890434ab46b7265933eeabf51566ceacd7dc7aae6a34e13213b7103a4658f4ec1fcf0a156d5f55eb3c18f26711b23bebce93000c99953be22c1f6651b8a6914b3a6e0de1dd2ef434e6a4c625446253d21df9e53fd212ea15db35895564b83e931e73466605e7e1bcc7bb708280976287732538c96808bc66374fb136687d6f754246b0849049875bc3ac151dc3c360a9c72e782727d8b45ad8c28656ef3bcc4643126c7cf8d4eaea357ae2e29e44dc1dc72f602948914526f8e42fea10f33a54b6309795be986a3f7b7b97c60b1cd0414762359395612def1b77349c40ed4fa7ed3bc988558fbe21a81876ee3053050d0acddc60f29a7a235f0a6b7ef463a064ff6a910ab90b2a613688ed374059bf653bfac413f2bbd8a5c0b0e339e1adedce8b18312bf9d2afc0637229c13c97577c908faf7606f27acb04c3a90b9851334165896148b53f063774af52bca6761022945493103f76305ca028b7dbaca9d8e72653e671e9e203f620b2b966dfcc1ca30623830e16884d40886142d4eb1b5c8d555401e464423dcb622ec5b113b0b5383ae6eb124ef6470d64f458c54bdd36127b034325f8877f99f40729378be57b42782a87e305a56be75ab5e3cd0f47f94a290d963e04e45cc90b1e17109b3838a4d20898f3bf01dc216de98f0010c75dba064434568629cc1039eb30194bd6067079e52b24264f4d513059637916868f641e588bb165a6989eaa36f33f12bc6634836ae6c7b54ffea209edfafb6a32586c795c82ade09e31c6546d4cb827a7b2ecd89a2d97bd0b91571f39943dc9974794be8b920dfa14390f9c89ac54e422d840ce5904a1afbf9a1cb04a1e57e3bda27ef376b7053c3bf20123db5da25fac7ceec0c9051389e3eee6d7ba7b229fa51cee7c12e29b81c3be792f84f432dcd4b99f0c0af54eb219784b79c654493874497c8865d94e7ef6614518b810db54b7fc0f042fda5194c737f49139f483765550978a1fb7db7e550f1fa309e29de1a3de314a9de4be8c85e078136af9803b71b753791132e53b94c43a4aceee4ccede27ac1b8803df8bbb2f93d3b2af91670d39065f1cfe09983881697f9b46f814850e7e253a993c9014967eb8b5a80328c9d16a562b026229023ca42672448787f87e52a12885328159d1081b850856261f696fa193cb0a6591a2d74620ad395714e5230cb77c2d6614d22ceee1a565558025aaa12c67e3e8d3d21d41986bd6f8dfb32e8b42fddcf403c23b4ebd6622ed8be00d95e7e8ad8aed882e84f8f6c87c32d2d0d8765b873f40abde3853164ebad306bbda1f16d8d333357574ede8ac6e30316cb04e0e053ae23444f5a2607718444db516e4e155c1d0df0a3362ca462fb53ac65ae83cf9248d2de2c4180639d54038df623a5f9aa96513d931abe7071d95b9d84d9d2b156501d54672343febad17b8df7e2b2f3ae5b4bb3168dc58880dafa1a4257b9837c5a07cfd5a3d313102d655810e8b3d2f929538b30da90dab01e3a42971d95154fbab0823c003356d144588713a29a116604111663930fcd0d92979cccb1348ebd8c5995f772b5485d48f8ab2f1b52291b7ebab1c5d3986bf9090bd5a0ca135bac7599d6941148ac88a16482748cfd0b6d4ccd87bd16631df593f6c0ccd029754e5891c951f4e7af12b1fcad7b97518c3aa8b2169f63192110685b39d498590aaf4dc4a5f6f5fa9beab75265c735c753bed2e4506648a662b994b33870e4754841e922a99e3880e133ca8e721726be9b3e06bbaf86c81092d767540695a54de0bdd47b4c085dd1d02354e4087dd02b72cc9110b3de9dc3a57068960af3422d4f7f07c5bf2e1f3bcac078facae54495b6f49b5ecd819aa1fe6526c3135efe3e3ae066c80455329651a61072fef5d600fdd992bf2b836b6d9f45144f9c195b0757d00101cb21a5a0a1e8c398a3de638482e6e119f4e74fc6a7a66c112a682a8f7d06b406c48cd18c3647d948997bcf9973a8f03cdd649a8a15c701b31cc11a2f0ebef075e17e0bd619371b10062dd9814e8e8a2a8642d1bd7f53a444771eab998ff8dfcbdc2333ec20829f700f5234fa53552e2f369f4a17727fa45c16f559ce4aaba34c82c04a740cb0c28dee67c135a12a432946fbdb083938a5729b35269ec4f5df26e34938164440fd01c5d1f7b6123951c85428624d1a02a7f2b79a59a87934e36d6806962bce5a4e88f78eded34fea38375981263cc84b82c47cdeee39651339457a8f9e74044935d3e1b2ff0f1db341b49fe2ba06e6815ab4d855796323b8c83160e4599bd3d3131e1cda1f9da33d972368e68db670c76855598e126b60fce9227f83f9c34c6846ecf2df4a6c0f935f458b1f9119946e8a9fb4ddbfc597c4a039ab43ca7b44839ff3163c5fd953dce5385484b6b7be4fcc2acae3addb7b5453650cf710150d64aa03520364aa8154d42b84b8100c30bbbc3ad8b4c0643303f81a5313f2d4f825c0c001da69600206f704db3c6c5f0185d9f2d2217a6f264434472347b76f5fb546cd03541c4e6db5af7d60072d559614ef8358495e69c7c70edd53952bed9f9697fffaaa2b16fbaa39ccf45374775a2d8d5c35b9eb2f03157df79d6bec06cefd10aa17e344ab98a54cbdb7b9d952796c6cbc146a7d45b456cb1d23fe76502b8cb8c724531ebf03ec206ad95851cebdac216909017e9e90b945e454f81d13c04354fc61405d320b46c754d1739aba616d7bd8fb9f6d032f2cf1874d1832d70e41a7511acea313b3f52ef97c35d7053284864abecc2be610c94771a3b0ce9cd9a8285cbc5047f122d493f101da0e8b97797ed40c0b076524826d9bdbca37fd575dc00350014337aef669d589d5b91afa779969b241d87653a619a4057a9c417c53ce980fd5de11044d8bb69a3329ce72e2c55577bb087178db888d72b051d0980bc47a625cc1c8da7140ecdc60b3b72abfee6f98061564dd2eb5264b6f9f6742e830cf16c64b5357b76ca35dbd7401124295590a80b087cbc3ba662318ed65d9082f0d6e1869e78708682ff7f90b56f8dbc2a07cce03834fecb4b7a817363298d6239f6e4a15607eddd44e5c02dcee2172ec1d9a6410e8f2c7d1d47b3aa435c20c25988ecaabdaf16e46ab5d0c8725c50c5dae42abd797c69053f93ad0dd7e4bd03234a8894932adff8ef803677b88d37f77bb8dc640ac229d473b7073b37c36e921ab7435f89b76cd57a4c9413d4c9520b47919f2aacc2ff5c063be43a5bbb62e718ec787816604372961f8d7eb27606e158c339443c6ef59bfe001e20226cbd9c93d97974b2082cf556fd262725f0e26093394301e135cde98bf64d610bfc8917a846c4c51c6522ef7aff231b26c1f2425de5a96693d465e7644e9abf882fd8afe88fac43ff117d79f55bacd3471ac4d70dfcb819c2253436b028b7f3b8af32528280fb0d10cb0830b6ece48bfa777576eb34ba25493e00efe2c6c1596b18ac28e52840d977ebc119d0909742ad38639b28c2156dbb5d34adba87cea483970585de44cba49ab33bdb5666e5a3a02be082bb4a709a60e3a040f0b64c3ddd736b740c1649fdc32dccfc5961908f1b5d6a6429856cac6e5d570ebf59c0f8ac3386b1e9ecd8478b88be98d1b2ef5f37a3494b96ef16a830472c69b820b917496c40478ab95ce94c2a4841910cb9f11482fbf35be6a274aa770d169f0896608d79c12764c477b18e63101a13c5aac88dbafe6f13cee462e763a4f076db4df31be83be275522f7b628723b60a87a281ad6a0a46ec367d69b173a179703e36587adb58990d7ec118c21be05ec3893fb8a318928a6d01f0ad07d5561b663a1706287d6ba14849cd65ae80c8b59c20b0c7f3136164e43a6288773946f905d24075016133a73ee64e2ea8e6805a2a9e590b754831a91cb2802f7a394c0cf6c905b205099597127ea80169126fc229e135546e559f933407943487a65d3d9c9a24938df2a239424df79fdf77fa9dea33385a9a3a3a7a2f15ecad0beff143524896faf8cb5e92e681a80e192328293ca2e58bb1327508d3782b3fe199b09a83dc42f34451b0ccdff7f9a1f4018fd9b0f96b65a12560fee7a4a5ff92d0fbc24a7d5846e7ba7eb8f1d68d5ccecc3e557621ebeb51116048b76a9c0719a839aa325fbc62a21ddbaa768e19f2e758cbb4513933b3b0decced05894368640d0c44b1e3b9cdfb7ba4cd40e15d5cc4f02dc693a2cf31c7f33ca5c0d8744d6fe62228f30a0db5b42dc85e532dab108748a647c36265a34abdda677c4572ef09f8b44137ec573095f5d9530e09ccec7c654f39cd51572f7077313759ee6d473797d90cdd76619b7524e918fc88bd73002de1909961c24ac1692ccea938649e19dfde879244c386259e4b96a25ad5664a1a1b16861c0accf8789d2168180ea6a00c01b3282a676836c9209b6f6fb2c7daad10365161a6e7ac8c822a476adfacb443137838f01ef9ddd1789d03143da615aaf995bade6cdbdcf67e72ce2f469e0ea8d9f7c84146b2af75c7ecf2e39d1a4f07a4e8514a4d54b88750a3b412027965af39f578f8f787e243b6be0a3d4db8e158d3073e85a39fbf0f05b9d307fb27164288481234ed4788849a82cae1a5426da1c31d232b2e8deab8b8647c52b32bab8fb9e0e7f7247f3a9da15f45b6dfdbc47852caa90e732e7509f5b8ce52732794d7016bc1cf7e4513ee728094e5ccfa90b65d2279f59abfa6138b406c702e3f143d3360e25ee3d4b3fe014a1ae7e6a0a858d8fbf459a709c95cd2cd6b6f06060669b8f635d3c5c55d0c1718a0071f6a836613ca5c0dcf9fc4f12e4c4ecd9ca197980174621d722ff8c3f94236633d6eb0c8908b00f4a7b41fc290b320895c325bbbe683f43ab6ea71c6bd925d57bef5ec77871e21fc6dc1fa4abd8f1c834ad8cb77cd07d7c7bc8c3a2ac021efd63f8a799fd8fed3b72ac4e889164f9f8bb70e44bf0fd452c5d74a4c1ed7f9a6c6d1880156ed56cb6b3ee6b75d7e20aeb1467278a2268873a8b13e041bedf10e3753f4dcb2895e33275e10db87a4dece0601c33cbadfa05e66682f5493c1b70e8df9b2b082ae26c174ad1053d1f9755da3f6a33801c3bdae4292032e53c2629257a1c99bc199b55a43065027956f01277d4ea7c234339b8efc888729fc2a0aebe818a52ef05c659655d2c6c62fa716c22827f92f033850f98af280c3de7f8d1124c44471134a513efef1408801d67503c45ac9d0a6245ac140aae51f81200ff424f33a444d95c62fcfd4a6391267de41f2d160341e4f2ba62e10d68e56f618fc242c17d1a91147066417165887d1ad08b6d9d78dbfdb58b3e01dec19cd57f500d05f5d809b81a4e6f2f895ca24ac85a52bc657b374aae856c0ddff82c3d3843c3269716e9c00f61cb09d420cb3d25c34b17b1b663c1fcf4a066e92a9ba5985db01a8dae7ee03e3e1b68184d60726c8dd589b54d8ae89746d4bb7092699d68f21da6230a36d23c333d906db7ca724ca30b417e519e0161e9c3a008f8d2783839a9573cd3277592b339a5d9400ae163bd236e0a2af6559123b037919e530dda86e411100848cd16dc139f55b72fd86d878bdabcebe909cc5715ad0905da5b55b47a9f70f85cea560244bb10b7c1c120fac668dc8e4bd17464487571b3c44d9e1634aa2d89054802c9e60889f972b3bf966b9077db5d309f7b990ff3711547a24409631dcd0d2704886a6c0dee86c6c512bdeeafaecebe733279b467093eabb937d928b1bc7f481f36f8407eafa056d6e6b69406647a3a1461ab225ef851d91947724480b39929feff4bc6e4e9614cdb3348620946bf4a5e9e822cee925d75660451c32c1567a9479538ba30604349feaf404414b7e4d99eb6550f7e2ed14bee92a5b002d40307d626030273150be3acec3de2b0000e766b002d9407068fbdf504533addf425b23c531ca15e39452b3dee309ecade32741f7dbe59946d92ff1b29fa88b5411074818a2681ac1dacc97fe9fee35b02706fbd0c5dae130cbf7efc6eb051edc88044075baf6fb0160fa1ae2736c08f63e14969a072982d971f612eb75e16de011c66d0d89131802296f9a6af3e1e138ac7866238faf82c23383ecf9bf39a25ca55c2c53f787ef84b2836c6a993a8885d11c4ab326e2884f97b8773440dff056c192e8fc6fdaa09b24df9a6717b13f8ebf67bf7b4ba9653ef55f9bfa293b0ff25dd25d3a494efe45784bd41e7ae17cffe25e61fb88d98a3edf72fe7225797e1e664eda7239488f7ff1f0834a2753d7d10ab389708ad386371477dee738951c18fb93e29a44977bdc9a7edca77047da9920fa8fbb9c450df04514f47002800be3ca9938d7c8e67a7d60cc9fbd124262a8b1493c697e2fd3c226a7a9890e90717c5db08a1ea25ce544502355ab0ecdcb15086b6299ed178eb7c015ca551526d6e2c424efd4bb80191c72ca3cb7dbf65ceecd12d40f1e7f521f67ad00828f67ab5c955a72df29d76a03c2af4b8c13c324e284d53edceeddbce75c09c387cbb0205c35b7c43e8790f56e704100433b60fda70fdab1e34d4833f55461f65ac236da881eeecb553aadd43f437c0078f7fb7c53868f2845587259f8f0d803b37a770c4734c354afeb0221d4f0a580f98779543493ca51529c1ed1b312b01810fbf1e6eb8b662525f5a665699bde5873b55cdedebed9e65426d5f7525d82ebdb07f7eae6e1fba4ec4d2c688551a4dee615ee362b03f5a1a706b256319737bb8ed433682a3551042d7ca48225e11babbe4b0b090d0d5cfd29399b8499718c50370569ac7fea78adb198aeb807141c98ff4d0a6732c439a826ed543c6db3fe7f35ce35974a65ac6c331967dbd29525167c2878cc6c5f0071c79bd35545fd3421b120d54ccb1e95613a5bc242feb94b5b9a449f498169025986967b095d9ee4c3811cb19ad047287eed2a5d94f5cb8fa2546b8c638e50c2b7e1bf896edd7c1f01b1ba98399717a74cf695ac14340f7cbaf0261da6a264da2b5181fe25d6e64eb5e46abfe690de2b1b32f3b999a9ab93fb370a224e8fb6d865ded9853893ddae5b66766419633a479345686d8e326c4c609e453f5220daf59d247bdf08e456e3dc8968fdc2231d95b7127b2b49d01d8e0f027d96fba02ced291697040bbb0d439ebf942a8b6e1c888d1597faa6e4feab302bcf58f2724a39331324ea219c3a21cf41332db46607549f7c140af7155b44f3d8723e4e48467d9b7d3a1e3a37a5bb5830a9b6b890c5e179a782420ec9b533d88c25dad01a3311527f207cd48627dab0f8f0c172ff9883e9ae65c64d6fa2160efe4a7a6faad0f67a0778e0706989b62c68ebac7f78bb7aaccdef9131add9f5451b81836b5de031aceaad53460e83df7173de0d46d8f99b02628aee278645a18405fa318ec61a384e4c8ca1cd4c53c1edd23ee5871de11e53ef4d8539b8a5da39976318929a9a59ae16b7388b53ef0131a9612a03be370e67c725eb0f29243391313b48432fd44a80a74a8e1c92f51e409b7df6d0ccf4b0cbfef99ebc805661ff2fee26581eec5567d39fbb9286a45b539e3acac91928fe50bde7799885c5420b880e870c76cbeb26bec53937cef4407ddfe52e55d933e0e22825cd72a73dab7831da5f962009db6aecc34ea82524bf5e4479e4e8c04769df8d3400d52a050122b14fb3ec864c33b92a1e37cf27d7cbba6e4f9a635b85e05dcf4a63f7dd42bf5dfc807793e234cc248f1bd2b54ce7f104b02c4c4d99381bc6bb1d170df8363ced1bd61c11639e575713746a5ff90d4b9a1cd78bd8db2ff0e284b9a7dffee7251371f145cdb8063ffd9fce014458b1d12ae0ff3fbdab0e6f42d0db70643d9cf2730c3b5214c463ba95855b3e8f813a1a0acab45df560cd219d7a89382fc656f92a455595da08cd695dae64aea72e211e3a2fb1d2ad0f97959fa9d03cc752fc95f6e6abe8b5d96173d6f427dc2a4b32e0af634ba2e87ed087c2c6560839528d66bf85ff327723f1c530ac45a735dc39d1bdf454faaa2d79244a4eb204be8940569bdd7f0650b6d7d27a01e907c5c76d09e1976032d42a74a6af1f77e4004ea44ebd88b11af5d2e3e94f6dcb4af430d0572316909d6e32390ab5ae905d5e1de505856b61cbc5bee15998274034dd6518e64b5fb55e95ebabc9c31d76d8bd9ed0e7c40fdd90fe5b396ac2faf43fa3333cacbcb63e4cb0d8c237959515971914e931dc836cf71deb7ce76594329702979eb04f98822225b668be924e3cb206291239338f939e1d2be0ad5598b81f204915186050d42d82c65c40d97fb4d565241acc53bbbd6c0dea6028eca0e2621c14edea9a63b757979e6b89e08ac93ee40ae163d4d5be201345f61f2222b7dafdb301a86d0de8ae90902d719946dae62e490c0d21c8051036f1c4b46ff9a681b1e50858acd57ca6ebfed67659ec8a0ec65dcd366c8599b2558bca785101005112c058f85c86f4f880ddcb225ecc08241fca7d875eecfb0e2a368a23c85b18c8e9d0d8889598febb357cf5433b136b9a192b41d056b577cd81b524eda4c16042e0a445de5563201f1602bf8136bd8c6f6e084347357c5a5c2111926929a2473fc1914179dddb4e294512445ab5cb1e371a89b8121a62a1b88ef173446abf93b39dbbb8029c9077c09be65e781211a4709622c28516619903326ead71ca22ee7ef6a8c2553c83e264ac3a9bd171a2da6341e0582ba5d34b0490952497b86e38704d05e6a18950c4e291560d294afe2566a63f857de8af7e26a785731364eadcfd565d4ef1065786d74c45173135c2f9aed920c13c7ff02ff8dd4121b94361714b64bc690a5e77f6a314f09439e8db5d1bed6d698051a6eb09bc817f08c523ac273fb8a582c737a3734c919bf4f5ebd57d9a0d2f7f501f6dd770067ec27e35a2e98a0d246c68cbd57d3b1c0b799397d879ff60946012514ec51eda5bcfb9dd4d77a37d40548b6f68d48bad729c0405386d60761f8f366fcfa62cf485d96fd461bf4c838befb2f33406daae512bfd7f94f8232e1882cd339d1acc069ab1d130677c600841a1159adf0349f9d1b0432f8f8b8a52d5a7a506b027fb55978951d2b0c4c6b2bd5a9e4cd2ff67bfcb2f910e9506878687aee1a1cfc62a21b81033778383ff13f9bff2fc1a9982dcba66e1a249c99bf4cf7b992cafd5cf7b5cfae9c948daa5b702df14c9fbb0e59c76d95ea92f345b67e88b38e942d2581bf57d00caf2432373c28364aa86f36ff1df3dfe674ad9ff34040bc36f729c1d277a94238ae092eb24351c6588319183bc93e1c9073b0cabaf9aca30c35064c538a4125911bc5c5a83576896fd022d41c8ffb6646bccd67b2f74a30cd283c188c18e3669fca4361dc98e96aa6e3c5403c2dc36f381991c6ca67c01a001f1ee3e1e37cf7a45004c57af772b2f0c3657e0f0bde86eb84b7de1900ae3bb6bac218f5e43263c97745bc9fc26d21f5edfcbd9df7bd0f36bda3de6b632f8cb3d6f2c03930aa1145fc9d24e1bf45a2aa3f9ba2297e7f6e01da66fb8760b1b3fcc24a8cf366921c19b3a82f299a1dca76a28a5aa736feb6e80f1182a293856d6ca8b1641cdf1b52225020635bbd778bd9f31b42b25cc99d4338684d212ac2857531833893a62e22f9f152957ed673c72db9fc28083c0325e75d8b27eeaa8aebd9e10b17c215f55e754178c280280d28d6abf9af9a6c3e65daf311c1fc20ea0669a17af6f179285f0a16bc5eee24b65313d320e682bb2240ff3d8c4a5305e0944ca3519c7072d4914809471ba6152db4f742a9f2f6e9fcda77d349a3d0f786bf3d46d19516ecdda554741c9cf5eb05d3454c560b6813ffbdeaf47cc559311ac2b46a02dadeb34464dc83de38c7bde84968bbeaf28e52fc01298c50d0393a6d397d97e928be799a670d0e322c530e16a4888895d4aa45769e1602891588bcb4d26be36ba2b06db6b52103c61f901c4bea93386d5c3f3a1d90bf7587e63f36e09ce9cf09809f9795ccd04cc236ade5a88c1d0e4868d56a7645c87a4933829faf567c411af9da2b73041dd194e6f64fae33834e125efbc34179b7e95267340e52a728340aeeb97ff0ee30c7c6d63c567e481e28e4547f9f9a44b60bb630d9b462d34fd453bfef730b6c76dc779c5f281181fa1636d4a6e7d45d2bdc363cca8bb9d6bcd7865a983b22e2478f0ef6d6c97e7dc1ff0a229b16f9d048aaa6d37b67c3e18d2fad47a73f1e428ff44734e82e0080e4f36ed1f5a25a1e95445d8a1d50e8d16ac8bca2526764c4e9b0943bc5a3c5b17a0df1dc4710a41c1d49a213879849c9d55bd21fdab131dc573f7fbcafea9a2d3fa88bf5d22c724bb2095458de2469359a5f67eb6cc70d00b6737a42b086cb058bd8fd276be0981e2fb16503615f7e8004020928e3cb872127f37ea9c26580c7654708c4d2be2b0033144c41ff4ed7603858b7bc32dcfa25c8e0f3931d57284a91ecbe013296700c53f481f7ceb78308c01eca7e29a4539be89096ab6a3633b16f6db00834a1ee869660871eaaca5878279e27df9626499386fac0c096baf15e2d3e48ff0c6fd5ed33968bb5484c47f700642577a844bdb9697a9dbc815212ce9c9b59bb3f62a48ba4d02d11e41d270b112d63e727c32812e49acfd498aa0c057f7be79ddc1fcc8bfc1a9050e6af98e8d214df77cabd2fd9df782ca1094010ca6401fdbf9a6cabdca45e8a335d6ab3110dc656c14c2b981c74fd9f5e75065cb85573b5a0156a3e1a09cf4a915f64ba9797c3dec93223d2e4bed385c105d786c2003d2cbe6e5dee47350703d7372e16ede7a18ee281daafcc227b2344241eeb76b141c593fbd771e42950d4944e96c60f0f51782171c91ba34132439eb568a25da084c27c7238c6f4ba62fbd210665f4c2aea3ff6ad8b5d409a12d28fd87aafa6c8bb73822d03edb0bf8f69c534f88eb846768c710e771547d5aaf11b9a5a5928c9741571759665c8debb3f6322143e797de22a183af2f7a1ffaeb4f04501541102237635bcc5a23cbcd5ca1560449196253626a7d56df629edad67cc23d04fa71ba8ac97994ef13f243d87a45c826b3902ee4ae8f1805d6cfbea1a289ebed17eff4771df9356cbb8e658def387e69e221a285960065fafa26f2e068e914d63e4f8550ffb9bb2ecafc04dcff9b0ca3c4001cd730f6148f1224be2cc849517f3515bdfafb5fce9cd0d25c5a257f4fe55a8b9572e6faad0768f23a35fcf1698af4de1f5f5f7e0f010f8b40fb05f14d1d05b46ccbaf0ffb86ed177db7a09d815465f1f96ad7368b5097715f5ede1a09d54b3ead541af6d860afd34dc5a4185a5fc6ec3e06fa9ee62e1dc71f0f77b8bc4373ff556b338eed34433335d9b2cc3a5c31c585b25edf5e6544db4c53c3cf3b44eeed698ebb15dc7178994cb05e8556e1d10a951964c9b5f9a7373845aa866c95d742133ab9f2dc9bcd3faa70eb4a3de048c75b00e5c23f66270f7c1e81d3097799a81bffc9b86a87c21caf5ba1b33b0375c28fd217d4d717ca2144c95d1756473e154ec210eccbcafe3dc6feb1142f70a6c80920f48821b492a5903cc9e77a860e14426e579f445ae9924cb7f00b2556c80c6d05361afda95d96cf2d097a5ff03e426d6b19bcd0f131af0c5c4deb8d6279d1a15ac57a524d1eb1aa9735de08ce4e97d01120c8a3965060c890c324b6e348237feab8304a2d7b917bf18a6958647198803b5fd8a2f07110b89ef5745c44e8bbeca216fb890fad7ffc9fcb34dd632b276105d657f6a02723ba020e24dab8b537f7e1c5eaee4ce92c25d9b9732eebb8af5c1e5829beb82f7cc0bdaaab11edeb636c99b89803e57e9b64e75bc8758b2ef41f302516df66c2efdc0b198bed6a4b48e3f2ac961f854b0c720fee38a82c41ab7a88b9c3e4610aa5297029355847ff54a42650ca5696b709099a73d78a16f6552e3978e6c82bf1d7036de9b18b0071c9c97fca1e377d761d277a412e494bbe420706e3c54a2df51cfa2b6604177e7ae845741b3ad7e128b011d17f42d87d005b8fcb98a3a88fcb8a137ff2d22ebf2bff2f5ed314759a4a99f8ab1c923426dbaf24a175ed302cf26aca5e6091af28bf2c3088ae9f135edcaa67bfdf14908744d3086e2b123133dff69197747a04a3d540814ef5a3a19096b52da902258dbda1a19eb8500ac8cbbb6217b12ce9630e43196452c50c325a49df6026c403b7e4db6cad039acc43bef818d661ebcb4b1f6428a9a0445be14c184c1a865c588a5840e503fe02362139fa765a3f2a109357e7e589301ef5e9c616a14a416b61ebcef99581233546d3df0cf602d9053a5904c409fd716043031a0b1b2ffbd38064daf905a87b6839c4d3bc8110ca58f68f522eaee389cc3e6272030feb7679e250af19444e4344dad7f88d2c0f007be5c382b87e9409e6d2eeb4f3e3706815d645dae2a7a03c587580a6bb46740b97036b01f2f035707b091752db1f0bb195dec27263eebd88c66686925077e7646fef97b8f5043c27ca6307c75cbbd7d30104119fddae6b1ca92ebef9c30f6a1533079ac73d0e906f1511f20766649a7dc0d38d93c77fd4ed591d07677497858b429d90979568d9bfbfb7c779aadc0f09988436ff160a53ccab82458561ad8111a08b2bd45d541a42022fb0fe9cb5c85e7f772372867ba65601877416d8fdd60c4c54b3cf0aea20b90de62b2e671fe073d1db1382e247cacf89e0490d235b4e2eaa415feb13338d79dfdb9ad6966dfbc7f8139e9a72612b618389ebd6ee2aa0f9ff8b4c7bced45752b480ae3a081b7780e9f81e94eccb28f93b4970c73fd7c99fd9686b97a0972daa524f9699ccab47c0b07472559759606411cd5ffda175cc4263f38945e05dcf4256c4bf9c6e0e96dc7b49451340e0cdd45866af97d4d922c059cb878049440657d054224692e7d181a1c01c4cdc3c814a78eb66c3dd483077d091cefdca135ad3c972e794d25bfc5e10231612176a9ea76d9aca7f2f7fad90a7a666dc081f4832ee6f9e6d1c1171f6992fcf4cfe21975c6a653993458a7cba1f987290a331578fb40bf2f4d97226b4b5919b2ca104a4ff4983b3b68c8b6dc3bee3c0ab208402a2ab4bad1e919d74755fd3805 总结你的进步吧！"}]